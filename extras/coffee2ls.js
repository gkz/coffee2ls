(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("__browserify_process",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
        && window.setImmediate;
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return window.setImmediate;
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    if (name === 'evals') return (require)('vm')
    else throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    process.cwd = function () { return cwd };
    process.chdir = function (dir) {
        if (!path) path = require('path');
        cwd = path.resolve(dir, cwd);
    };
})();

});

require.define("fs",function(require,module,exports,__dirname,__filename,process,global){// nothing to see here... no file methods for the browser

});

require.define("/lib/coffee2ls/helpers.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 2.0.0-dev
var beingDeclared, cleanMarkers, concat, concatMap, CS, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, pointToErrorLocation, usedAsExpression, usedAsExpression_;
cache$ = require('./functional-helpers');
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
foldl = cache$.foldl;
map = cache$.map;
nub = cache$.nub;
CS = require('./nodes');
this.numberLines = numberLines = function (input, startLine) {
  var lines, numbered, padSize;
  if (null == startLine)
    startLine = 1;
  lines = input.split('\n');
  padSize = ('' + (lines.length + startLine - 1)).length;
  numbered = function (accum$) {
    var currLine, i, line, pad;
    for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
      line = lines[i$];
      i = i$;
      currLine = '' + (i + startLine);
      pad = Array(padSize + 1).join('0').slice(currLine.length);
      accum$.push('' + pad + currLine + ' : ' + lines[i]);
    }
    return accum$;
  }.call(this, []);
  return numbered.join('\n');
};
cleanMarkers = function (str) {
  return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
};
this.humanReadable = humanReadable = function (str) {
  return str.replace(/\uEFEF/g, '(INDENT)').replace(/\uEFFE/g, '(DEDENT)').replace(/\uEFFF/g, '(TERM)');
};
this.formatParserError = function (input, e) {
  var found, message, realColumn, unicode;
  realColumn = cleanMarkers(('' + input.split('\n')[e.line - 1] + '\n').slice(0, e.column)).length;
  if (!(null != e.found))
    return 'Syntax error on line ' + e.line + ', column ' + realColumn + ': unexpected end of input';
  found = JSON.stringify(humanReadable(e.found));
  found = found.replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
  unicode = e.found.charCodeAt(0).toString(16).toUpperCase();
  unicode = '\\u' + '0000'.slice(unicode.length) + unicode;
  message = 'Syntax error on line ' + e.line + ', column ' + realColumn + ": unexpected '" + found + "' (" + unicode + ')';
  return '' + message + '\n' + pointToErrorLocation(input, e.line, realColumn);
};
this.pointToErrorLocation = pointToErrorLocation = function (source, line, column, numLinesOfContext) {
  var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
  if (null == numLinesOfContext)
    numLinesOfContext = 3;
  lines = source.split('\n');
  currentLineOffset = line - 1;
  startLine = currentLineOffset - numLinesOfContext;
  if (startLine < 0)
    startLine = 0;
  preLines = lines.slice(startLine, +currentLineOffset + 1);
  postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1);
  numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
  preLines = numberedLines.slice(0, preLines.length);
  postLines = numberedLines.slice(preLines.length);
  column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
  padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
  return [].slice.call(preLines).concat(['' + Array(padSize + 1).join('^') + ' :~' + Array(column).join('~') + '^'], [].slice.call(postLines)).join('\n');
};
this.beingDeclared = beingDeclared = function (assignment) {
  switch (false) {
  case !!(null != assignment):
    return [];
  case !assignment['instanceof'](CS.Identifiers):
    return [assignment.data];
  case !assignment['instanceof'](CS.Rest):
    return beingDeclared(assignment.expression);
  case !assignment['instanceof'](CS.MemberAccessOps):
    return [];
  case !assignment['instanceof'](CS.DefaultParam):
    return beingDeclared(assignment.param);
  case !assignment['instanceof'](CS.ArrayInitialiser):
    return concatMap(assignment.members, beingDeclared);
  case !assignment['instanceof'](CS.ObjectInitialiser):
    return concatMap(assignment.vals(), beingDeclared);
  default:
    throw new Error('beingDeclared: Non-exhaustive patterns in case: ' + assignment.className);
  }
};
this.declarationsFor = function (node, inScope) {
  var vars;
  vars = envEnrichments(node, inScope);
  return foldl(new CS.Undefined().g(), vars, function (expr, v) {
    return new CS.AssignOp(new CS.Identifier(v).g(), expr).g();
  });
};
usedAsExpression_ = function (ancestors) {
  var grandparent, parent;
  parent = ancestors[0];
  grandparent = ancestors[1];
  switch (false) {
  case !!(null != parent):
    return true;
  case !parent['instanceof'](CS.Program, CS.Class):
    return false;
  case !parent['instanceof'](CS.SeqOp):
    return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
  case !(parent['instanceof'](CS.Block) && parent.statements.indexOf(this) !== parent.statements.length - 1):
    return false;
  case !(parent['instanceof'](CS.Functions) && parent.body === this && null != grandparent && grandparent['instanceof'](CS.Constructor)):
    return false;
  default:
    return true;
  }
};
this.usedAsExpression = usedAsExpression = function (node, ancestors) {
  return usedAsExpression_.call(node, ancestors);
};
envEnrichments_ = function (inScope) {
  var possibilities;
  if (null == inScope)
    inScope = [];
  possibilities = function () {
    var this$, this$1;
    switch (false) {
    case !this['instanceof'](CS.AssignOp):
      return nub(beingDeclared(this.assignee));
    case !this['instanceof'](CS.Class):
      return nub(concat([
        beingDeclared(this.nameAssignee),
        envEnrichments(this.parent),
        'undefined' !== typeof name && null != name ? [name] : []
      ]));
    case !this['instanceof'](CS.ForIn, CS.ForOf):
      return nub(concat([
        concatMap(this.childNodes, (this$ = this, function (child) {
          if (in$(child, this$.listMembers)) {
            return concatMap(this$[child], function (m) {
              return envEnrichments(m, inScope);
            });
          } else {
            return envEnrichments(this$[child], inScope);
          }
        })),
        beingDeclared(this.keyAssignee),
        beingDeclared(this.valAssignee)
      ]));
    case !this['instanceof'](CS.Functions):
      return [];
    default:
      return nub(concatMap(this.childNodes, (this$1 = this, function (child) {
        if (in$(child, this$1.listMembers)) {
          return concatMap(this$1[child], function (m) {
            return envEnrichments(m, inScope);
          });
        } else {
          return envEnrichments(this$1[child], inScope);
        }
      })));
    }
  }.call(this);
  return difference(possibilities, inScope);
};
this.envEnrichments = envEnrichments = function (node, args) {
  args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
  if (null != node) {
    return envEnrichments_.apply(node, args);
  } else {
    return [];
  }
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

});

require.define("/lib/coffee2ls/functional-helpers.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 2.0.0-dev
var concat, foldl, map, nub, span;
this.any = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (fn(e))
      return true;
  }
  return false;
};
this.all = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (!fn(e))
      return false;
  }
  return true;
};
this.foldl = foldl = function (memo, list, fn) {
  var i;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    memo = fn(memo, i);
  }
  return memo;
};
this.foldl1 = function (list, fn) {
  return foldl(list[0], list.slice(1), fn);
};
this.map = map = function (list, fn) {
  return function (accum$) {
    var e;
    for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
      e = list[i$];
      accum$.push(fn(e));
    }
    return accum$;
  }.call(this, []);
};
this.concat = concat = function (list) {
  var cache$;
  return (cache$ = []).concat.apply(cache$, [].slice.call(list).concat());
};
this.concatMap = function (list, fn) {
  return concat(map(list, fn));
};
this.intersect = function (listA, listB) {
  return function (accum$) {
    var a;
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.difference = function (listA, listB) {
  return function (accum$) {
    var a;
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.nub = nub = function (list) {
  var i, result;
  result = [];
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    if (!!in$(i, result))
      continue;
    result.push(i);
  }
  return result;
};
this.union = function (listA, listB) {
  return listA.concat(function (accum$) {
    var b;
    for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
      b = cache$[i$];
      if (!!in$(b, listA))
        continue;
      accum$.push(b);
    }
    return accum$;
  }.call(this, []));
};
this.flip = function (fn) {
  return function (b, a) {
    return fn.call(this, a, b);
  };
};
this.owns = function (hop) {
  return function (a, b) {
    return hop.call(a, b);
  };
}({}.hasOwnProperty);
this.span = span = function (list, f) {
  var cache$, ys, zs;
  if (list.length === 0) {
    return [
      [],
      []
    ];
  } else if (f(list[0])) {
    cache$ = span(list.slice(1), f);
    ys = cache$[0];
    zs = cache$[1];
    return [
      [list[0]].concat([].slice.call(ys)),
      zs
    ];
  } else {
    return [
      [],
      list
    ];
  }
};
this.divMod = function (a, b) {
  var c, div, mod;
  c = a % b;
  mod = c < 0 ? c + b : c;
  div = Math.floor(a / b);
  return [
    div,
    mod
  ];
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

});

require.define("/lib/coffee2ls/nodes.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 2.0.0-dev
var ArrayInitialiser, Block, Bool, Class, CompoundAssignOp, concat, concatMap, Conditional, createNodes, difference, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, Primitives, Range, RegExp, RegExps, Slice, StaticMemberAccessOps, Super, Switch, SwitchCase, union, While;
cache$ = require('./functional-helpers');
map = cache$.map;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
nub = cache$.nub;
union = cache$.union;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNodes = function (subclasses, superclasses) {
  var className, specs;
  if (null == superclasses)
    superclasses = [];
  for (className in subclasses) {
    if (!isOwn$(subclasses, className))
      continue;
    specs = subclasses[className];
    (function (className) {
      var isCategory, klass, params, superclass;
      superclass = null != superclasses[0] ? superclasses[0] : function () {
      };
      isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
      params = 'undefined' !== typeof specs && null != specs ? function () {
        switch (specs.length) {
        case 0:
          return [];
        case 1:
        case 2:
          return specs[0];
        }
      }.call(this) : null;
      if (null != params)
        params;
      else
        params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
      klass = function (super$) {
        var externalCtor$;
        extends$(class$, super$);
        externalCtor$ = isCategory ? function () {
        } : function () {
          var i, param;
          for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
            param = params[i$];
            i = i$;
            this[param] = arguments[i];
          }
          if (null != this.initialise)
            this.initialise.apply(this, arguments);
          return this;
        };
        function class$() {
          return externalCtor$.apply(this, arguments);
        }
        class$.prototype.className = className;
        class$.superclasses = superclasses;
        return class$;
      }(superclass);
      if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
        klass.prototype.childNodes = specs[0];
      if (isCategory)
        createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
      return exports[className] = klass;
    }(className));
  }
};
createNodes({Nodes: [
    [],
    {
      BinOps: [
        [
          'left',
          'right'
        ],
        {
          AssignOps: [
            [
              'assignee',
              'expression'
            ],
            {
              AssignOp: null,
              ClassProtoAssignOp: null,
              CompoundAssignOp: [[
                  'op',
                  'assignee',
                  'expression'
                ]],
              ExistsAssignOp: null
            }
          ],
          BitOps: [
            null,
            {
              BitAndOp: null,
              BitOrOp: null,
              BitXorOp: null,
              LeftShiftOp: null,
              SignedRightShiftOp: null,
              UnsignedRightShiftOp: null
            }
          ],
          ComparisonOps: [
            null,
            {
              EQOp: null,
              GTEOp: null,
              GTOp: null,
              LTEOp: null,
              LTOp: null,
              NEQOp: null
            }
          ],
          ConcatOp: null,
          ExistsOp: null,
          ExtendsOp: null,
          InOp: null,
          InstanceofOp: null,
          LogicalOps: [
            null,
            {
              LogicalAndOp: null,
              LogicalOrOp: null
            }
          ],
          MathsOps: [
            null,
            {
              ExpOp: null,
              DivideOp: null,
              MultiplyOp: null,
              RemOp: null,
              SubtractOp: null
            }
          ],
          OfOp: null,
          PlusOp: null,
          Range: [[
              'isInclusive',
              'left',
              'right'
            ]],
          SeqOp: null
        }
      ],
      Statements: [
        [],
        {
          Break: null,
          Continue: null,
          Return: [['expression']],
          Throw: [['expression']]
        }
      ],
      UnaryOps: [
        ['expression'],
        {
          BitNotOp: null,
          DeleteOp: null,
          DoOp: null,
          LogicalNotOp: null,
          NewOp: [[
              'ctor',
              'arguments'
            ]],
          PreDecrementOp: null,
          PreIncrementOp: null,
          PostDecrementOp: null,
          PostIncrementOp: null,
          TypeofOp: null,
          UnaryExistsOp: null,
          UnaryNegateOp: null,
          UnaryPlusOp: null
        }
      ],
      MemberAccessOps: [
        null,
        {
          StaticMemberAccessOps: [
            [
              'expression',
              'memberName'
            ],
            {
              MemberAccessOp: null,
              ProtoMemberAccessOp: null,
              SoakedMemberAccessOp: null,
              SoakedProtoMemberAccessOp: null
            }
          ],
          DynamicMemberAccessOps: [
            [
              'expression',
              'indexingExpr'
            ],
            {
              DynamicMemberAccessOp: null,
              DynamicProtoMemberAccessOp: null,
              SoakedDynamicMemberAccessOp: null,
              SoakedDynamicProtoMemberAccessOp: null
            }
          ]
        }
      ],
      ChainedComparisonOp: [['expression']],
      FunctionApplications: [
        [
          'function',
          'arguments'
        ],
        {
          FunctionApplication: null,
          SoakedFunctionApplication: null
        }
      ],
      Super: [['arguments']],
      Program: [['body']],
      Block: [['statements']],
      Conditional: [[
          'condition',
          'consequent',
          'alternate'
        ]],
      ForIn: [[
          'valAssignee',
          'keyAssignee',
          'target',
          'step',
          'filter',
          'body'
        ]],
      ForOf: [[
          'isOwn',
          'keyAssignee',
          'valAssignee',
          'target',
          'filter',
          'body'
        ]],
      Switch: [[
          'expression',
          'cases',
          'alternate'
        ]],
      SwitchCase: [[
          'conditions',
          'consequent'
        ]],
      Try: [[
          'body',
          'catchAssignee',
          'catchBody',
          'finallyBody'
        ]],
      While: [[
          'condition',
          'body'
        ]],
      ArrayInitialiser: [['members']],
      ObjectInitialiser: [['members']],
      ObjectInitialiserMember: [[
          'key',
          'expression'
        ]],
      Class: [[
          'nameAssignee',
          'parent',
          'ctor',
          'body',
          'boundMembers'
        ]],
      Constructor: [['expression']],
      Functions: [
        [
          'parameters',
          'body'
        ],
        {
          Function: null,
          BoundFunction: null
        }
      ],
      DefaultParam: [[
          'param',
          'default'
        ]],
      Identifiers: [
        ['data'],
        {
          Identifier: null,
          GenSym: null
        }
      ],
      Null: null,
      Primitives: [
        ['data'],
        {
          Bool: null,
          JavaScript: null,
          Numbers: [
            null,
            {
              Int: null,
              Float: null
            }
          ],
          String: null
        }
      ],
      RegExps: [
        null,
        {
          RegExp: [[
              'data',
              'flags'
            ]],
          HeregExp: [[
              'expression',
              'flags'
            ]]
        }
      ],
      This: null,
      Undefined: null,
      Slice: [[
          'expression',
          'isInclusive',
          'left',
          'right'
        ]],
      Rest: [['expression']],
      Spread: [['expression']]
    }
  ]});
cache$1 = exports;
Nodes = cache$1.Nodes;
Primitives = cache$1.Primitives;
CompoundAssignOp = cache$1.CompoundAssignOp;
StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
Range = cache$1.Range;
ArrayInitialiser = cache$1.ArrayInitialiser;
ObjectInitialiser = cache$1.ObjectInitialiser;
NegatedConditional = cache$1.NegatedConditional;
Conditional = cache$1.Conditional;
Identifier = cache$1.Identifier;
ForOf = cache$1.ForOf;
Functions = cache$1.Functions;
While = cache$1.While;
Class = cache$1.Class;
Block = cache$1.Block;
NewOp = cache$1.NewOp;
Bool = cache$1.Bool;
FunctionApplications = cache$1.FunctionApplications;
RegExps = cache$1.RegExps;
RegExp = cache$1.RegExp;
HeregExp = cache$1.HeregExp;
Super = cache$1.Super;
Slice = cache$1.Slice;
Switch = cache$1.Switch;
Identifiers = cache$1.Identifiers;
SwitchCase = cache$1.SwitchCase;
GenSym = cache$1.GenSym;
Nodes.fromJSON = function (json) {
  return exports[json.type].fromJSON(json);
};
Nodes.prototype.listMembers = [];
Nodes.prototype.toJSON = function () {
  var child, json;
  json = {
    type: this.className,
    'line': this.line,
    'column': this.column,
    range: [
      this.offset,
      null != this.raw ? this.offset + this.raw.length : void 0
    ],
    'raw': this.raw
  };
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      json[child] = function (accum$) {
        var p;
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.toJSON());
        }
        return accum$;
      }.call(this, []);
    } else {
      json[child] = null != this[child] ? this[child].toJSON() : void 0;
    }
  }
  return json;
};
Nodes.prototype.fold = function (memo, fn) {
  var child;
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      memo = function (accum$) {
        var p;
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.fold(memo, fn));
        }
        return accum$;
      }.call(this, []);
    } else {
      memo = this[child].fold(memo, fn);
    }
  }
  return fn(memo, this);
};
Nodes.prototype.clone = function () {
  var ctor, k, n, v;
  ctor = function () {
  };
  ctor.prototype = this.constructor.prototype;
  n = new ctor;
  for (k in this) {
    if (!isOwn$(this, k))
      continue;
    v = this[k];
    n[k] = v;
  }
  return n;
};
Nodes.prototype['instanceof'] = function (ctors) {
  var ctor, superclasses;
  ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
  superclasses = map(this.constructor.superclasses, function (c) {
    return c.prototype.className;
  });
  for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
    ctor = ctors[i$];
    if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
      continue;
    return true;
  }
  return false;
};
Nodes.prototype.r = function (param$) {
  this.raw = param$;
  return this;
};
Nodes.prototype.p = function (param$, param$1, param$2) {
  this.line = param$;
  this.column = param$1;
  this.offset = param$2;
  return this;
};
Nodes.prototype.generated = false;
Nodes.prototype.g = function () {
  this.generated = true;
  return this;
};
handlePrimitives = function (ctor, primitives) {
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toJSON = function () {
    var json, primitive;
    json = Nodes.prototype.toJSON.call(this);
    for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
      primitive = primitives[i$];
      json[primitive] = this[primitive];
    }
    return json;
  };
};
handlePrimitives(Class, ['boundMembers']);
handlePrimitives(CompoundAssignOp, ['op']);
handlePrimitives(ForOf, ['isOwn']);
handlePrimitives(HeregExp, ['flags']);
handlePrimitives(Identifiers, ['data']);
handlePrimitives(Primitives, ['data']);
handlePrimitives(Range, ['isInclusive']);
handlePrimitives(RegExp, [
  'data',
  'flags'
]);
handlePrimitives(Slice, ['isInclusive']);
handlePrimitives(StaticMemberAccessOps, ['memberName']);
handleLists = function (ctor, listProps) {
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayInitialiser, ['members']);
handleLists(Block, ['statements']);
handleLists(Functions, ['parameters']);
handleLists(FunctionApplications, ['arguments']);
handleLists(NewOp, ['arguments']);
handleLists(ObjectInitialiser, ['members']);
handleLists(Super, ['arguments']);
handleLists(Switch, ['cases']);
handleLists(SwitchCase, ['conditions']);
Block.wrap = function (s) {
  return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
};
Class.prototype.initialise = function () {
  if (null != this.boundMembers)
    this.boundMembers;
  else
    this.boundMembers = [];
  this.name = new GenSym('class');
  if (null != this.nameAssignee)
    return this.name = function () {
      switch (false) {
      case !this.nameAssignee['instanceof'](Identifier):
        return new Identifier(this.nameAssignee.data);
      case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
        return new Identifier(this.nameAssignee.memberName);
      default:
        return this.name;
      }
    }.call(this);
};
Class.prototype.childNodes.push('name');
ObjectInitialiser.prototype.keys = function () {
  return map(this.members, function (m) {
    return m.key;
  });
};
ObjectInitialiser.prototype.vals = function () {
  return map(this.members, function (m) {
    return m.expression;
  });
};
RegExps.prototype.initialise = function (_, flags) {
  var flag;
  this.flags = {};
  for (var cache$2 = [
        'g',
        'i',
        'm',
        'y'
      ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
    flag = cache$2[i$];
    this.flags[flag] = in$(flag, flags);
  }
};
exports.NegatedConditional = function (super$) {
  extends$(NegatedConditional, super$);
  function NegatedConditional() {
    Conditional.apply(this, arguments);
  }
  return NegatedConditional;
}(Conditional);
exports.NegatedWhile = function (super$) {
  extends$(NegatedWhile, super$);
  function NegatedWhile() {
    While.apply(this, arguments);
  }
  return NegatedWhile;
}(While);
exports.Loop = function (super$) {
  extends$(Loop, super$);
  function Loop(body) {
    While.call(this, new Bool(true).g(), body);
  }
  return Loop;
}(While);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  var key;
  for (key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

});

require.define("/lib/coffee2ls/preprocessor.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 2.0.0-dev
var EventEmitter, fs, inspect, pointToErrorLocation, Preprocessor, StringScanner;
fs = require('fs');
EventEmitter = require('events').EventEmitter;
pointToErrorLocation = require('./helpers').pointToErrorLocation;
StringScanner = require('StringScanner');
inspect = function (o) {
  return require('util').inspect(o, false, 9e9, true);
};
this.Preprocessor = Preprocessor = function (super$) {
  var DEDENT, INDENT, processInput, TERM, ws;
  extends$(Preprocessor, super$);
  ws = '\\t\\x0B\\f \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  INDENT = '\uefef';
  DEDENT = '\ueffe';
  TERM = '\uefff';
  function Preprocessor() {
    this.base = this.indent = null;
    this.context = [];
    this.context.peek = function () {
      if (this.length) {
        return this[this.length - 1];
      } else {
        return null;
      }
    };
    this.context.err = function (c) {
      throw new Error('Unexpected ' + inspect(c));
    };
    this.context.observe = function (c) {
      var top;
      top = this.peek();
      switch (c) {
      case '"""':
      case "'''":
      case '"':
      case "'":
      case '###':
      case '`':
      case '///':
      case '/':
        if (top === c) {
          this.pop();
        } else {
          this.push(c);
        }
        break;
      case INDENT:
      case '#':
      case '#{':
      case '[':
      case '(':
      case '{':
      case '\\':
      case 'regexp-[':
      case 'regexp-(':
      case 'regexp-{':
      case 'heregexp-#':
      case 'heregexp-[':
      case 'heregexp-(':
      case 'heregexp-{':
        this.push(c);
        break;
      case DEDENT:
        if (!(top === INDENT))
          this.err(c);
        this.pop();
        break;
      case '\n':
        if (!(top === '#' || top === 'heregexp-#'))
          this.err(c);
        this.pop();
        break;
      case ']':
        if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
          this.err(c);
        this.pop();
        break;
      case ')':
        if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
          this.err(c);
        this.pop();
        break;
      case '}':
        if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
          this.err(c);
        this.pop();
        break;
      case 'end-\\':
        if (!(top === '\\'))
          this.err(c);
        this.pop();
        break;
      default:
        throw new Error('undefined token observed: ' + c);
      }
      return this;
    };
    this.ss = new StringScanner('');
  }
  Preprocessor.prototype.p = function (s) {
    if (null != s)
      this.emit('data', s);
    return s;
  };
  Preprocessor.prototype.scan = function (r) {
    return this.p(this.ss.scan(r));
  };
  processInput = function (isEnd) {
    return function (data) {
      var context, delta, lastChar, level, lines, message, newLevel, nonIdentifierBefore, pos, spaceBefore, tok;
      if (!isEnd)
        this.ss.concat(data);
      while (!this.ss.eos()) {
        switch (this.context.peek()) {
        case null:
        case INDENT:
        case '#{':
        case '[':
        case '(':
        case '{':
          if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
            this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
            if (!isEnd && null != this.ss.check(new RegExp('[' + ws + '\\n]*$')))
              return;
            if (null != this.base) {
              if (!(null != this.scan(this.base))) {
                throw new Error('inconsistent base indentation');
              }
            } else {
              this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
            }
            if (null != this.indent) {
              level = function (accum$) {
                var c;
                for (var i$ = 0, length$ = this.context.length; i$ < length$; ++i$) {
                  c = this.context[i$];
                  if (!(c === INDENT))
                    continue;
                  accum$.push(0);
                }
                return accum$;
              }.call(this, []).length;
              if (this.ss.check(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}[^' + ws + '#]'))) {
                this.scan(new RegExp('(?:' + this.indent + '){' + (level + 1) + '}'));
                this.context.observe(INDENT);
                this.p(INDENT);
              } else if (level > 0 && this.ss.check(new RegExp('(?:' + this.indent + '){0,' + (level - 1) + '}[^' + ws + ']'))) {
                newLevel = 0;
                while (this.scan(new RegExp('' + this.indent + ''))) {
                  ++newLevel;
                }
                delta = level - newLevel;
                while (delta--) {
                  this.context.observe(DEDENT);
                  this.p('' + DEDENT + TERM);
                }
              } else if (this.ss.check(new RegExp('(?:' + this.indent + '){' + level + '}[^' + ws + ']'))) {
                this.scan(new RegExp('(?:' + this.indent + '){' + level + '}'));
              } else {
                lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
                message = 'Syntax error on line ' + lines.length + ': invalid indentation';
                context = pointToErrorLocation(this.ss.str, lines.length, 1 + (level + 1) * this.indent.length);
                throw new Error('' + message + '\n' + context);
              }
            } else if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
              this.indent = this.scan(new RegExp('[' + ws + ']+'));
              this.context.observe(INDENT);
              this.p(INDENT);
            }
          }
          tok = function () {
            switch (this.context.peek()) {
            case '[':
              this.scan(/[^\n'"\\\/#`[({\]]+/);
              return this.scan(/\]/);
            case '(':
              this.scan(/[^\n'"\\\/#`[({)]+/);
              return this.scan(/\)/);
            case '#{':
            case '{':
              this.scan(/[^\n'"\\\/#`[({}]+/);
              return this.scan(/\}/);
            default: {
                this.scan(/[^\n'"\\\/#`[({]+/);
                return null;
              }
            }
          }.call(this);
          if (tok) {
            this.context.observe(tok);
            continue;
          }
          if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/\//)) {
            pos = this.ss.position();
            if (pos > 1) {
              lastChar = this.ss.string()[pos - 2];
              spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
              nonIdentifierBefore = /[\W_$]/.test(lastChar);
            }
            if (pos === 1 || (spaceBefore ? !this.ss.check(new RegExp('[' + ws + '=]')) : nonIdentifierBefore))
              this.context.observe('/');
          }
          break;
        case '\\':
          if (this.scan(/[\s\S]/))
            this.context.observe('end-\\');
          break;
        case '"""':
          this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/#{|"""/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/#{|"""/)) {
            this.context.observe(tok);
          }
          break;
        case '"':
          this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/#{|"/))
            this.context.observe(tok);
          break;
        case "'''":
          this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/'''/))
            this.context.observe(tok);
          break;
        case "'":
          this.scan(/(?:[^'\\]+|\\.)+/);
          this.ss.scan(/\\\n/);
          if (tok = this.scan(/'/))
            this.context.observe(tok);
          break;
        case '###':
          this.scan(/(?:[^#]+|##?(?!#))+/);
          if (tok = this.scan(/###/))
            this.context.observe(tok);
          break;
        case '#':
          this.scan(/[^\n]+/);
          if (tok = this.scan(/\n/))
            this.context.observe(tok);
          break;
        case '`':
          this.scan(/[^`]+/);
          if (tok = this.scan(/`/))
            this.context.observe(tok);
          break;
        case '///':
          this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
          if (tok = this.scan(/#{|\/\/\/|\\/)) {
            this.context.observe(tok);
          } else if (this.ss.scan(/#/)) {
            this.context.observe('heregexp-#');
          } else if (tok = this.scan(/[\[]/)) {
            this.context.observe('heregexp-' + tok);
          }
          break;
        case 'heregexp-[':
          this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
          if (tok = this.scan(/[\]\\]|#{|\/\/\//))
            this.context.observe(tok);
          break;
        case 'heregexp-#':
          this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
          if (tok = this.scan(/\n|\/\/\//))
            this.context.observe(tok);
          break;
        case '/':
          this.scan(/[^[/\\]+/);
          if (tok = this.scan(/[\/\\]/)) {
            this.context.observe(tok);
          } else if (tok = this.scan(/\[/)) {
            this.context.observe('regexp-' + tok);
          }
          break;
        case 'regexp-[':
          this.scan(/[^\]\\]+/);
          if (tok = this.scan(/[\]\\]/))
            this.context.observe(tok);
        }
      }
      if (isEnd) {
        this.scan(new RegExp('[' + ws + '\\n]*$'));
        while (this.context.length && INDENT === this.context.peek()) {
          this.context.observe(DEDENT);
          this.p('' + DEDENT + TERM);
        }
        if (this.context.length)
          throw new Error('Unclosed ' + inspect(this.context.peek()) + ' at EOF');
        this.emit('end');
        return;
      }
    };
  };
  Preprocessor.prototype.processData = processInput(false);
  Preprocessor.prototype.processEnd = processInput(true);
  Preprocessor.processSync = function (input) {
    var output, pre;
    pre = new Preprocessor;
    output = '';
    pre.emit = function (type, data) {
      if (type === 'data')
        return output += data;
    };
    pre.processData(input);
    pre.processEnd();
    return output;
  };
  return Preprocessor;
}(EventEmitter);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  var key;
  for (key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}

});

require.define("events",function(require,module,exports,__dirname,__filename,process,global){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = list.indexOf(listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

});

require.define("/node_modules/StringScanner/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"./lib/StringScanner"}
});

require.define("/node_modules/StringScanner/lib/StringScanner.js",function(require,module,exports,__dirname,__filename,process,global){(function() {
  var StringScanner;
  StringScanner = (function() {
    function StringScanner(str) {
      this.str = str != null ? str : '';
      this.str = '' + this.str;
      this.pos = 0;
      this.lastMatch = {
        reset: function() {
          this.str = null;
          this.captures = [];
          return this;
        }
      }.reset();
      this;
    }
    StringScanner.prototype.bol = function() {
      return this.pos <= 0 || (this.str[this.pos - 1] === "\n");
    };
    StringScanner.prototype.captures = function() {
      return this.lastMatch.captures;
    };
    StringScanner.prototype.check = function(pattern) {
      var matches;
      if (this.str.substr(this.pos).search(pattern) !== 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str;
    };
    StringScanner.prototype.checkUntil = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
    };
    StringScanner.prototype.clone = function() {
      var clone, prop, value, _ref;
      clone = new this.constructor(this.str);
      clone.pos = this.pos;
      clone.lastMatch = {};
      _ref = this.lastMatch;
      for (prop in _ref) {
        value = _ref[prop];
        clone.lastMatch[prop] = value;
      }
      return clone;
    };
    StringScanner.prototype.concat = function(str) {
      this.str += str;
      return this;
    };
    StringScanner.prototype.eos = function() {
      return this.pos === this.str.length;
    };
    StringScanner.prototype.exists = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return patternPos;
    };
    StringScanner.prototype.getch = function() {
      return this.scan(/./);
    };
    StringScanner.prototype.match = function() {
      return this.lastMatch.str;
    };
    StringScanner.prototype.matches = function(pattern) {
      this.check(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.matched = function() {
      return this.lastMatch.str != null;
    };
    StringScanner.prototype.matchSize = function() {
      if (this.matched()) {
        return this.match().length;
      } else {
        return null;
      }
    };
    StringScanner.prototype.peek = function(len) {
      return this.str.substr(this.pos, len);
    };
    StringScanner.prototype.pointer = function() {
      return this.pos;
    };
    StringScanner.prototype.setPointer = function(pos) {
      pos = +pos;
      if (pos < 0) {
        pos = 0;
      }
      if (pos > this.str.length) {
        pos = this.str.length;
      }
      return this.pos = pos;
    };
    StringScanner.prototype.reset = function() {
      this.lastMatch.reset();
      this.pos = 0;
      return this;
    };
    StringScanner.prototype.rest = function() {
      return this.str.substr(this.pos);
    };
    StringScanner.prototype.scan = function(pattern) {
      var chk;
      chk = this.check(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.scanUntil = function(pattern) {
      var chk;
      chk = this.checkUntil(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.skip = function(pattern) {
      this.scan(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.skipUntil = function(pattern) {
      this.scanUntil(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.string = function() {
      return this.str;
    };
    StringScanner.prototype.terminate = function() {
      this.pos = this.str.length;
      this.lastMatch.reset();
      return this;
    };
    StringScanner.prototype.toString = function() {
      return "#<StringScanner " + (this.eos() ? 'fin' : "" + this.pos + "/" + this.str.length + " @ " + (this.str.length > 8 ? "" + (this.str.substr(0, 5)) + "..." : this.str)) + ">";
    };
    return StringScanner;
  })();
  StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
  StringScanner.prototype.clear = StringScanner.prototype.terminate;
  StringScanner.prototype.dup = StringScanner.prototype.clone;
  StringScanner.prototype.endOfString = StringScanner.prototype.eos;
  StringScanner.prototype.exist = StringScanner.prototype.exists;
  StringScanner.prototype.getChar = StringScanner.prototype.getch;
  StringScanner.prototype.position = StringScanner.prototype.pointer;
  StringScanner.StringScanner = StringScanner;
  module.exports = StringScanner;
}).call(this);

});

require.define("util",function(require,module,exports,__dirname,__filename,process,global){var events = require('events');

exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

});

require.define("/lib/coffee2ls/parser.js",function(require,module,exports,__dirname,__filename,process,global){module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "program": parse_program,
        "toplevelBlock": parse_toplevelBlock,
        "toplevelStatement": parse_toplevelStatement,
        "block": parse_block,
        "statement": parse_statement,
        "expression": parse_expression,
        "secondaryStatement": parse_secondaryStatement,
        "secondaryExpression": parse_secondaryExpression,
        "expressionworthy": parse_expressionworthy,
        "seqExpression": parse_seqExpression,
        "postfixControlFlowOp": parse_postfixControlFlowOp,
        "postfixControlFlowExpression": parse_postfixControlFlowExpression,
        "assignmentExpression": parse_assignmentExpression,
        "assignmentOp": parse_assignmentOp,
        "CompoundAssignmentOperators": parse_CompoundAssignmentOperators,
        "compoundAssignmentOp": parse_compoundAssignmentOp,
        "existsAssignmentOp": parse_existsAssignmentOp,
        "logicalOrExpression": parse_logicalOrExpression,
        "logicalAndExpression": parse_logicalAndExpression,
        "bitwiseOrExpression": parse_bitwiseOrExpression,
        "bitwiseXorExpression": parse_bitwiseXorExpression,
        "bitwiseAndExpression": parse_bitwiseAndExpression,
        "existentialExpression": parse_existentialExpression,
        "comparisonExpression": parse_comparisonExpression,
        "relationalExpression": parse_relationalExpression,
        "relationalExpressionOperator": parse_relationalExpressionOperator,
        "bitwiseShiftExpression": parse_bitwiseShiftExpression,
        "additiveExpression": parse_additiveExpression,
        "multiplicativeExpression": parse_multiplicativeExpression,
        "exponentiationExpression": parse_exponentiationExpression,
        "prefixExpression": parse_prefixExpression,
        "postfixExpression": parse_postfixExpression,
        "leftHandSideExpression": parse_leftHandSideExpression,
        "argumentList": parse_argumentList,
        "argumentListContents": parse_argumentListContents,
        "argument": parse_argument,
        "secondaryArgumentList": parse_secondaryArgumentList,
        "secondaryArgumentRest": parse_secondaryArgumentRest,
        "secondaryArgument": parse_secondaryArgument,
        "callExpression": parse_callExpression,
        "superExpression": parse_superExpression,
        "newExpression": parse_newExpression,
        "memberExpression": parse_memberExpression,
        "memberAccess": parse_memberAccess,
        "accesses": parse_accesses,
        "MemberAccessOps": parse_MemberAccessOps,
        "primaryExpression": parse_primaryExpression,
        "contextVar": parse_contextVar,
        "JSLiteral": parse_JSLiteral,
        "spread": parse_spread,
        "conditional": parse_conditional,
        "conditionalBody": parse_conditionalBody,
        "elseClause": parse_elseClause,
        "while": parse_while,
        "loop": parse_loop,
        "try": parse_try,
        "tryBody": parse_tryBody,
        "catchClause": parse_catchClause,
        "finallyClause": parse_finallyClause,
        "class": parse_class,
        "extendee": parse_extendee,
        "classBody": parse_classBody,
        "classBlock": parse_classBlock,
        "classStatement": parse_classStatement,
        "constructor": parse_constructor,
        "staticAssignment": parse_staticAssignment,
        "classProtoAssignment": parse_classProtoAssignment,
        "forOf": parse_forOf,
        "forIn": parse_forIn,
        "switch": parse_switch,
        "switchBody": parse_switchBody,
        "switchBlock": parse_switchBlock,
        "case": parse_case,
        "caseConditions": parse_caseConditions,
        "functionLiteral": parse_functionLiteral,
        "functionBody": parse_functionBody,
        "parameter": parse_parameter,
        "rest": parse_rest,
        "parameterList": parse_parameterList,
        "range": parse_range,
        "arrayLiteral": parse_arrayLiteral,
        "arrayLiteralBody": parse_arrayLiteralBody,
        "arrayLiteralMemberList": parse_arrayLiteralMemberList,
        "arrayLiteralMember": parse_arrayLiteralMember,
        "arrayLiteralMemberSeparator": parse_arrayLiteralMemberSeparator,
        "objectLiteral": parse_objectLiteral,
        "objectLiteralBody": parse_objectLiteralBody,
        "objectLiteralMemberList": parse_objectLiteralMemberList,
        "objectLiteralMember": parse_objectLiteralMember,
        "ObjectInitialiserKeys": parse_ObjectInitialiserKeys,
        "implicitObjectLiteral": parse_implicitObjectLiteral,
        "implicitObjectLiteralMemberList": parse_implicitObjectLiteralMemberList,
        "implicitObjectLiteralMemberSeparator": parse_implicitObjectLiteralMemberSeparator,
        "implicitObjectLiteralMember": parse_implicitObjectLiteralMember,
        "implicitObjectLiteralMemberValue": parse_implicitObjectLiteralMemberValue,
        "macro": parse_macro,
        "bool": parse_bool,
        "Numbers": parse_Numbers,
        "decimal": parse_decimal,
        "integer": parse_integer,
        "decimalDigit": parse_decimalDigit,
        "hexDigit": parse_hexDigit,
        "octalDigit": parse_octalDigit,
        "bit": parse_bit,
        "string": parse_string,
        "stringData": parse_stringData,
        "interpolation": parse_interpolation,
        "regexp": parse_regexp,
        "regexpData": parse_regexpData,
        "hereregexpData": parse_hereregexpData,
        "throw": parse_throw,
        "return": parse_return,
        "continue": parse_continue,
        "break": parse_break,
        "undefined": parse_undefined,
        "null": parse_null,
        "unassignable": parse_unassignable,
        "CompoundAssignable": parse_CompoundAssignable,
        "Assignable": parse_Assignable,
        "positionalDestructuring": parse_positionalDestructuring,
        "positionalDestructuringBody": parse_positionalDestructuringBody,
        "positionalDestructuringMemberList": parse_positionalDestructuringMemberList,
        "positionalDestructuringMember": parse_positionalDestructuringMember,
        "namedDestructuring": parse_namedDestructuring,
        "namedDestructuringBody": parse_namedDestructuringBody,
        "namedDestructuringMemberList": parse_namedDestructuringMemberList,
        "namedDestructuringMember": parse_namedDestructuringMember,
        "identifier": parse_identifier,
        "identifierName": parse_identifierName,
        "identifierStart": parse_identifierStart,
        "identifierPart": parse_identifierPart,
        "__": parse___,
        "_": parse__,
        "comment": parse_comment,
        "singleLineComment": parse_singleLineComment,
        "blockComment": parse_blockComment,
        "whitespace": parse_whitespace,
        "INDENT": parse_INDENT,
        "DEDENT": parse_DEDENT,
        "TERM": parse_TERM,
        "TERMINATOR": parse_TERMINATOR,
        "TERMINDENT": parse_TERMINDENT,
        "AND": parse_AND,
        "BREAK": parse_BREAK,
        "BY": parse_BY,
        "CATCH": parse_CATCH,
        "CONTINUE": parse_CONTINUE,
        "CLASS": parse_CLASS,
        "DELETE": parse_DELETE,
        "DO": parse_DO,
        "ELSE": parse_ELSE,
        "EXTENDS": parse_EXTENDS,
        "FALSE": parse_FALSE,
        "FINALLY": parse_FINALLY,
        "FOR": parse_FOR,
        "IF": parse_IF,
        "IN": parse_IN,
        "INSTANCEOF": parse_INSTANCEOF,
        "IS": parse_IS,
        "ISNT": parse_ISNT,
        "LOOP": parse_LOOP,
        "NEW": parse_NEW,
        "NO": parse_NO,
        "NOT": parse_NOT,
        "NULL": parse_NULL,
        "OF": parse_OF,
        "OFF": parse_OFF,
        "ON": parse_ON,
        "OR": parse_OR,
        "OWN": parse_OWN,
        "RETURN": parse_RETURN,
        "SWITCH": parse_SWITCH,
        "SUPER": parse_SUPER,
        "THEN": parse_THEN,
        "THIS": parse_THIS,
        "THROW": parse_THROW,
        "TRUE": parse_TRUE,
        "TRY": parse_TRY,
        "TYPEOF": parse_TYPEOF,
        "UNDEFINED": parse_UNDEFINED,
        "UNLESS": parse_UNLESS,
        "UNTIL": parse_UNTIL,
        "WHEN": parse_WHEN,
        "WHILE": parse_WHILE,
        "YES": parse_YES,
        "SharedKeywords": parse_SharedKeywords,
        "JSKeywords": parse_JSKeywords,
        "CSKeywords": parse_CSKeywords,
        "StandardPredefinedMacros": parse_StandardPredefinedMacros,
        "reserved": parse_reserved,
        "UnicodeEscapeSequence": parse_UnicodeEscapeSequence,
        "UnicodeLetter": parse_UnicodeLetter,
        "UnicodeCombiningMark": parse_UnicodeCombiningMark,
        "UnicodeDigit": parse_UnicodeDigit,
        "UnicodeConnectorPunctuation": parse_UnicodeConnectorPunctuation,
        "ZWNJ": parse_ZWNJ,
        "ZWJ": parse_ZWJ
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "program";
      }
      
      var pos = { offset: 0, line: 1, column: 1, seenCR: false };
      var reportFailures = 0;
      var rightmostFailuresPos = { offset: 0, line: 1, column: 1, seenCR: false };
      var rightmostFailuresExpected = [];
      var cache = {};
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function clone(object) {
        var result = {};
        for (var key in object) {
          result[key] = object[key];
        }
        return result;
      }
      
      function advance(pos, n) {
        var endOffset = pos.offset + n;
        
        for (var offset = pos.offset; offset < endOffset; offset++) {
          var ch = input.charAt(offset);
          if (ch === "\n") {
            if (!pos.seenCR) { pos.line++; }
            pos.column = 1;
            pos.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            pos.line++;
            pos.column = 1;
            pos.seenCR = true;
          } else {
            pos.column++;
            pos.seenCR = false;
          }
        }
        
        pos.offset += n;
      }
      
      function matchFailed(failure) {
        if (pos.offset < rightmostFailuresPos.offset) {
          return;
        }
        
        if (pos.offset > rightmostFailuresPos.offset) {
          rightmostFailuresPos = clone(pos);
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_program() {
        var cacheKey = "program@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse__();
          if (r6 !== null) {
            r7 = parse_toplevelBlock();
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, leader, b) {
              var block;
              if(b) {
                block = b[1];
                return new CS.Program(block).r(leader + b[0] + block.raw).p(line, column, offset);
              } else {
                return new CS.Program().r(leader).p(line, column, offset);
              }
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_toplevelBlock() {
        var cacheKey = "toplevelBlock@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_toplevelStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_toplevelStatement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_toplevelStatement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, s, ss, term) {
              var raw = s.raw + ss.map(function(s){ return s[0] + s[1] + s[2] + s[3].raw; }).join('') + term;
              return new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_toplevelStatement() {
        var cacheKey = "toplevelStatement@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r4 = clone(pos);
        reportFailures++;
        r3 = parse_return();
        if (r3 === null) {
          r3 = parse_continue();
          if (r3 === null) {
            r3 = parse_break();
          }
        }
        reportFailures--;
        if (r3 === null) {
          r3 = "";
        } else {
          r3 = null;
          pos = clone(r4);
        }
        if (r3 !== null) {
          r4 = parse_statement();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, s) { return s; })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_block() {
        var cacheKey = "block@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_statement();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_statement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_statement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, s, ss, term) {
              var raw = s.raw + ss.map(function(s){ return s[0] + s[1] + s[2] + s[3].raw; }).join('') + term;
              return new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_statement() {
        var cacheKey = "statement@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expression();
        if (r0 === null) {
          r0 = parse_return();
          if (r0 === null) {
            r0 = parse_continue();
            if (r0 === null) {
              r0 = parse_break();
              if (r0 === null) {
                r0 = parse_throw();
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_expression() {
        var cacheKey = "expression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r0 = parse_seqExpression();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryStatement() {
        var cacheKey = "secondaryStatement@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_secondaryExpression();
        if (r0 === null) {
          r0 = parse_return();
          if (r0 === null) {
            r0 = parse_continue();
            if (r0 === null) {
              r0 = parse_break();
              if (r0 === null) {
                r0 = parse_throw();
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryExpression() {
        var cacheKey = "secondaryExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r0 = parse_assignmentExpression();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_expressionworthy() {
        var cacheKey = "expressionworthy@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_functionLiteral();
        if (r0 === null) {
          r0 = parse_conditional();
          if (r0 === null) {
            r0 = parse_while();
            if (r0 === null) {
              r0 = parse_loop();
              if (r0 === null) {
                r0 = parse_try();
                if (r0 === null) {
                  r0 = parse_forOf();
                  if (r0 === null) {
                    r0 = parse_forIn();
                    if (r0 === null) {
                      r0 = parse_class();
                      if (r0 === null) {
                        r0 = parse_switch();
                        if (r0 === null) {
                          r0 = parse_implicitObjectLiteral();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_seqExpression() {
        var cacheKey = "seqExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_postfixControlFlowExpression();
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse__();
          if (r6 !== null) {
            if (input.charCodeAt(pos.offset) === 59) {
              r7 = ";";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              r8 = r8 !== null ? r8 : "";
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_expression();
                  if (r10 !== null) {
                    r4 = [r6, r7, r8, r9, r10];
                  } else {
                    r4 = null;
                    pos = clone(r5);
                  }
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
              } else {
                r4 = null;
                pos = clone(r5);
              }
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, right) {
              if(!right) return left;
              var raw = left.raw + right[0] + right[1] + right[2] + right[3] + right[4].raw;
              return new CS.SeqOp(left, right[4]).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixControlFlowOp() {
        var cacheKey = "postfixControlFlowOp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_IF();
        if (r3 === null) {
          r3 = parse_UNLESS();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpression();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, kw, ws, e) { return {type: kw, cond: e, raw: kw + ws + e.raw}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_WHILE();
          if (r3 === null) {
            r3 = parse_UNTIL();
          }
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_assignmentExpression();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, kw, ws, e) { return {type: kw, cond: e, raw: kw + ws + e.raw}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse_FOR();
            if (r3 !== null) {
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_Assignable();
                if (r5 !== null) {
                  r6 = parse__();
                  if (r6 !== null) {
                    r8 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 44) {
                      r9 = ",";
                      advance(pos, 1);
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                    if (r9 !== null) {
                      r10 = parse__();
                      if (r10 !== null) {
                        r11 = parse_Assignable();
                        if (r11 !== null) {
                          r12 = parse__();
                          if (r12 !== null) {
                            r7 = [r9, r10, r11, r12];
                          } else {
                            r7 = null;
                            pos = clone(r8);
                          }
                        } else {
                          r7 = null;
                          pos = clone(r8);
                        }
                      } else {
                        r7 = null;
                        pos = clone(r8);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r8);
                    }
                    r7 = r7 !== null ? r7 : "";
                    if (r7 !== null) {
                      r8 = parse_IN();
                      if (r8 !== null) {
                        r9 = parse__();
                        if (r9 !== null) {
                          r10 = parse_assignmentExpression();
                          if (r10 !== null) {
                            r12 = clone(pos);
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_BY();
                              if (r14 !== null) {
                                r15 = parse__();
                                if (r15 !== null) {
                                  r16 = parse_assignmentExpression();
                                  if (r16 !== null) {
                                    r11 = [r13, r14, r15, r16];
                                  } else {
                                    r11 = null;
                                    pos = clone(r12);
                                  }
                                } else {
                                  r11 = null;
                                  pos = clone(r12);
                                }
                              } else {
                                r11 = null;
                                pos = clone(r12);
                              }
                            } else {
                              r11 = null;
                              pos = clone(r12);
                            }
                            r11 = r11 !== null ? r11 : "";
                            if (r11 !== null) {
                              r13 = clone(pos);
                              r14 = parse__();
                              if (r14 !== null) {
                                r15 = parse_WHEN();
                                if (r15 !== null) {
                                  r16 = parse__();
                                  if (r16 !== null) {
                                    r17 = parse_assignmentExpression();
                                    if (r17 !== null) {
                                      r12 = [r14, r15, r16, r17];
                                    } else {
                                      r12 = null;
                                      pos = clone(r13);
                                    }
                                  } else {
                                    r12 = null;
                                    pos = clone(r13);
                                  }
                                } else {
                                  r12 = null;
                                  pos = clone(r13);
                                }
                              } else {
                                r12 = null;
                                pos = clone(r13);
                              }
                              r12 = r12 !== null ? r12 : "";
                              if (r12 !== null) {
                                r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, ws0, val, ws1, maybeKey, ws2, list, maybeStep, maybeFilter) {
                  var key = maybeKey ? maybeKey[2] : null,
                      step = maybeStep ? maybeStep[3] : new CS.Int(1).r('1').g(),
                      filter = maybeFilter ? maybeFilter[3] : null;
                  return 0,
                    { type: 'for-in'
                    , val: val, key: key, list: list, step: step, filter: filter
                    , raw: 'for' + ws0 + val.raw + ws1 + (key ? maybeKey[0] + maybeKey[1] + key.raw + maybeKey[3] : '') +
                      'in' + ws2 + list.raw + (step ? maybeStep[0] + 'by' + maybeStep[2] + step.raw : '') +
                      (filter ? maybeFilter[0] + 'when' + maybeFilter[2] + filter.raw : '')
                    };
                })(r1.offset, r1.line, r1.column, r4, r5, r6, r7, r9, r10, r11, r12);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = clone(pos);
                  r7 = parse_OWN();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r5 = [r7, r8];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                  r5 = r5 !== null ? r5 : "";
                  if (r5 !== null) {
                    r6 = parse_Assignable();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r9 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 44) {
                          r10 = ",";
                          advance(pos, 1);
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_Assignable();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r8 = [r10, r11, r12, r13];
                              } else {
                                r8 = null;
                                pos = clone(r9);
                              }
                            } else {
                              r8 = null;
                              pos = clone(r9);
                            }
                          } else {
                            r8 = null;
                            pos = clone(r9);
                          }
                        } else {
                          r8 = null;
                          pos = clone(r9);
                        }
                        r8 = r8 !== null ? r8 : "";
                        if (r8 !== null) {
                          r9 = parse_OF();
                          if (r9 !== null) {
                            r10 = parse__();
                            if (r10 !== null) {
                              r11 = parse_assignmentExpression();
                              if (r11 !== null) {
                                r13 = clone(pos);
                                r14 = parse__();
                                if (r14 !== null) {
                                  r15 = parse_WHEN();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r17 = parse_assignmentExpression();
                                      if (r17 !== null) {
                                        r12 = [r14, r15, r16, r17];
                                      } else {
                                        r12 = null;
                                        pos = clone(r13);
                                      }
                                    } else {
                                      r12 = null;
                                      pos = clone(r13);
                                    }
                                  } else {
                                    r12 = null;
                                    pos = clone(r13);
                                  }
                                } else {
                                  r12 = null;
                                  pos = clone(r13);
                                }
                                r12 = r12 !== null ? r12 : "";
                                if (r12 !== null) {
                                  r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, ws0, maybeOwn, key, ws1, maybeVal, ws2, obj, maybeFilter) {
                    var own = !!maybeOwn,
                        val = maybeVal ? maybeVal[2] : null,
                        filter = maybeFilter ? maybeFilter[3] : null;
                    return 0,
                      { type: 'for-of'
                      , own: own, key: key, val: val, obj: obj, filter: filter
                      , raw: 'for' + ws0 + (own ? 'own' + maybeOwn[1] : '') + key.raw + ws1 +
                        (val ? maybeVal[0] + maybeVal[1] + val.raw + maybeVal[3] : '') + 'of' + ws2 + obj.raw +
                        (filter ? maybeFilter[0] + 'when' + maybeFilter[2] + filter.raw : '')
                      };
                  })(r1.offset, r1.line, r1.column, r4, r5, r6, r7, r8, r10, r11, r12);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixControlFlowExpression() {
        var cacheKey = "postfixControlFlowExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_secondaryStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_postfixControlFlowOp();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_postfixControlFlowOp();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, expr, postfixes) {
              return foldl(function(expr, postfixContainer){
                var raw, constructor, cond,
                    ws = postfixContainer[0],
                    postfix = postfixContainer[1],
                    indicator = postfix.type;
                switch(indicator){
                  case 'if':
                  case 'unless':
                    raw = expr.raw + ws + postfix.raw;
                    constructor = (indicator == 'unless') ? CS.NegatedConditional : CS.Conditional;
                    cond = (indicator == 'unless') ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                    return new constructor(cond, expr, null).r(raw).p(line, column, offset)
                  case 'while':
                  case 'until':
                    raw = expr.raw + ws + postfix.raw;
                    constructor = (indicator == 'until') ? CS.NegatedWhile : CS.While;
                    cond = (indicator == 'until') ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                    return new constructor(cond, expr).r(raw).p(line, column, offset)
                  case 'for-in':
                    raw = expr.raw + ws + postfix.raw;
                    return new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr).r(raw).p(line, column, offset);
                  case 'for-of':
                    raw = expr.raw + ws + postfix.raw;
                    return new CS.ForOf(postfix.own, postfix.key, postfix.val, postfix.obj, postfix.filter, expr).r(raw).p(line, column, offset);
                }
              }, expr, postfixes)
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentExpression() {
        var cacheKey = "assignmentExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_assignmentOp();
        if (r0 === null) {
          r0 = parse_compoundAssignmentOp();
          if (r0 === null) {
            r0 = parse_existsAssignmentOp();
            if (r0 === null) {
              r0 = parse_logicalOrExpression();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentOp() {
        var cacheKey = "assignmentOp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_Assignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 61) {
              r5 = "=";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (r5 !== null) {
              r7 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r6 = "=";
                advance(pos, 1);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r6 === null) {
                r6 = "";
              } else {
                r6 = null;
                pos = clone(r7);
              }
              if (r6 !== null) {
                r8 = clone(pos);
                r9 = clone(pos);
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
                if (r7 !== null) {
                  r7 = (function(offset, line, column, t, e, d) { return {raw: t + e.raw + d, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                }
                if (r7 === null) {
                  pos = clone(r8);
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, t, ws1, e) { return {raw: t + ws1 + e.raw, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, ws0, right) {
                var raw = left.raw + ws0 + '=' + right.raw;
                return new CS.AssignOp(left, right.expr).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CompoundAssignmentOperators() {
        var cacheKey = "CompoundAssignmentOperators@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.substr(pos.offset, 2) === "**") {
          r0 = "**";
          advance(pos, 2);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"**\"");
          }
        }
        if (r0 === null) {
          if (input.charCodeAt(pos.offset) === 42) {
            r0 = "*";
            advance(pos, 1);
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"*\"");
            }
          }
          if (r0 === null) {
            if (input.charCodeAt(pos.offset) === 47) {
              r0 = "/";
              advance(pos, 1);
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (r0 === null) {
              if (input.charCodeAt(pos.offset) === 37) {
                r0 = "%";
                advance(pos, 1);
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"%\"");
                }
              }
              if (r0 === null) {
                if (input.charCodeAt(pos.offset) === 43) {
                  r0 = "+";
                  advance(pos, 1);
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (r0 === null) {
                  if (input.charCodeAt(pos.offset) === 45) {
                    r0 = "-";
                    advance(pos, 1);
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (r0 === null) {
                    if (input.substr(pos.offset, 2) === "<<") {
                      r0 = "<<";
                      advance(pos, 2);
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"<<\"");
                      }
                    }
                    if (r0 === null) {
                      if (input.substr(pos.offset, 3) === ">>>") {
                        r0 = ">>>";
                        advance(pos, 3);
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\">>>\"");
                        }
                      }
                      if (r0 === null) {
                        if (input.substr(pos.offset, 2) === ">>") {
                          r0 = ">>";
                          advance(pos, 2);
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\">>\"");
                          }
                        }
                        if (r0 === null) {
                          r0 = parse_AND();
                          if (r0 === null) {
                            r0 = parse_OR();
                            if (r0 === null) {
                              if (input.substr(pos.offset, 2) === "&&") {
                                r0 = "&&";
                                advance(pos, 2);
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"&&\"");
                                }
                              }
                              if (r0 === null) {
                                if (input.substr(pos.offset, 2) === "||") {
                                  r0 = "||";
                                  advance(pos, 2);
                                } else {
                                  r0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"||\"");
                                  }
                                }
                                if (r0 === null) {
                                  if (input.charCodeAt(pos.offset) === 38) {
                                    r0 = "&";
                                    advance(pos, 1);
                                  } else {
                                    r0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"&\"");
                                    }
                                  }
                                  if (r0 === null) {
                                    if (input.charCodeAt(pos.offset) === 94) {
                                      r0 = "^";
                                      advance(pos, 1);
                                    } else {
                                      r0 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"^\"");
                                      }
                                    }
                                    if (r0 === null) {
                                      if (input.charCodeAt(pos.offset) === 124) {
                                        r0 = "|";
                                        advance(pos, 1);
                                      } else {
                                        r0 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"|\"");
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_compoundAssignmentOp() {
        var cacheKey = "compoundAssignmentOp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_CompoundAssignmentOperators();
            if (r5 !== null) {
              if (input.charCodeAt(pos.offset) === 61) {
                r6 = "=";
                advance(pos, 1);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (r6 !== null) {
                r8 = clone(pos);
                r9 = clone(pos);
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
                if (r7 !== null) {
                  r7 = (function(offset, line, column, t, e, d) { return {raw: t + e.raw + d, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                }
                if (r7 === null) {
                  pos = clone(r8);
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, t, ws1, e) { return {raw: t + ws1 + e.raw, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, ws0, op, right) {
                var raw = left.raw + ws0 + op + '=' + right.raw;
                return new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right.expr).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_existsAssignmentOp() {
        var cacheKey = "existsAssignmentOp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.substr(pos.offset, 2) === "?=") {
              r5 = "?=";
              advance(pos, 2);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?=\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = clone(pos);
                r9 = clone(pos);
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
                if (r7 !== null) {
                  r7 = (function(offset, line, column, t, e, d) { return {raw: t + e.raw + d, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                }
                if (r7 === null) {
                  pos = clone(r8);
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, t, ws1, e) { return {raw: t + ws1 + e.raw, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, ws0, ws1, right) {
                var raw = left.raw + ws0 + '?=' + right.raw;
                return new CS.ExistsAssignOp(left, right.expr).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_logicalOrExpression() {
        var cacheKey = "logicalOrExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_logicalAndExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.substr(pos.offset, 2) === "||") {
              r8 = "||";
              advance(pos, 2);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"||\"");
              }
            }
            if (r8 === null) {
              r8 = parse_OR();
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_logicalAndExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.substr(pos.offset, 2) === "||") {
                r8 = "||";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"||\"");
                }
              }
              if (r8 === null) {
                r8 = parse_OR();
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_logicalAndExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new CS.LogicalOrOp(expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_logicalAndExpression() {
        var cacheKey = "logicalAndExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_bitwiseOrExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.substr(pos.offset, 2) === "&&") {
              r8 = "&&";
              advance(pos, 2);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"&&\"");
              }
            }
            if (r8 === null) {
              r8 = parse_AND();
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_bitwiseOrExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.substr(pos.offset, 2) === "&&") {
                r8 = "&&";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&&\"");
                }
              }
              if (r8 === null) {
                r8 = parse_AND();
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_bitwiseOrExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new CS.LogicalAndOp(expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bitwiseOrExpression() {
        var cacheKey = "bitwiseOrExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_bitwiseXorExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos.offset) === 124) {
              r8 = "|";
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"|\"");
              }
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_bitwiseXorExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos.offset) === 124) {
                r8 = "|";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"|\"");
                }
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_bitwiseXorExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new CS.BitOrOp(expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bitwiseXorExpression() {
        var cacheKey = "bitwiseXorExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_bitwiseAndExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos.offset) === 94) {
              r8 = "^";
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"^\"");
              }
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_bitwiseAndExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos.offset) === 94) {
                r8 = "^";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"^\"");
                }
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_bitwiseAndExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new CS.BitXorOp(expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bitwiseAndExpression() {
        var cacheKey = "bitwiseAndExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_existentialExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos.offset) === 38) {
              r8 = "&";
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_existentialExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos.offset) === 38) {
                r8 = "&";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_existentialExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new CS.BitAndOp(expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_existentialExpression() {
        var cacheKey = "existentialExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_comparisonExpression();
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse__();
          if (r6 !== null) {
            if (input.charCodeAt(pos.offset) === 63) {
              r7 = "?";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (r7 !== null) {
              r9 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r8 = "=";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r8 === null) {
                r8 = "";
              } else {
                r8 = null;
                pos = clone(r9);
              }
              if (r8 !== null) {
                r9 = parse_TERMINATOR();
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r11 = parse_expressionworthy();
                    if (r11 === null) {
                      r11 = parse_existentialExpression();
                    }
                    if (r11 !== null) {
                      r4 = [r6, r7, r8, r9, r10, r11];
                    } else {
                      r4 = null;
                      pos = clone(r5);
                    }
                  } else {
                    r4 = null;
                    pos = clone(r5);
                  }
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
              } else {
                r4 = null;
                pos = clone(r5);
              }
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, right) {
              if(!right) return left;
              var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
              return new CS.ExistsOp(left, right[5]).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_comparisonExpression() {
        var cacheKey = "comparisonExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_relationalExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.substr(pos.offset, 2) === "<=") {
              r8 = "<=";
              advance(pos, 2);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"<=\"");
              }
            }
            if (r8 === null) {
              if (input.substr(pos.offset, 2) === ">=") {
                r8 = ">=";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\">=\"");
                }
              }
              if (r8 === null) {
                if (input.charCodeAt(pos.offset) === 60) {
                  r8 = "<";
                  advance(pos, 1);
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"<\"");
                  }
                }
                if (r8 === null) {
                  if (input.charCodeAt(pos.offset) === 62) {
                    r8 = ">";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\">\"");
                    }
                  }
                  if (r8 === null) {
                    if (input.substr(pos.offset, 2) === "==") {
                      r8 = "==";
                      advance(pos, 2);
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"==\"");
                      }
                    }
                    if (r8 === null) {
                      r8 = parse_IS();
                      if (r8 === null) {
                        if (input.substr(pos.offset, 2) === "!=") {
                          r8 = "!=";
                          advance(pos, 2);
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"!=\"");
                          }
                        }
                        if (r8 === null) {
                          r8 = parse_ISNT();
                        }
                      }
                    }
                  }
                }
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_expressionworthy();
                if (r10 === null) {
                  r10 = parse_relationalExpression();
                }
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.substr(pos.offset, 2) === "<=") {
                r8 = "<=";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<=\"");
                }
              }
              if (r8 === null) {
                if (input.substr(pos.offset, 2) === ">=") {
                  r8 = ">=";
                  advance(pos, 2);
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">=\"");
                  }
                }
                if (r8 === null) {
                  if (input.charCodeAt(pos.offset) === 60) {
                    r8 = "<";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"<\"");
                    }
                  }
                  if (r8 === null) {
                    if (input.charCodeAt(pos.offset) === 62) {
                      r8 = ">";
                      advance(pos, 1);
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed("\">\"");
                      }
                    }
                    if (r8 === null) {
                      if (input.substr(pos.offset, 2) === "==") {
                        r8 = "==";
                        advance(pos, 2);
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"==\"");
                        }
                      }
                      if (r8 === null) {
                        r8 = parse_IS();
                        if (r8 === null) {
                          if (input.substr(pos.offset, 2) === "!=") {
                            r8 = "!=";
                            advance(pos, 2);
                          } else {
                            r8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"!=\"");
                            }
                          }
                          if (r8 === null) {
                            r8 = parse_ISNT();
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_expressionworthy();
                  if (r10 === null) {
                    r10 = parse_relationalExpression();
                  }
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              var tree = foldl(function(expr, right){
                var raw = expr.raw + right[0] + right[1] + right[2] + right[3].raw;
                return new constructorLookup[right[1]](expr, right[3]).r(raw).p(line, column, offset);
              }, left, rights);
              return rights.length < 2 ? tree : new CS.ChainedComparisonOp(tree).r(tree.raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_relationalExpression() {
        var cacheKey = "relationalExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_bitwiseShiftExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_relationalExpressionOperator();
            if (r8 !== null) {
              r9 = parse_TERMINATOR();
              r9 = r9 !== null ? r9 : "";
              if (r9 !== null) {
                r10 = parse__();
                if (r10 !== null) {
                  r11 = parse_expressionworthy();
                  if (r11 === null) {
                    r11 = parse_bitwiseShiftExpression();
                  }
                  if (r11 !== null) {
                    r5 = [r7, r8, r9, r10, r11];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_relationalExpressionOperator();
              if (r8 !== null) {
                r9 = parse_TERMINATOR();
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r11 = parse_expressionworthy();
                    if (r11 === null) {
                      r11 = parse_bitwiseShiftExpression();
                    }
                    if (r11 !== null) {
                      r5 = [r7, r8, r9, r10, r11];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = expr.raw + right[0] + right[1].raw + right[2] + right[3] + right[4].raw;
                return right[1](expr, right[4], raw, line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_relationalExpressionOperator() {
        var cacheKey = "relationalExpressionOperator@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r0 = parse_EXTENDS();
        if (r0 === null) {
          r0 = parse_INSTANCEOF();
          if (r0 === null) {
            r0 = parse_IN();
            if (r0 === null) {
              r0 = parse_OF();
            }
          }
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, op) {
                var fn = function(left, right, raw, line, column, offset){
                  return new constructorLookup[op](left, right).r(raw).p(line, column, offset);
                };
                fn.raw = op;
                return fn;
              })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_NOT();
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_INSTANCEOF();
              if (r5 === null) {
                r5 = parse_IN();
                if (r5 === null) {
                  r5 = parse_OF();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, op) {
                  var fn = function(left, right, raw, line, column, offset){
                    return new CS.LogicalNotOp(new constructorLookup[op](left, right).r(raw).p(line, column, offset)).r(raw).g();
                  };
                  fn.raw = 'not' + ws + op;
                  return fn;
                })(r1.offset, r1.line, r1.column, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bitwiseShiftExpression() {
        var cacheKey = "bitwiseShiftExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_additiveExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.substr(pos.offset, 2) === "<<") {
              r8 = "<<";
              advance(pos, 2);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"<<\"");
              }
            }
            if (r8 === null) {
              if (input.substr(pos.offset, 3) === ">>>") {
                r8 = ">>>";
                advance(pos, 3);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\">>>\"");
                }
              }
              if (r8 === null) {
                if (input.substr(pos.offset, 2) === ">>") {
                  r8 = ">>";
                  advance(pos, 2);
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">>\"");
                  }
                }
              }
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_additiveExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.substr(pos.offset, 2) === "<<") {
                r8 = "<<";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<<\"");
                }
              }
              if (r8 === null) {
                if (input.substr(pos.offset, 3) === ">>>") {
                  r8 = ">>>";
                  advance(pos, 3);
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">>>\"");
                  }
                }
                if (r8 === null) {
                  if (input.substr(pos.offset, 2) === ">>") {
                    r8 = ">>";
                    advance(pos, 2);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\">>\"");
                    }
                  }
                }
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_additiveExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new constructorLookup[right[1]](expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_additiveExpression() {
        var cacheKey = "additiveExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_multiplicativeExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r9 = clone(pos);
            if (input.charCodeAt(pos.offset) === 43) {
              r10 = "+";
              advance(pos, 1);
            } else {
              r10 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (r10 !== null) {
              r12 = clone(pos);
              reportFailures++;
              if (/^[+=]/.test(input.charAt(pos.offset))) {
                r11 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r11 = null;
                if (reportFailures === 0) {
                  matchFailed("[+=]");
                }
              }
              reportFailures--;
              if (r11 === null) {
                r11 = "";
              } else {
                r11 = null;
                pos = clone(r12);
              }
              if (r11 !== null) {
                r8 = [r10, r11];
              } else {
                r8 = null;
                pos = clone(r9);
              }
            } else {
              r8 = null;
              pos = clone(r9);
            }
            if (r8 === null) {
              r9 = clone(pos);
              if (input.charCodeAt(pos.offset) === 45) {
                r10 = "-";
                advance(pos, 1);
              } else {
                r10 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (r10 !== null) {
                r12 = clone(pos);
                reportFailures++;
                if (/^[\-=]/.test(input.charAt(pos.offset))) {
                  r11 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r11 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\-=]");
                  }
                }
                reportFailures--;
                if (r11 === null) {
                  r11 = "";
                } else {
                  r11 = null;
                  pos = clone(r12);
                }
                if (r11 !== null) {
                  r8 = [r10, r11];
                } else {
                  r8 = null;
                  pos = clone(r9);
                }
              } else {
                r8 = null;
                pos = clone(r9);
              }
            }
            if (r8 !== null) {
              r9 = parse_TERMINATOR();
              r9 = r9 !== null ? r9 : "";
              if (r9 !== null) {
                r10 = parse__();
                if (r10 !== null) {
                  r11 = parse_expressionworthy();
                  if (r11 === null) {
                    r11 = parse_multiplicativeExpression();
                  }
                  if (r11 !== null) {
                    r5 = [r7, r8, r9, r10, r11];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r9 = clone(pos);
              if (input.charCodeAt(pos.offset) === 43) {
                r10 = "+";
                advance(pos, 1);
              } else {
                r10 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (r10 !== null) {
                r12 = clone(pos);
                reportFailures++;
                if (/^[+=]/.test(input.charAt(pos.offset))) {
                  r11 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r11 = null;
                  if (reportFailures === 0) {
                    matchFailed("[+=]");
                  }
                }
                reportFailures--;
                if (r11 === null) {
                  r11 = "";
                } else {
                  r11 = null;
                  pos = clone(r12);
                }
                if (r11 !== null) {
                  r8 = [r10, r11];
                } else {
                  r8 = null;
                  pos = clone(r9);
                }
              } else {
                r8 = null;
                pos = clone(r9);
              }
              if (r8 === null) {
                r9 = clone(pos);
                if (input.charCodeAt(pos.offset) === 45) {
                  r10 = "-";
                  advance(pos, 1);
                } else {
                  r10 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (r10 !== null) {
                  r12 = clone(pos);
                  reportFailures++;
                  if (/^[\-=]/.test(input.charAt(pos.offset))) {
                    r11 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r11 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\-=]");
                    }
                  }
                  reportFailures--;
                  if (r11 === null) {
                    r11 = "";
                  } else {
                    r11 = null;
                    pos = clone(r12);
                  }
                  if (r11 !== null) {
                    r8 = [r10, r11];
                  } else {
                    r8 = null;
                    pos = clone(r9);
                  }
                } else {
                  r8 = null;
                  pos = clone(r9);
                }
              }
              if (r8 !== null) {
                r9 = parse_TERMINATOR();
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r11 = parse_expressionworthy();
                    if (r11 === null) {
                      r11 = parse_multiplicativeExpression();
                    }
                    if (r11 !== null) {
                      r5 = [r7, r8, r9, r10, r11];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = expr.raw + right[0] + right[1][0] + right[2] + right[3] + right[4].raw;
                return new constructorLookup[right[1][0]](expr, right[4]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_multiplicativeExpression() {
        var cacheKey = "multiplicativeExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_exponentiationExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (/^[*\/%]/.test(input.charAt(pos.offset))) {
              r8 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("[*\\/%]");
              }
            }
            if (r8 !== null) {
              r10 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r9 = "=";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r9 === null) {
                r9 = "";
              } else {
                r9 = null;
                pos = clone(r10);
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_exponentiationExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (/^[*\/%]/.test(input.charAt(pos.offset))) {
                r8 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("[*\\/%]");
                }
              }
              if (r8 !== null) {
                r10 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 61) {
                  r9 = "=";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                reportFailures--;
                if (r9 === null) {
                  r9 = "";
                } else {
                  r9 = null;
                  pos = clone(r10);
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expressionworthy();
                      if (r12 === null) {
                        r12 = parse_exponentiationExpression();
                      }
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, rights) {
              if(!rights) return left;
              return foldl(function(expr, right){
                var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
                return new constructorLookup[right[1]](expr, right[5]).r(raw).p(line, column, offset);
              }, left, rights);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_exponentiationExpression() {
        var cacheKey = "exponentiationExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_prefixExpression();
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse__();
          if (r6 !== null) {
            if (input.substr(pos.offset, 2) === "**") {
              r7 = "**";
              advance(pos, 2);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"**\"");
              }
            }
            if (r7 !== null) {
              r9 = clone(pos);
              reportFailures++;
              if (input.charCodeAt(pos.offset) === 61) {
                r8 = "=";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r8 === null) {
                r8 = "";
              } else {
                r8 = null;
                pos = clone(r9);
              }
              if (r8 !== null) {
                r9 = parse_TERMINATOR();
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r11 = parse_expressionworthy();
                    if (r11 === null) {
                      r11 = parse_exponentiationExpression();
                    }
                    if (r11 !== null) {
                      r4 = [r6, r7, r8, r9, r10, r11];
                    } else {
                      r4 = null;
                      pos = clone(r5);
                    }
                  } else {
                    r4 = null;
                    pos = clone(r5);
                  }
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
              } else {
                r4 = null;
                pos = clone(r5);
              }
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, left, right) {
              if(!right) return left;
              var raw = left.raw + right[0] + right[1] + right[3] + right[4] + right[5].raw;
              return new CS.ExpOp(left, right[5]).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_prefixExpression() {
        var cacheKey = "prefixExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r0 = parse_postfixExpression();
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.substr(pos.offset, 2) === "++") {
            r3 = "++";
            advance(pos, 2);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"++\"");
            }
          }
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_expressionworthy();
              if (r5 === null) {
                r5 = parse_prefixExpression();
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, e) { return new CS.PreIncrementOp(e).r('++' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.substr(pos.offset, 2) === "--") {
              r3 = "--";
              advance(pos, 2);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"--\"");
              }
            }
            if (r3 !== null) {
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_expressionworthy();
                if (r5 === null) {
                  r5 = parse_prefixExpression();
                }
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, ws, e) { return new CS.PreDecrementOp(e).r('--' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              if (input.charCodeAt(pos.offset) === 43) {
                r3 = "+";
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_expressionworthy();
                  if (r5 === null) {
                    r5 = parse_prefixExpression();
                  }
                  if (r5 !== null) {
                    r0 = [r3, r4, r5];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, ws, e) { return new CS.UnaryPlusOp(e).r('+' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                r2 = clone(pos);
                if (input.charCodeAt(pos.offset) === 45) {
                  r3 = "-";
                  advance(pos, 1);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_expressionworthy();
                    if (r5 === null) {
                      r5 = parse_prefixExpression();
                    }
                    if (r5 !== null) {
                      r0 = [r3, r4, r5];
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
                if (r0 !== null) {
                  r0 = (function(offset, line, column, ws, e) { return new CS.UnaryNegateOp(e).r('-' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
                }
                if (r0 === null) {
                  pos = clone(r1);
                }
                if (r0 === null) {
                  r1 = clone(pos);
                  r2 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 33) {
                    r3 = "!";
                    advance(pos, 1);
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (r3 === null) {
                    r3 = parse_NOT();
                  }
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r5 = parse_expressionworthy();
                      if (r5 === null) {
                        r5 = parse_prefixExpression();
                      }
                      if (r5 !== null) {
                        r0 = [r3, r4, r5];
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                  if (r0 !== null) {
                    r0 = (function(offset, line, column, o, ws, e) { return new CS.LogicalNotOp(e).r(o + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r3, r4, r5);
                  }
                  if (r0 === null) {
                    pos = clone(r1);
                  }
                  if (r0 === null) {
                    r1 = clone(pos);
                    r2 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 126) {
                      r3 = "~";
                      advance(pos, 1);
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"~\"");
                      }
                    }
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r5 = parse_expressionworthy();
                        if (r5 === null) {
                          r5 = parse_prefixExpression();
                        }
                        if (r5 !== null) {
                          r0 = [r3, r4, r5];
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                    if (r0 !== null) {
                      r0 = (function(offset, line, column, ws, e) { return new CS.BitNotOp(e).r('~' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
                    }
                    if (r0 === null) {
                      pos = clone(r1);
                    }
                    if (r0 === null) {
                      r1 = clone(pos);
                      r2 = clone(pos);
                      r3 = parse_DO();
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r6 = clone(pos);
                          reportFailures++;
                          r5 = parse_unassignable();
                          reportFailures--;
                          if (r5 === null) {
                            r5 = "";
                          } else {
                            r5 = null;
                            pos = clone(r6);
                          }
                          if (r5 !== null) {
                            r6 = parse_identifier();
                            if (r6 !== null) {
                              r7 = parse__();
                              if (r7 !== null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                  r8 = "=";
                                  advance(pos, 1);
                                } else {
                                  r8 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"=\"");
                                  }
                                }
                                if (r8 !== null) {
                                  r9 = parse__();
                                  if (r9 !== null) {
                                    r10 = parse_functionLiteral();
                                    if (r10 !== null) {
                                      r0 = [r3, r4, r5, r6, r7, r8, r9, r10];
                                    } else {
                                      r0 = null;
                                      pos = clone(r2);
                                    }
                                  } else {
                                    r0 = null;
                                    pos = clone(r2);
                                  }
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                      if (r0 !== null) {
                        r0 = (function(offset, line, column, ws0, a, ws1, ws2, f) {
                            return new CS.DoOp(new CS.AssignOp(a, f)).r('do' + ws0 + a.raw + ws1 + '+' + ws2 + f.raw).p(line, column, offset);
                          })(r1.offset, r1.line, r1.column, r4, r6, r7, r9, r10);
                      }
                      if (r0 === null) {
                        pos = clone(r1);
                      }
                      if (r0 === null) {
                        r1 = clone(pos);
                        r2 = clone(pos);
                        r3 = parse_DO();
                        if (r3 !== null) {
                          r4 = parse__();
                          if (r4 !== null) {
                            r5 = parse_expressionworthy();
                            if (r5 === null) {
                              r5 = parse_prefixExpression();
                            }
                            if (r5 !== null) {
                              r0 = [r3, r4, r5];
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                        if (r0 !== null) {
                          r0 = (function(offset, line, column, ws, e) { return new CS.DoOp(e).r('do' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
                        }
                        if (r0 === null) {
                          pos = clone(r1);
                        }
                        if (r0 === null) {
                          r1 = clone(pos);
                          r2 = clone(pos);
                          r3 = parse_TYPEOF();
                          if (r3 !== null) {
                            r4 = parse__();
                            if (r4 !== null) {
                              r5 = parse_expressionworthy();
                              if (r5 === null) {
                                r5 = parse_prefixExpression();
                              }
                              if (r5 !== null) {
                                r0 = [r3, r4, r5];
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                          if (r0 !== null) {
                            r0 = (function(offset, line, column, ws, e) { return new CS.TypeofOp(e).r('typeof' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
                          }
                          if (r0 === null) {
                            pos = clone(r1);
                          }
                          if (r0 === null) {
                            r1 = clone(pos);
                            r2 = clone(pos);
                            r3 = parse_DELETE();
                            if (r3 !== null) {
                              r4 = parse__();
                              if (r4 !== null) {
                                r5 = parse_expressionworthy();
                                if (r5 === null) {
                                  r5 = parse_prefixExpression();
                                }
                                if (r5 !== null) {
                                  r0 = [r3, r4, r5];
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                            if (r0 !== null) {
                              r0 = (function(offset, line, column, ws, e) { return new CS.DeleteOp(e).r('delete' + ws + e.raw).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4, r5);
                            }
                            if (r0 === null) {
                              pos = clone(r1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixExpression() {
        var cacheKey = "postfixExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_leftHandSideExpression();
        if (r3 !== null) {
          r4 = [];
          if (input.charCodeAt(pos.offset) === 63) {
            r5 = "?";
            advance(pos, 1);
          } else {
            r5 = null;
            if (reportFailures === 0) {
              matchFailed("\"?\"");
            }
          }
          if (r5 === null) {
            if (input.substr(pos.offset, 4) === "[..]") {
              r5 = "[..]";
              advance(pos, 4);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"[..]\"");
              }
            }
            if (r5 === null) {
              if (input.substr(pos.offset, 2) === "++") {
                r5 = "++";
                advance(pos, 2);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"++\"");
                }
              }
              if (r5 === null) {
                if (input.substr(pos.offset, 2) === "--") {
                  r5 = "--";
                  advance(pos, 2);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"--\"");
                  }
                }
              }
            }
          }
          while (r5 !== null) {
            r4.push(r5);
            if (input.charCodeAt(pos.offset) === 63) {
              r5 = "?";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (r5 === null) {
              if (input.substr(pos.offset, 4) === "[..]") {
                r5 = "[..]";
                advance(pos, 4);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"[..]\"");
                }
              }
              if (r5 === null) {
                if (input.substr(pos.offset, 2) === "++") {
                  r5 = "++";
                  advance(pos, 2);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"++\"");
                  }
                }
                if (r5 === null) {
                  if (input.substr(pos.offset, 2) === "--") {
                    r5 = "--";
                    advance(pos, 2);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"--\"");
                    }
                  }
                }
              }
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, expr, ops) {
              return foldl(function(expr, op){
                var raw;
                switch(op){
                  case '?': return new CS.UnaryExistsOp(expr).r(expr.raw + op).p(line, column, offset)
                  case '[..]': return new CS.ShallowCopyArray(expr).r(expr.raw + op).p(line, column, offset)
                  case '++': return new CS.PostIncrementOp(expr).r(expr.raw + op).p(line, column, offset)
                  case '--': return new CS.PostDecrementOp(expr).r(expr.raw + op).p(line, column, offset)
                }
              }, expr, ops);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_leftHandSideExpression() {
        var cacheKey = "leftHandSideExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_callExpression();
        if (r0 === null) {
          r0 = parse_newExpression();
          if (r0 === null) {
            r0 = parse_superExpression();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_argumentList() {
        var cacheKey = "argumentList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 63) {
          r3 = "?";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.charCodeAt(pos.offset) === 40) {
            r4 = "(";
            advance(pos, 1);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              r6 = parse_argumentListContents();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos.offset) === 41) {
                    r8 = ")";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, soaked, ws0, a, ws1) {
                return 0,
                  { op: soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication
                  , operands: [a ? a.list : []]
                  , raw: '(' + ws0 + (a ? a.raw : '') + ws1 + ')'
                  , line: line
                  , column: column
                  , offset: offset
                  };
              })(r1.offset, r1.line, r1.column, r3, r5, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_argumentListContents() {
        var cacheKey = "argumentListContents@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_argument();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r9 = clone(pos);
            r10 = parse_TERM();
            r10 = r10 !== null ? r10 : "";
            if (r10 !== null) {
              r11 = parse__();
              if (r11 !== null) {
                if (input.charCodeAt(pos.offset) === 44) {
                  r12 = ",";
                  advance(pos, 1);
                } else {
                  r12 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r12 !== null) {
                  r13 = parse__();
                  if (r13 !== null) {
                    r14 = parse_TERMINATOR();
                    r14 = r14 !== null ? r14 : "";
                    if (r14 !== null) {
                      r15 = [];
                      r16 = parse_INDENT();
                      while (r16 !== null) {
                        r15.push(r16);
                        r16 = parse_INDENT();
                      }
                      if (r15 !== null) {
                        r8 = [r10, r11, r12, r13, r14, r15];
                      } else {
                        r8 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r8 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r8 = null;
                    pos = clone(r9);
                  }
                } else {
                  r8 = null;
                  pos = clone(r9);
                }
              } else {
                r8 = null;
                pos = clone(r9);
              }
            } else {
              r8 = null;
              pos = clone(r9);
            }
            if (r8 === null) {
              r8 = parse_TERMINATOR();
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_argument();
                if (r10 !== null) {
                  r11 = [];
                  r12 = parse_DEDENT();
                  while (r12 !== null) {
                    r11.push(r12);
                    r12 = parse_DEDENT();
                  }
                  if (r11 !== null) {
                    r5 = [r7, r8, r9, r10, r11];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r9 = clone(pos);
              r10 = parse_TERM();
              r10 = r10 !== null ? r10 : "";
              if (r10 !== null) {
                r11 = parse__();
                if (r11 !== null) {
                  if (input.charCodeAt(pos.offset) === 44) {
                    r12 = ",";
                    advance(pos, 1);
                  } else {
                    r12 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (r12 !== null) {
                    r13 = parse__();
                    if (r13 !== null) {
                      r14 = parse_TERMINATOR();
                      r14 = r14 !== null ? r14 : "";
                      if (r14 !== null) {
                        r15 = [];
                        r16 = parse_INDENT();
                        while (r16 !== null) {
                          r15.push(r16);
                          r16 = parse_INDENT();
                        }
                        if (r15 !== null) {
                          r8 = [r10, r11, r12, r13, r14, r15];
                        } else {
                          r8 = null;
                          pos = clone(r9);
                        }
                      } else {
                        r8 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r8 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r8 = null;
                    pos = clone(r9);
                  }
                } else {
                  r8 = null;
                  pos = clone(r9);
                }
              } else {
                r8 = null;
                pos = clone(r9);
              }
              if (r8 === null) {
                r8 = parse_TERMINATOR();
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_argument();
                  if (r10 !== null) {
                    r11 = [];
                    r12 = parse_DEDENT();
                    while (r12 !== null) {
                      r11.push(r12);
                      r12 = parse_DEDENT();
                    }
                    if (r11 !== null) {
                      r5 = [r7, r8, r9, r10, r11];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r6 = clone(pos);
            if (input.charCodeAt(pos.offset) === 44) {
              r7 = ",";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                r9 = [];
                r10 = parse_DEDENT();
                while (r10 !== null) {
                  r9.push(r10);
                  r10 = parse_DEDENT();
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            if (r5 === null) {
              r5 = parse_TERMINATOR();
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, es, t) {
                var raw = e.raw + es.map(function(e){ return e[0] + e[1] + e[2] + e[3].raw; }).join('') + t;
                return {list: [e].concat(es.map(function(e){ return e[3]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_TERMINDENT();
          if (r3 !== null) {
            r4 = parse_argumentListContents();
            if (r4 !== null) {
              r5 = parse_DEDENT();
              r5 = r5 !== null ? r5 : "";
              if (r5 !== null) {
                r6 = parse_TERMINATOR();
                r6 = r6 !== null ? r6 : "";
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, t0, a, d, t1) {
                  return {list: a.list, raw: t0 + a.raw + d + t1};
                })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_argument() {
        var cacheKey = "argument@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_implicitObjectLiteral();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, o, d) { return o; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r0 = parse_spread();
          if (r0 === null) {
            r0 = parse_expression();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgumentList() {
        var cacheKey = "secondaryArgumentList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse___();
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r6 = clone(pos);
          if (/^[+-\/]/.test(input.charAt(pos.offset))) {
            r7 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("[+-\\/]");
            }
          }
          if (r7 !== null) {
            r8 = parse___();
            if (r8 !== null) {
              r4 = [r7, r8];
            } else {
              r4 = null;
              pos = clone(r6);
            }
          } else {
            r4 = null;
            pos = clone(r6);
          }
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r5 = parse_secondaryArgument();
            if (r5 !== null) {
              r6 = [];
              r7 = parse_secondaryArgumentRest();
              while (r7 !== null) {
                r6.push(r7);
                r7 = parse_secondaryArgumentRest();
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, e, es) {
                var raw = ws0 + e.raw + es.map(function(e){ return e.raw; }).join('');
                es = [e].concat(es.map(function(e){ return e.list[0]; }));
                return {list: es, op: CS.FunctionApplication, operands: [es], raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_TERMINDENT();
          if (r3 !== null) {
            r4 = parse_implicitObjectLiteral();
            if (r4 !== null) {
              r5 = parse_DEDENT();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, t, o, d) {
                  return {list: [o], op: CS.FunctionApplication, operands: [[o]], raw: t + o.raw + d};
                })(r1.offset, r1.line, r1.column, r3, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgumentRest() {
        var cacheKey = "secondaryArgumentRest@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERM();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              if (input.charCodeAt(pos.offset) === 44) {
                r6 = ",";
                advance(pos, 1);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_secondaryArgument();
                      if (r10 !== null) {
                        r0 = [r3, r4, r5, r6, r7, r8, r9, r10];
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, t0, ws1, ws2, t1, ws3, e) {
                return {list: [e], raw: ws0 + t0 + ws1 + "," + ws2 + t1 + ws3 + e.raw};
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r7, r8, r9, r10);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_TERM();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                if (input.charCodeAt(pos.offset) === 44) {
                  r6 = ",";
                  advance(pos, 1);
                } else {
                  r6 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r6 !== null) {
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINDENT();
                    if (r8 !== null) {
                      r9 = parse_implicitObjectLiteral();
                      if (r9 !== null) {
                        r10 = parse_DEDENT();
                        if (r10 !== null) {
                          r0 = [r3, r4, r5, r6, r7, r8, r9, r10];
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws0, t0, ws1, ws2, t1, o, d) {
                  return {list: [o], raw: ws0 + t0 + ws1 + "," + ws2 + t1 + o.raw + d};
                })(r1.offset, r1.line, r1.column, r3, r4, r5, r7, r8, r9, r10);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgument() {
        var cacheKey = "secondaryArgument@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_spread();
        if (r0 === null) {
          r0 = parse_secondaryExpression();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_callExpression() {
        var cacheKey = "callExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_memberExpression();
        if (r3 !== null) {
          r4 = parse_accesses();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r6 = clone(pos);
            if (input.charCodeAt(pos.offset) === 63) {
              r7 = "?";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse_secondaryArgumentList();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, fn, accesses, secondaryArgs) {
              if(accesses) fn = createMemberExpression(fn, accesses);
              var soaked, secondaryCtor;
              if(secondaryArgs) {
                soaked = secondaryArgs[0];
                secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                fn = new secondaryCtor(fn, secondaryArgs[1].list).r(fn.raw + secondaryArgs[1].raw).p(line, column, offset);
              }
              return fn;
            })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_superExpression() {
        var cacheKey = "superExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_SUPER();
        if (r3 !== null) {
          r4 = parse_argumentList();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, args) {
              return new CS.Super(args.operands[0]).r('super' + args.raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_SUPER();
          if (r3 !== null) {
            r4 = parse_secondaryArgumentList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, args) {
                var a = args ? args.list : [];
                return new CS.Super(a).r('super' + args.raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_newExpression() {
        var cacheKey = "newExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_memberExpression();
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_expressionworthy();
              if (r5 === null) {
                r5 = parse_newExpression();
                if (r5 === null) {
                  r5 = parse_prefixExpression();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, e) {
                return new CS.NewOp(e, []).r('new' + ws + e.raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_memberExpression() {
        var cacheKey = "memberExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_primaryExpression();
        if (r3 === null) {
          r4 = clone(pos);
          r5 = clone(pos);
          r6 = parse_NEW();
          if (r6 !== null) {
            r7 = parse___();
            if (r7 !== null) {
              r8 = parse_memberExpression();
              if (r8 !== null) {
                r9 = parse_argumentList();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = clone(r5);
                }
              } else {
                r3 = null;
                pos = clone(r5);
              }
            } else {
              r3 = null;
              pos = clone(r5);
            }
          } else {
            r3 = null;
            pos = clone(r5);
          }
          if (r3 !== null) {
            r3 = (function(offset, line, column, ws0, e, args) { return new CS.NewOp(e, args.operands[0]).r('new' + ws0 + e + args.raw).p(line, column, offset); })(r4.offset, r4.line, r4.column, r7, r8, r9);
          }
          if (r3 === null) {
            pos = clone(r4);
          }
        }
        if (r3 !== null) {
          r4 = [];
          r5 = parse_MemberAccessOps();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_MemberAccessOps();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, accesses) {
              return createMemberExpression(e, accesses || []);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_memberExpression();
              if (r5 !== null) {
                r6 = parse_secondaryArgumentList();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws0, e, args) {
                var raw = 'new' + ws0 + e.raw + args.raw;
                return new CS.NewOp(e, args.list).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4, r5, r6);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r0 = parse_superExpression();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_memberAccess() {
        var cacheKey = "memberAccess@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_primaryExpression();
        if (r3 === null) {
          r4 = clone(pos);
          r5 = clone(pos);
          r6 = parse_NEW();
          if (r6 !== null) {
            r7 = parse___();
            if (r7 !== null) {
              r8 = parse_memberExpression();
              if (r8 !== null) {
                r9 = parse_argumentList();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = clone(r5);
                }
              } else {
                r3 = null;
                pos = clone(r5);
              }
            } else {
              r3 = null;
              pos = clone(r5);
            }
          } else {
            r3 = null;
            pos = clone(r5);
          }
          if (r3 !== null) {
            r3 = (function(offset, line, column, ws0, e, args) { return new CS.NewOp(e, args.operands[0]).r('new' + ws0 + e + args.raw).p(line, column, offset); })(r4.offset, r4.line, r4.column, r7, r8, r9);
          }
          if (r3 === null) {
            pos = clone(r4);
          }
        }
        if (r3 !== null) {
          r6 = clone(pos);
          r7 = parse_argumentList();
          if (r7 !== null) {
            r8 = parse_MemberAccessOps();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          if (r5 === null) {
            r5 = parse_MemberAccessOps();
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = clone(pos);
              r7 = parse_argumentList();
              if (r7 !== null) {
                r8 = parse_MemberAccessOps();
                if (r8 !== null) {
                  r5 = [r7, r8];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
              if (r5 === null) {
                r5 = parse_MemberAccessOps();
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, acc) {
                return createMemberExpression(e, foldl(function(memo, a){ return memo.concat(a); }, [], acc));
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_accesses() {
        var cacheKey = "accesses@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = [];
        r4 = parse_argumentList();
        if (r4 === null) {
          r4 = parse_MemberAccessOps();
        }
        while (r4 !== null) {
          r3.push(r4);
          r4 = parse_argumentList();
          if (r4 === null) {
            r4 = parse_MemberAccessOps();
          }
        }
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_MemberAccessOps();
            if (r5 !== null) {
              r6 = [];
              r7 = parse_argumentList();
              if (r7 === null) {
                r7 = parse_secondaryArgumentList();
                if (r7 === null) {
                  r7 = parse_MemberAccessOps();
                }
              }
              while (r7 !== null) {
                r6.push(r7);
                r7 = parse_argumentList();
                if (r7 === null) {
                  r7 = parse_secondaryArgumentList();
                  if (r7 === null) {
                    r7 = parse_MemberAccessOps();
                  }
                }
              }
              if (r6 !== null) {
                r7 = parse_DEDENT();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, acc0, td, acc1, acc2, d) {
                acc0 = acc0 || [];
                acc2 = acc2 || [];
                return acc0.concat(acc1, acc2);
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r0 = [];
          r1 = parse_argumentList();
          if (r1 === null) {
            r1 = parse_MemberAccessOps();
          }
          while (r1 !== null) {
            r0.push(r1);
            r1 = parse_argumentList();
            if (r1 === null) {
              r1 = parse_MemberAccessOps();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_MemberAccessOps() {
        var cacheKey = "MemberAccessOps@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 46) {
              r5 = ".";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (r5 !== null) {
              r6 = parse_TERMINATOR();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_identifierName();
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, ws1, ws2, ws3, e) { return {op: CS.MemberAccessOp, operands: [e], raw: ws0 + ws1 + '.' + ws2 + ws3 + e, line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r3, r4, r6, r7, r8);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.substr(pos.offset, 2) === "?.") {
            r3 = "?.";
            advance(pos, 2);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"?.\"");
            }
          }
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_identifierName();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, e) { return {op: CS.SoakedMemberAccessOp, operands: [e], raw: '?.' + ws + e, line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.charCodeAt(pos.offset) === 91) {
              r3 = "[";
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (r3 !== null) {
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_expression();
                if (r5 !== null) {
                  r6 = parse__();
                  if (r6 !== null) {
                    if (input.charCodeAt(pos.offset) === 93) {
                      r7 = "]";
                      advance(pos, 1);
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"]\"");
                      }
                    }
                    if (r7 !== null) {
                      r0 = [r3, r4, r5, r6, r7];
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, ws0, e, ws1) { return {op: CS.DynamicMemberAccessOp, operands: [e], raw: '[' + ws0 + e + ws1 + ']', line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5, r6);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              if (input.substr(pos.offset, 2) === "?[") {
                r3 = "?[";
                advance(pos, 2);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?[\"");
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_expression();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos.offset) === 93) {
                        r7 = "]";
                        advance(pos, 1);
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"]\"");
                        }
                      }
                      if (r7 !== null) {
                        r0 = [r3, r4, r5, r6, r7];
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, ws0, e, ws1) { return {op: CS.SoakedDynamicMemberAccessOp, operands: [e], raw: '?[' + ws0 + e + ws1 + ']', line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5, r6);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                r2 = clone(pos);
                if (input.substr(pos.offset, 2) === "::") {
                  r3 = "::";
                  advance(pos, 2);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_identifierName();
                    if (r5 !== null) {
                      r0 = [r3, r4, r5];
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
                if (r0 !== null) {
                  r0 = (function(offset, line, column, ws, e) { return {op: CS.ProtoMemberAccessOp, operands: [e], raw: '::' + ws + e, line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5);
                }
                if (r0 === null) {
                  pos = clone(r1);
                }
                if (r0 === null) {
                  r1 = clone(pos);
                  r2 = clone(pos);
                  if (input.substr(pos.offset, 3) === "::[") {
                    r3 = "::[";
                    advance(pos, 3);
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::[\"");
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r5 = parse_expression();
                      if (r5 !== null) {
                        r6 = parse__();
                        if (r6 !== null) {
                          if (input.charCodeAt(pos.offset) === 93) {
                            r7 = "]";
                            advance(pos, 1);
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"]\"");
                            }
                          }
                          if (r7 !== null) {
                            r0 = [r3, r4, r5, r6, r7];
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                  if (r0 !== null) {
                    r0 = (function(offset, line, column, ws0, e, ws1) { return {op: CS.DynamicProtoMemberAccessOp, operands: [e], raw: '::[' + ws0 + e + ws1 + ']', line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5, r6);
                  }
                  if (r0 === null) {
                    pos = clone(r1);
                  }
                  if (r0 === null) {
                    r1 = clone(pos);
                    r2 = clone(pos);
                    if (input.substr(pos.offset, 3) === "?::") {
                      r3 = "?::";
                      advance(pos, 3);
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"?::\"");
                      }
                    }
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r5 = parse_identifierName();
                        if (r5 !== null) {
                          r0 = [r3, r4, r5];
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                    if (r0 !== null) {
                      r0 = (function(offset, line, column, ws, e) { return {op: CS.SoakedProtoMemberAccessOp, operands: [e], raw: '?::' + ws + e, line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5);
                    }
                    if (r0 === null) {
                      pos = clone(r1);
                    }
                    if (r0 === null) {
                      r1 = clone(pos);
                      r2 = clone(pos);
                      if (input.substr(pos.offset, 4) === "?::[") {
                        r3 = "?::[";
                        advance(pos, 4);
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"?::[\"");
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_expression();
                          if (r5 !== null) {
                            r6 = parse__();
                            if (r6 !== null) {
                              if (input.charCodeAt(pos.offset) === 93) {
                                r7 = "]";
                                advance(pos, 1);
                              } else {
                                r7 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"]\"");
                                }
                              }
                              if (r7 !== null) {
                                r0 = [r3, r4, r5, r6, r7];
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                      if (r0 !== null) {
                        r0 = (function(offset, line, column, ws0, e, ws1) { return {op: CS.SoakedDynamicProtoMemberAccessOp, operands: [e], raw: '?::[' + ws0 + e + ws1 + ']', line: line, column: column, offset: offset}; })(r1.offset, r1.line, r1.column, r4, r5, r6);
                      }
                      if (r0 === null) {
                        pos = clone(r1);
                      }
                      if (r0 === null) {
                        r1 = clone(pos);
                        r2 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 91) {
                          r3 = "[";
                          advance(pos, 1);
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"[\"");
                          }
                        }
                        if (r3 !== null) {
                          r4 = parse__();
                          if (r4 !== null) {
                            r6 = clone(pos);
                            r7 = parse_assignmentExpression();
                            if (r7 !== null) {
                              r8 = parse__();
                              if (r8 !== null) {
                                r5 = [r7, r8];
                              } else {
                                r5 = null;
                                pos = clone(r6);
                              }
                            } else {
                              r5 = null;
                              pos = clone(r6);
                            }
                            r5 = r5 !== null ? r5 : "";
                            if (r5 !== null) {
                              if (input.substr(pos.offset, 2) === "..") {
                                r6 = "..";
                                advance(pos, 2);
                              } else {
                                r6 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"..\"");
                                }
                              }
                              if (r6 !== null) {
                                if (input.charCodeAt(pos.offset) === 46) {
                                  r7 = ".";
                                  advance(pos, 1);
                                } else {
                                  r7 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\".\"");
                                  }
                                }
                                r7 = r7 !== null ? r7 : "";
                                if (r7 !== null) {
                                  r8 = parse__();
                                  if (r8 !== null) {
                                    r10 = clone(pos);
                                    r11 = parse_assignmentExpression();
                                    if (r11 !== null) {
                                      r12 = parse__();
                                      if (r12 !== null) {
                                        r9 = [r11, r12];
                                      } else {
                                        r9 = null;
                                        pos = clone(r10);
                                      }
                                    } else {
                                      r9 = null;
                                      pos = clone(r10);
                                    }
                                    r9 = r9 !== null ? r9 : "";
                                    if (r9 !== null) {
                                      if (input.charCodeAt(pos.offset) === 93) {
                                        r10 = "]";
                                        advance(pos, 1);
                                      } else {
                                        r10 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"]\"");
                                        }
                                      }
                                      if (r10 !== null) {
                                        r0 = [r3, r4, r5, r6, r7, r8, r9, r10];
                                      } else {
                                        r0 = null;
                                        pos = clone(r2);
                                      }
                                    } else {
                                      r0 = null;
                                      pos = clone(r2);
                                    }
                                  } else {
                                    r0 = null;
                                    pos = clone(r2);
                                  }
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                        if (r0 !== null) {
                          r0 = (function(offset, line, column, ws0, maybeLeft, exclusive, ws1, maybeRight) {
                                var left = maybeLeft ? maybeLeft[0] : null,
                                    right = maybeRight ? maybeRight[0] : null;
                                var raw = '[' + ws0 + (left ? left.raw + maybeLeft[1] : '') + '..' + exclusive +
                                  ws1 + (right ? right.raw + maybeRight[1] : '') + ']';
                                return {op: CS.Slice, operands: [!exclusive, left, right], raw: raw, line: line, column: column, offset: offset};
                              })(r1.offset, r1.line, r1.column, r4, r5, r7, r8, r9);
                        }
                        if (r0 === null) {
                          pos = clone(r1);
                        }
                        if (r0 === null) {
                          r1 = clone(pos);
                          if (input.substr(pos.offset, 2) === "::") {
                            r0 = "::";
                            advance(pos, 2);
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }
                          if (r0 !== null) {
                            r0 = (function(offset, line, column) {
                                  return {op: CS.MemberAccessOp, operands: ["prototype"], raw: "::", line: line, column: column, offset: offset};
                                })(r1.offset, r1.line, r1.column);
                          }
                          if (r0 === null) {
                            pos = clone(r1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_primaryExpression() {
        var cacheKey = "primaryExpression@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r0 = parse_macro();
        if (r0 === null) {
          r0 = parse_Numbers();
          if (r0 === null) {
            r0 = parse_bool();
            if (r0 === null) {
              r0 = parse_null();
              if (r0 === null) {
                r0 = parse_undefined();
                if (r0 === null) {
                  r0 = parse_contextVar();
                  if (r0 === null) {
                    r1 = clone(pos);
                    r0 = parse_THIS();
                    if (r0 === null) {
                      if (input.charCodeAt(pos.offset) === 64) {
                        r0 = "@";
                        advance(pos, 1);
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"@\"");
                        }
                      }
                    }
                    if (r0 !== null) {
                      r0 = (function(offset, line, column, r) { return (new CS.This).r(r).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
                    }
                    if (r0 === null) {
                      pos = clone(r1);
                    }
                    if (r0 === null) {
                      r0 = parse_identifier();
                      if (r0 === null) {
                        r0 = parse_range();
                        if (r0 === null) {
                          r0 = parse_arrayLiteral();
                          if (r0 === null) {
                            r0 = parse_objectLiteral();
                            if (r0 === null) {
                              r0 = parse_interpolation();
                              if (r0 === null) {
                                r0 = parse_JSLiteral();
                                if (r0 === null) {
                                  r0 = parse_string();
                                  if (r0 === null) {
                                    r0 = parse_regexp();
                                    if (r0 === null) {
                                      r1 = clone(pos);
                                      r2 = clone(pos);
                                      if (input.charCodeAt(pos.offset) === 40) {
                                        r3 = "(";
                                        advance(pos, 1);
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"(\"");
                                        }
                                      }
                                      if (r3 !== null) {
                                        r4 = parse_TERMINDENT();
                                        if (r4 !== null) {
                                          r5 = parse_expression();
                                          if (r5 !== null) {
                                            r6 = parse_DEDENT();
                                            if (r6 !== null) {
                                              r7 = parse_TERMINATOR();
                                              r7 = r7 !== null ? r7 : "";
                                              if (r7 !== null) {
                                                if (input.charCodeAt(pos.offset) === 41) {
                                                  r8 = ")";
                                                  advance(pos, 1);
                                                } else {
                                                  r8 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\")\"");
                                                  }
                                                }
                                                if (r8 !== null) {
                                                  r0 = [r3, r4, r5, r6, r7, r8];
                                                } else {
                                                  r0 = null;
                                                  pos = clone(r2);
                                                }
                                              } else {
                                                r0 = null;
                                                pos = clone(r2);
                                              }
                                            } else {
                                              r0 = null;
                                              pos = clone(r2);
                                            }
                                          } else {
                                            r0 = null;
                                            pos = clone(r2);
                                          }
                                        } else {
                                          r0 = null;
                                          pos = clone(r2);
                                        }
                                      } else {
                                        r0 = null;
                                        pos = clone(r2);
                                      }
                                      if (r0 !== null) {
                                        r0 = (function(offset, line, column, t0, e, d, t1) {
                                            e = e.clone();
                                            e.raw = '(' + t0 + e.raw + d + t1 + ')';
                                            return e;
                                          })(r1.offset, r1.line, r1.column, r4, r5, r6, r7);
                                      }
                                      if (r0 === null) {
                                        pos = clone(r1);
                                      }
                                      if (r0 === null) {
                                        r1 = clone(pos);
                                        r2 = clone(pos);
                                        if (input.charCodeAt(pos.offset) === 40) {
                                          r3 = "(";
                                          advance(pos, 1);
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"(\"");
                                          }
                                        }
                                        if (r3 !== null) {
                                          r4 = parse__();
                                          if (r4 !== null) {
                                            r5 = parse_expression();
                                            if (r5 !== null) {
                                              r6 = parse__();
                                              if (r6 !== null) {
                                                r7 = parse_TERMINATOR();
                                                r7 = r7 !== null ? r7 : "";
                                                if (r7 !== null) {
                                                  r8 = parse__();
                                                  if (r8 !== null) {
                                                    if (input.charCodeAt(pos.offset) === 41) {
                                                      r9 = ")";
                                                      advance(pos, 1);
                                                    } else {
                                                      r9 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\")\"");
                                                      }
                                                    }
                                                    if (r9 !== null) {
                                                      r0 = [r3, r4, r5, r6, r7, r8, r9];
                                                    } else {
                                                      r0 = null;
                                                      pos = clone(r2);
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = clone(r2);
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = clone(r2);
                                                }
                                              } else {
                                                r0 = null;
                                                pos = clone(r2);
                                              }
                                            } else {
                                              r0 = null;
                                              pos = clone(r2);
                                            }
                                          } else {
                                            r0 = null;
                                            pos = clone(r2);
                                          }
                                        } else {
                                          r0 = null;
                                          pos = clone(r2);
                                        }
                                        if (r0 !== null) {
                                          r0 = (function(offset, line, column, ws0, e, ws1, t, ws2) {
                                              e = e.clone();
                                              e.raw = '(' + ws0 + e.raw + ws1 + t + ws2 + ')';
                                              return e;
                                            })(r1.offset, r1.line, r1.column, r4, r5, r6, r7, r8);
                                        }
                                        if (r0 === null) {
                                          pos = clone(r1);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_contextVar() {
        var cacheKey = "contextVar@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 64) {
          r3 = "@";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"@\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_identifierName();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, m) {
                return new CS.MemberAccessOp((new CS.This).r("@").p(line, column, offset), m).r("@" + m).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_JSLiteral() {
        var cacheKey = "JSLiteral@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 96) {
          r3 = "`";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"`\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          if (/^[^`]/.test(input.charAt(pos.offset))) {
            r5 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r5 = null;
            if (reportFailures === 0) {
              matchFailed("[^`]");
            }
          }
          while (r5 !== null) {
            r4.push(r5);
            if (/^[^`]/.test(input.charAt(pos.offset))) {
              r5 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("[^`]");
              }
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 96) {
              r5 = "`";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"`\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, data) {
                data = data.join('');
                return new CS.JavaScript(data).r('`' + data + '`').p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_spread() {
        var cacheKey = "spread@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_postfixExpression();
        if (r3 !== null) {
          if (input.substr(pos.offset, 3) === "...") {
            r4 = "...";
            advance(pos, 3);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"...\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e) {
              return new CS.Spread(e).r(e.raw + "...").p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_conditional() {
        var cacheKey = "conditional@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_IF();
        if (r3 === null) {
          r3 = parse_UNLESS();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpression();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r7 = parse_elseClause();
                r7 = r7 !== null ? r7 : "";
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, kw, ws0, cond, body, elseClause) {
              var raw = kw + ws0 + cond.raw + body.raw + (elseClause ? elseClause.raw : '');
              var constructor = kw == 'unless' ? CS.NegatedConditional : CS.Conditional;
              if(kw == 'unless') cond = new CS.LogicalNotOp(cond).g();
              var elseBlock = elseClause ? elseClause.block : null;
              return new constructor(cond, body.block, elseBlock).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4, r5, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_conditionalBody() {
        var cacheKey = "conditionalBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_block();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, t, b, d) { return {block: b, raw: t + b.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_TERMINATOR();
          r3 = r3 !== null ? r3 : "";
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_THEN();
              if (r5 !== null) {
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_statement();
                  if (r7 !== null) {
                    r0 = [r3, r4, r5, r6, r7];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, t, ws0, ws1, s) {
                  return {block: s, raw: ws0 + t + 'then' + ws1 + s.raw};
                })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, ws) {
                    return {block: null, raw: ws + 'then'};
                  })(r1.offset, r1.line, r1.column, r3);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_elseClause() {
        var cacheKey = "elseClause@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINATOR();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              r6 = parse_ELSE();
              if (r6 !== null) {
                r7 = parse_functionBody();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, term, ws1, b) { return {block: b.block, raw: ws0 + term + ws1 + 'else' + b.raw}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_while() {
        var cacheKey = "while@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_WHILE();
        if (r3 === null) {
          r3 = parse_UNTIL();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpression();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, kw, ws, cond, body) {
              var raw = kw + ws + cond.raw + body.raw;
              var constructor = kw == 'until' ? CS.NegatedWhile : CS.While;
              if(kw == 'until') cond = new CS.LogicalNotOp(cond).g();
              return new constructor(cond, body.block).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_loop() {
        var cacheKey = "loop@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_LOOP();
        if (r3 !== null) {
          r4 = parse_conditionalBody();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, body) {
              return new CS.Loop(body.block).r('loop' + body.raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_try() {
        var cacheKey = "try@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TRY();
        if (r3 !== null) {
          r4 = parse_tryBody();
          if (r4 !== null) {
            r5 = parse_catchClause();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_finallyClause();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, body, c, f) {
              var raw = 'try' + body.block + (c ? c.raw : '') + (f ? f.raw : '');
              return new CS.Try(body.block, c ? c.assignee : null, c ? c.block : null, f ? f.block : null).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_tryBody() {
        var cacheKey = "tryBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_functionBody();
        if (r0 === null) {
          r0 = parse_conditionalBody();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_catchClause() {
        var cacheKey = "catchClause@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_CATCH();
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_Assignable();
                if (r7 !== null) {
                  r8 = parse_conditionalBody();
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, ws0, ws1, e, body) {
              return {block: body.block, assignee: e, raw: t + ws0 + 'catch' + ws1 + e.raw + body.raw};
            })(r1.offset, r1.line, r1.column, r3, r4, r6, r7, r8);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_finallyClause() {
        var cacheKey = "finallyClause@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_FINALLY();
            if (r5 !== null) {
              r6 = parse_tryBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, ws, body) {
              return {block: body.block, raw: t + ws + 'finally' + body.raw};
            })(r1.offset, r1.line, r1.column, r3, r4, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_class() {
        var cacheKey = "class@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_CLASS();
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse__();
          if (r6 !== null) {
            r7 = parse_Assignable();
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_EXTENDS();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_extendee();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_classBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, name, parent, body) {
              var ctor = null;
              var raw = 'class' + (name ? name[0] + name[1].raw : '') +
                (parent ? parent[0] + 'parent' + parent[2] + parent[3].raw : '') +
                body.raw;
              name = name ? name[1] : null;
              parent = parent ? parent[3] : null;
              var boundMembers = [];
              var stmts = body.block != null ? body.block.statements || [body.block] : [];
              for(var i = 0, l = stmts.length; i < l; ++i) {
                var m = stmts[i];
                if(m.instanceof(CS.Constructor)) {
                  ctor = m;
                } else if(m.instanceof(CS.ClassProtoAssignOp) && m.expression.instanceof(CS.BoundFunction)) {
                  boundMembers.push(m);
                }
              }
              return new CS.Class(name, parent, ctor, body.block, boundMembers).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_extendee() {
        var cacheKey = "extendee@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r4 = clone(pos);
          reportFailures++;
          r5 = clone(pos);
          r6 = parse_memberExpression();
          if (r6 !== null) {
            r7 = [];
            r8 = parse_MemberAccessOps();
            if (r8 === null) {
              r8 = parse_argumentList();
            }
            while (r8 !== null) {
              r7.push(r8);
              r8 = parse_MemberAccessOps();
              if (r8 === null) {
                r8 = parse_argumentList();
              }
            }
            if (r7 !== null) {
              r8 = parse_TERMINDENT();
              if (r8 !== null) {
                r9 = parse_implicitObjectLiteralMember();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = clone(r5);
                }
              } else {
                r3 = null;
                pos = clone(r5);
              }
            } else {
              r3 = null;
              pos = clone(r5);
            }
          } else {
            r3 = null;
            pos = clone(r5);
          }
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r4 = parse_assignmentExpression();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, a) { return a; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse_memberExpression();
            if (r3 !== null) {
              r5 = clone(pos);
              r6 = parse_argumentList();
              if (r6 !== null) {
                r7 = [];
                r8 = parse_MemberAccessOps();
                if (r8 === null) {
                  r8 = parse_argumentList();
                }
                while (r8 !== null) {
                  r7.push(r8);
                  r8 = parse_MemberAccessOps();
                  if (r8 === null) {
                    r8 = parse_argumentList();
                  }
                }
                if (r7 !== null) {
                  r4 = [r6, r7];
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
              } else {
                r4 = null;
                pos = clone(r5);
              }
              r4 = r4 !== null ? r4 : "";
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, fn, accesses) {
                    if(accesses)
                      fn = createMemberExpression(fn, [accesses[0]].concat(accesses[1] || []));
                    return fn;
                  })(r1.offset, r1.line, r1.column, r3, r4);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_classBody() {
        var cacheKey = "classBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_classBlock();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, t, b, d) { return {block: b, raw: ws + t + b.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_THEN();
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r6 = parse_classStatement();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws0, t, ws1, s) {
                  return {block: s, raw: ws0 + t + ws1 + s.raw};
                })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            r0 = r0 !== null ? r0 : "";
            if (r0 !== null) {
              r0 = (function(offset, line, column, all) {
                    return {block: null, raw: all ? all[0] + all[1] : ''};
                  })(r1.offset, r1.line, r1.column, r0);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_classBlock() {
        var cacheKey = "classBlock@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_classStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_classStatement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_classStatement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, s, ss, term) {
                var raw = s.raw + ss.map(function(s){ return s[0] + s[1] + s[2] + s[3].raw; }).join('') + term;
                return new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_classStatement() {
        var cacheKey = "classStatement@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_classProtoAssignment();
        if (r0 === null) {
          r0 = parse_staticAssignment();
          if (r0 === null) {
            r0 = parse_constructor();
            if (r0 === null) {
              r0 = parse_expression();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_constructor() {
        var cacheKey = "constructor@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = clone(pos);
                r9 = clone(pos);
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_expression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
                if (r7 !== null) {
                  r7 = (function(offset, line, column, t, e, d) { return {raw: t + e.raw + d, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                }
                if (r7 === null) {
                  pos = clone(r8);
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, t, ws1, e) { return {raw: t + ws1 + e.raw, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, e) {
                if(!key.instanceof(CS.String, CS.Identifier) || key.data !== 'constructor') return null;
                var raw = key.raw + ws0 + ":" + ws1 + e.raw;
                e = e.expr;
                if(e.instanceof(CS.BoundFunction))
                  e = new CS.Function(e.parameters, e.block).r(e.raw).p(e.line, e.column);
                return new CS.Constructor(e).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_staticAssignment() {
        var cacheKey = "staticAssignment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_contextVar();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_expression();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, e) {
                var raw = key.raw + ws0 + ":" + ws1 + e.raw;
                return new CS.AssignOp(key, e).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_classProtoAssignment() {
        var cacheKey = "classProtoAssignment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = clone(pos);
                r9 = clone(pos);
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_expression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
                if (r7 !== null) {
                  r7 = (function(offset, line, column, t, e, d) { return {raw: t + e.raw + d, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                }
                if (r7 === null) {
                  pos = clone(r8);
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, t, ws1, e) { return {raw: t + ws1 + e.raw, expr: e}; })(r8.offset, r8.line, r8.column, r10, r11, r12);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, e) {
                if(key.data === 'constructor') return null;
                var raw = key.raw + ws0 + ":" + ws1 + e.raw;
                return new CS.ClassProtoAssignOp(key, e.expr).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_forOf() {
        var cacheKey = "forOf@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_FOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r6 = clone(pos);
            r7 = parse_OWN();
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_Assignable();
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r9 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 44) {
                    r10 = ",";
                    advance(pos, 1);
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_Assignable();
                      if (r12 !== null) {
                        r13 = parse__();
                        if (r13 !== null) {
                          r8 = [r10, r11, r12, r13];
                        } else {
                          r8 = null;
                          pos = clone(r9);
                        }
                      } else {
                        r8 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r8 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r8 = null;
                    pos = clone(r9);
                  }
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r9 = parse_OF();
                    if (r9 !== null) {
                      r10 = parse__();
                      if (r10 !== null) {
                        r11 = parse_assignmentExpression();
                        if (r11 !== null) {
                          r12 = parse__();
                          if (r12 !== null) {
                            r14 = clone(pos);
                            r15 = parse_WHEN();
                            if (r15 !== null) {
                              r16 = parse__();
                              if (r16 !== null) {
                                r17 = parse_assignmentExpression();
                                if (r17 !== null) {
                                  r18 = parse__();
                                  if (r18 !== null) {
                                    r13 = [r15, r16, r17, r18];
                                  } else {
                                    r13 = null;
                                    pos = clone(r14);
                                  }
                                } else {
                                  r13 = null;
                                  pos = clone(r14);
                                }
                              } else {
                                r13 = null;
                                pos = clone(r14);
                              }
                            } else {
                              r13 = null;
                              pos = clone(r14);
                            }
                            r13 = r13 !== null ? r13 : "";
                            if (r13 !== null) {
                              r14 = parse_conditionalBody();
                              if (r14 !== null) {
                                r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14];
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, own, key, ws1, maybeVal, ws2, obj, ws3, maybeFilter, body) {
              var raw = 'for' + ws0 + (own ? 'own' + own[1] : '') + key.raw + ws1 +
                (maybeVal ? ',' + maybeVal[1] + maybeVal[2].raw + maybeVal[3] : '') +
                'of' + ws2 + obj.raw + ws3 +
                (maybeFilter ? 'when' + maybeFilter[1] + maybeFilter[2].raw + maybeFilter[3] : '') +
                body.raw;
              var val = maybeVal ? maybeVal[2] : null;
              var filter = maybeFilter ? maybeFilter[2] : null;
              return new CS.ForOf(!!own, key, val, obj, filter, body.block).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6, r7, r8, r10, r11, r12, r13, r14);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_forIn() {
        var cacheKey = "forIn@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_FOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_Assignable();
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = clone(pos);
                if (input.charCodeAt(pos.offset) === 44) {
                  r9 = ",";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r11 = parse_Assignable();
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r7 = [r9, r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r8);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r8);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r8);
                  }
                } else {
                  r7 = null;
                  pos = clone(r8);
                }
                r7 = r7 !== null ? r7 : "";
                if (r7 !== null) {
                  r8 = parse_IN();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_assignmentExpression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r13 = clone(pos);
                          r14 = parse_BY();
                          if (r14 !== null) {
                            r15 = parse__();
                            if (r15 !== null) {
                              r16 = parse_assignmentExpression();
                              if (r16 !== null) {
                                r17 = parse__();
                                if (r17 !== null) {
                                  r12 = [r14, r15, r16, r17];
                                } else {
                                  r12 = null;
                                  pos = clone(r13);
                                }
                              } else {
                                r12 = null;
                                pos = clone(r13);
                              }
                            } else {
                              r12 = null;
                              pos = clone(r13);
                            }
                          } else {
                            r12 = null;
                            pos = clone(r13);
                          }
                          r12 = r12 !== null ? r12 : "";
                          if (r12 !== null) {
                            r14 = clone(pos);
                            r15 = parse_WHEN();
                            if (r15 !== null) {
                              r16 = parse__();
                              if (r16 !== null) {
                                r17 = parse_assignmentExpression();
                                if (r17 !== null) {
                                  r18 = parse__();
                                  if (r18 !== null) {
                                    r13 = [r15, r16, r17, r18];
                                  } else {
                                    r13 = null;
                                    pos = clone(r14);
                                  }
                                } else {
                                  r13 = null;
                                  pos = clone(r14);
                                }
                              } else {
                                r13 = null;
                                pos = clone(r14);
                              }
                            } else {
                              r13 = null;
                              pos = clone(r14);
                            }
                            r13 = r13 !== null ? r13 : "";
                            if (r13 !== null) {
                              r14 = parse_conditionalBody();
                              if (r14 !== null) {
                                r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14];
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r2);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, val, ws1, maybeKey, ws2, list, ws3, maybeStep, maybeFilter, body) {
              var raw = 'for' + ws0 + val.raw + ws1 +
                (maybeKey ? ',' + maybeKey[1] + maybeKey[2].raw + maybeKey[3] : '') +
                'in' + ws2 + list.raw + ws3 +
                (maybeStep ? 'by' + maybeStep[1] + maybeStep[2].raw + maybeStep[3] : '') +
                (maybeFilter ? 'when' + maybeFilter[1] + maybeFilter[2].raw + maybeFilter[3] : '') +
                body.raw;
              var key = maybeKey ? maybeKey[2] : null;
              var step = maybeStep ? maybeStep[2] : new CS.Int(1).r('1').g();
              var filter = maybeFilter ? maybeFilter[2] : null;
              return new CS.ForIn(val, key, list, step, filter, body.block).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6, r7, r9, r10, r11, r12, r13, r14);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_switch() {
        var cacheKey = "switch@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_SWITCH();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_expressionworthy();
            if (r5 === null) {
              r5 = parse_assignmentExpression();
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_switchBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, e, body) {
              var raw = 'switch' + ws + (e ? e.raw : '') + body.raw;
              return new CS.Switch(e || null, body.cases, body['else'] || null).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_switchBody() {
        var cacheKey = "switchBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_switchBlock();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, t, b, d) { return {cases: b.cases, 'else': b['else'], raw: ws + t + b.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_THEN();
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r6 = parse_case();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws0, t, ws1, c) { return {cases: [c], raw: ws0 + t + ws1 + c.raw}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, ws) { return {cases: [], raw: ws + 'then'}; })(r1.offset, r1.line, r1.column, r3);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_switchBlock() {
        var cacheKey = "switchBlock@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_case();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_case();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_case();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_elseClause();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_TERMINATOR();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w, ws, elseClause, term) {
                var raw = w.raw + ws.map(function(w){ return w[0] + w[1] + w[2] + w[3].raw; }).join('') +
                  (elseClause ? elseClause[0] + elseClause[1] + elseClause[2] + elseClause[3].raw : '') + term;
                var cases = [w].concat(ws.map(function(w){ return w[3]; }));
                return {cases: cases, 'else': elseClause ? elseClause[3].block : null, raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_case() {
        var cacheKey = "case@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_WHEN();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_caseConditions();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, conditions, body) {
                var raw = 'when' + ws + conditions.raw + body.raw
                return new CS.SwitchCase(conditions.list, body.block).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_caseConditions() {
        var cacheKey = "caseConditions@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_assignmentExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos.offset) === 44) {
              r8 = ",";
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_assignmentExpression();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos.offset) === 44) {
                r8 = ",";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_assignmentExpression();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, c, cs) {
                var raw = c.raw + cs.map(function(c){ return c[0] + c[1] + c[2] + c[3].raw; }).join('');
                return {list: [c].concat(cs.map(function(c){ return c[3]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_functionLiteral() {
        var cacheKey = "functionLiteral@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r4 = clone(pos);
        if (input.charCodeAt(pos.offset) === 40) {
          r5 = "(";
          advance(pos, 1);
        } else {
          r5 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (r5 !== null) {
          r6 = parse__();
          if (r6 !== null) {
            r8 = clone(pos);
            r9 = clone(pos);
            r10 = parse_TERMINDENT();
            if (r10 !== null) {
              r11 = parse_parameterList();
              if (r11 !== null) {
                r12 = parse_DEDENT();
                if (r12 !== null) {
                  r13 = parse_TERMINATOR();
                  if (r13 !== null) {
                    r7 = [r10, r11, r12, r13];
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
              } else {
                r7 = null;
                pos = clone(r9);
              }
            } else {
              r7 = null;
              pos = clone(r9);
            }
            if (r7 !== null) {
              r7 = (function(offset, line, column, td, p, d, t) { return {e: p, raw: td + p.raw + d + t}; })(r8.offset, r8.line, r8.column, r10, r11, r12, r13);
            }
            if (r7 === null) {
              pos = clone(r8);
            }
            if (r7 === null) {
              r8 = clone(pos);
              r7 = parse_parameterList();
              if (r7 !== null) {
                r7 = (function(offset, line, column, p) { return {e: p, raw: p.raw}; })(r8.offset, r8.line, r8.column, r7);
              }
              if (r7 === null) {
                pos = clone(r8);
              }
            }
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                if (input.charCodeAt(pos.offset) === 41) {
                  r9 = ")";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r3 = [r5, r6, r7, r8, r9, r10];
                  } else {
                    r3 = null;
                    pos = clone(r4);
                  }
                } else {
                  r3 = null;
                  pos = clone(r4);
                }
              } else {
                r3 = null;
                pos = clone(r4);
              }
            } else {
              r3 = null;
              pos = clone(r4);
            }
          } else {
            r3 = null;
            pos = clone(r4);
          }
        } else {
          r3 = null;
          pos = clone(r4);
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.substr(pos.offset, 2) === "->") {
            r4 = "->";
            advance(pos, 2);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"->\"");
            }
          }
          if (r4 === null) {
            if (input.substr(pos.offset, 2) === "=>") {
              r4 = "=>";
              advance(pos, 2);
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"=>\"");
              }
            }
          }
          if (r4 !== null) {
            r5 = parse_functionBody();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, params, arrow, body) {
              if(!body) body = {block: null, raw: ''};
              var raw =
                (params ? params[0] + params[1] + (params[2] && params[2].raw) + params[3] + params[4] + params[5] : '') +
                arrow + body.raw;
              var constructor;
              switch(arrow) {
                case '->': constructor = CS.Function; break;
                case '=>': constructor = CS.BoundFunction; break;
                default: throw new Error('parsed function arrow ("' + arrow + '") not associated with a constructor');
              }
              params = params && params[2] && params[2].e ? params[2].e.list : [];
              return new constructor(params, body.block).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_functionBody() {
        var cacheKey = "functionBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_block();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, t, b, d) { return {block: b, raw: ws + t + b.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_statement();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, s) {
                  return {block: s, raw: ws + s.raw};
                })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_parameter() {
        var cacheKey = "parameter@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_Assignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 61) {
              r5 = "=";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_secondaryExpression();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, param, ws0, ws1, default_) {
                var raw = param.raw + ws0 + '=' + ws1 + default_.raw;
                return new CS.DefaultParam(param, default_).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r0 = parse_rest();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_rest() {
        var cacheKey = "rest@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_Assignable();
        if (r3 !== null) {
          if (input.substr(pos.offset, 3) === "...") {
            r4 = "...";
            advance(pos, 3);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"...\"");
            }
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, a, rest) {
                  return (rest ? new CS.Rest(a) : a).r(a.raw + rest).p(line, column, offset);
                })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_parameterList() {
        var cacheKey = "parameterList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_parameter();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            r9 = clone(pos);
            r10 = clone(pos);
            if (input.charCodeAt(pos.offset) === 44) {
              r11 = ",";
              advance(pos, 1);
            } else {
              r11 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r11 !== null) {
              r12 = parse_TERMINATOR();
              r12 = r12 !== null ? r12 : "";
              if (r12 !== null) {
                r8 = [r11, r12];
              } else {
                r8 = null;
                pos = clone(r10);
              }
            } else {
              r8 = null;
              pos = clone(r10);
            }
            if (r8 !== null) {
              r8 = (function(offset, line, column, c, t) { return c + t; })(r9.offset, r9.line, r9.column, r11, r12);
            }
            if (r8 === null) {
              pos = clone(r9);
            }
            if (r8 === null) {
              r8 = parse_TERMINATOR();
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_parameter();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              r9 = clone(pos);
              r10 = clone(pos);
              if (input.charCodeAt(pos.offset) === 44) {
                r11 = ",";
                advance(pos, 1);
              } else {
                r11 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r11 !== null) {
                r12 = parse_TERMINATOR();
                r12 = r12 !== null ? r12 : "";
                if (r12 !== null) {
                  r8 = [r11, r12];
                } else {
                  r8 = null;
                  pos = clone(r10);
                }
              } else {
                r8 = null;
                pos = clone(r10);
              }
              if (r8 !== null) {
                r8 = (function(offset, line, column, c, t) { return c + t; })(r9.offset, r9.line, r9.column, r11, r12);
              }
              if (r8 === null) {
                pos = clone(r9);
              }
              if (r8 === null) {
                r8 = parse_TERMINATOR();
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_parameter();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, es) {
                var raw = e.raw + es.map(function(e){ return e[0] + e[1] + e[2] + e[3].raw; }).join('');
                return {list: [e].concat(es.map(function(e){ return e[3]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_range() {
        var cacheKey = "range@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          r3 = "[";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_secondaryExpression();
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.substr(pos.offset, 2) === "..") {
                  r7 = "..";
                  advance(pos, 2);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"..\"");
                  }
                }
                if (r7 !== null) {
                  if (input.charCodeAt(pos.offset) === 46) {
                    r8 = ".";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_secondaryExpression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos.offset) === 93) {
                            r12 = "]";
                            advance(pos, 1);
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"]\"");
                            }
                          }
                          if (r12 !== null) {
                            r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                          } else {
                            r0 = null;
                            pos = clone(r2);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws0, left, ws1, exclusiveDot, ws2, right, ws3) {
              var raw = '[' + ws0 + left.raw + ws1 + '..' + exclusiveDot + ws2 + right.raw + ws3 + ']';
              var inclusive = !exclusiveDot;
              return new CS.Range(inclusive, left, right).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6, r8, r9, r10, r11);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteral() {
        var cacheKey = "arrayLiteral@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          r3 = "[";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_arrayLiteralBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos.offset) === 93) {
                  r7 = "]";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, members, t, ws) {
              var raw = "[" + members.raw + t + ws + "]";
              return new CS.ArrayInitialiser(members.list).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralBody() {
        var cacheKey = "arrayLiteralBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_arrayLiteralMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, members, d) { return {list: members.list, raw: t + members.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_arrayLiteralMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, members) { return {list: members ? members.list : [], raw: ws + members ? members.raw : ''}; })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMemberList() {
        var cacheKey = "arrayLiteralMemberList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_arrayLiteralMember();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = [];
            r7 = clone(pos);
            r8 = parse_arrayLiteralMemberSeparator();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_arrayLiteralMember();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r6 = [r8, r9, r10, r11];
                  } else {
                    r6 = null;
                    pos = clone(r7);
                  }
                } else {
                  r6 = null;
                  pos = clone(r7);
                }
              } else {
                r6 = null;
                pos = clone(r7);
              }
            } else {
              r6 = null;
              pos = clone(r7);
            }
            while (r6 !== null) {
              r5.push(r6);
              r7 = clone(pos);
              r8 = parse_arrayLiteralMemberSeparator();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_arrayLiteralMember();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r6 = [r8, r9, r10, r11];
                    } else {
                      r6 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r6 = null;
                    pos = clone(r7);
                  }
                } else {
                  r6 = null;
                  pos = clone(r7);
                }
              } else {
                r6 = null;
                pos = clone(r7);
              }
            }
            if (r5 !== null) {
              r6 = parse_arrayLiteralMemberSeparator();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, ws, es, trail) {
                var raw = e.raw + ws + es.map(function(e){ return e[0] + e[1] + e[2].raw + e[3]; }).join('') + trail;
                return {list: [e].concat(es.map(function(e){ return e[2]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMember() {
        var cacheKey = "arrayLiteralMember@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_spread();
        if (r0 === null) {
          r0 = parse_expression();
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r3 = parse_TERMINDENT();
            if (r3 !== null) {
              r4 = parse_implicitObjectLiteral();
              if (r4 !== null) {
                r5 = parse_DEDENT();
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, o) { return o; })(r1.offset, r1.line, r1.column, r4);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMemberSeparator() {
        var cacheKey = "arrayLiteralMemberSeparator@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 44) {
              r5 = ",";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, ws, c) { return t + ws + c; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 44) {
            r3 = ",";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (r3 !== null) {
            r4 = parse_TERMINATOR();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, t) { return ',' + t; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteral() {
        var cacheKey = "objectLiteral@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 123) {
          r3 = "{";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_objectLiteralBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos.offset) === 125) {
                  r7 = "}";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"}\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, members, t, ws) {
            var raw = '{' + members.raw + t + ws + '}'
            return new CS.ObjectInitialiser(members.list).r(raw).p(line, column, offset);
          })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralBody() {
        var cacheKey = "objectLiteralBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_objectLiteralMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, members, d) { return {list: members.list, raw: t + members.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_objectLiteralMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, members) { return {list: members ? members.list : [], raw: ws + members ? members.raw : ''}; })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralMemberList() {
        var cacheKey = "objectLiteralMemberList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_objectLiteralMember();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = [];
            r7 = clone(pos);
            r8 = parse_arrayLiteralMemberSeparator();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_objectLiteralMember();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r6 = [r8, r9, r10, r11];
                  } else {
                    r6 = null;
                    pos = clone(r7);
                  }
                } else {
                  r6 = null;
                  pos = clone(r7);
                }
              } else {
                r6 = null;
                pos = clone(r7);
              }
            } else {
              r6 = null;
              pos = clone(r7);
            }
            while (r6 !== null) {
              r5.push(r6);
              r7 = clone(pos);
              r8 = parse_arrayLiteralMemberSeparator();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_objectLiteralMember();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r6 = [r8, r9, r10, r11];
                    } else {
                      r6 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r6 = null;
                    pos = clone(r7);
                  }
                } else {
                  r6 = null;
                  pos = clone(r7);
                }
              } else {
                r6 = null;
                pos = clone(r7);
              }
            }
            if (r5 !== null) {
              if (input.charCodeAt(pos.offset) === 44) {
                r6 = ",";
                advance(pos, 1);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, ws, es, trail) {
                var raw = e.raw + ws + es.map(function(e){ return e[0] + e[1] + e[2].raw + e[3]; }).join('') + trail;
                return {list: [e].concat(es.map(function(e){ return e[2]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralMember() {
        var cacheKey = "objectLiteralMember@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_expression();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, val) {
                var raw = key.raw + ws0 + ':' + ws1 + val.raw;
                return new CS.ObjectInitialiserMember(key, val).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r0 = parse_contextVar();
          if (r0 !== null) {
            r0 = (function(offset, line, column, v) {
                  var key = new CS.String(v.memberName).r(v.memberName).p(line, column + 1)
                  return new CS.ObjectInitialiserMember(key, v).r(v.raw).p(line, column, offset);
                })(r1.offset, r1.line, r1.column, r0);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r0 = parse_ObjectInitialiserKeys();
            if (r0 !== null) {
              r0 = (function(offset, line, column, v) {
                    return new CS.ObjectInitialiserMember(v, v).r(v.raw).p(line, column, offset);
                  })(r1.offset, r1.line, r1.column, r0);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ObjectInitialiserKeys() {
        var cacheKey = "ObjectInitialiserKeys@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_identifierName();
        if (r0 !== null) {
          r0 = (function(offset, line, column, i) { return new CS.Identifier(i).r(i).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r0 = parse_string();
          if (r0 === null) {
            r0 = parse_Numbers();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteral() {
        var cacheKey = "implicitObjectLiteral@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_implicitObjectLiteralMemberList();
        if (r0 !== null) {
          r0 = (function(offset, line, column, members) {
            return new CS.ObjectInitialiser(members.list).r(members.raw).p(line, column, offset);
          })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberList() {
        var cacheKey = "implicitObjectLiteralMemberList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_implicitObjectLiteralMember();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse_implicitObjectLiteralMemberSeparator();
          if (r7 !== null) {
            r8 = parse__();
            if (r8 !== null) {
              r9 = parse_implicitObjectLiteralMember();
              if (r9 !== null) {
                r5 = [r7, r8, r9];
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse_implicitObjectLiteralMemberSeparator();
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                r9 = parse_implicitObjectLiteralMember();
                if (r9 !== null) {
                  r5 = [r7, r8, r9];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r6 = clone(pos);
            if (input.charCodeAt(pos.offset) === 44) {
              r7 = ",";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, es) {
                var raw = e.raw + es.map(function(e){ return e[0] + e[1] + e[2].raw; }).join('');
                return {list: [e].concat(es.map(function(e){ return e[2]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberSeparator() {
        var cacheKey = "implicitObjectLiteralMemberSeparator@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = parse_TERMINATOR();
        if (r2 !== null) {
          if (input.charCodeAt(pos.offset) === 44) {
            r3 = ",";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          r3 = r3 !== null ? r3 : "";
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r0 = [r2, r3, r4];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 44) {
            r2 = ",";
            advance(pos, 1);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (r2 !== null) {
            r3 = parse_TERMINATOR();
            r3 = r3 !== null ? r3 : "";
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMember() {
        var cacheKey = "implicitObjectLiteralMember@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_implicitObjectLiteralMemberValue();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, val) {
                return new CS.ObjectInitialiserMember(key, val.value).r(key.raw + ws0 + ':' + ws1 + val.raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberValue() {
        var cacheKey = "implicitObjectLiteralMemberValue@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r0 = parse_expression();
        if (r0 !== null) {
          r0 = (function(offset, line, column, e) { return {value: e, raw: e.raw}; })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse_TERMINDENT();
          if (r3 !== null) {
            r4 = parse_implicitObjectLiteral();
            if (r4 !== null) {
              r5 = parse_DEDENT();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, i, o, d) { return {value: o, raw: i + o.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_macro() {
        var cacheKey = "macro@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 8) === "__LINE__") {
          r0 = "__LINE__";
          advance(pos, 8);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"__LINE__\"");
          }
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, r) { return new CS.Int(line).r(r).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.substr(pos.offset, 8) === "__DATE__") {
            r0 = "__DATE__";
            advance(pos, 8);
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"__DATE__\"");
            }
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, r) { return new CS.String(new Date().toDateString().slice(4)).r(r).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            if (input.substr(pos.offset, 8) === "__TIME__") {
              r0 = "__TIME__";
              advance(pos, 8);
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"__TIME__\"");
              }
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, r) { return new CS.String(new Date().toTimeString().slice(0, 8)).r(r).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              if (input.substr(pos.offset, 14) === "__DATETIMEMS__") {
                r0 = "__DATETIMEMS__";
                advance(pos, 14);
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"__DATETIMEMS__\"");
                }
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, r) { return new CS.Int(+new Date).r(r).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bool() {
        var cacheKey = "bool@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_TRUE();
        if (r0 === null) {
          r0 = parse_YES();
          if (r0 === null) {
            r0 = parse_ON();
          }
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, match) { return new CS.Bool(true).r(match).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r0 = parse_FALSE();
          if (r0 === null) {
            r0 = parse_NO();
            if (r0 === null) {
              r0 = parse_OFF();
            }
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, match) { return new CS.Bool(false).r(match).p(line, column, offset); })(r1.offset, r1.line, r1.column, r0);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_Numbers() {
        var cacheKey = "Numbers@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "0b") {
          r3 = "0b";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"0b\"");
          }
        }
        if (r3 !== null) {
          r5 = parse_bit();
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_bit();
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, bs) { return new CS.Int(parseInt(bs.join(''), 2)).r("0b" + bs).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.substr(pos.offset, 2) === "0o") {
            r3 = "0o";
            advance(pos, 2);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"0o\"");
            }
          }
          if (r3 !== null) {
            r5 = parse_octalDigit();
            if (r5 !== null) {
              r4 = [];
              while (r5 !== null) {
                r4.push(r5);
                r5 = parse_octalDigit();
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, os) { return new CS.Int(parseInt(os.join(''), 8)).r("0o" + os).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.substr(pos.offset, 2) === "0x") {
              r3 = "0x";
              advance(pos, 2);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"0x\"");
              }
            }
            if (r3 !== null) {
              r5 = parse_hexDigit();
              if (r5 !== null) {
                r4 = [];
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_hexDigit();
                }
              } else {
                r4 = null;
              }
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, hs) { return new CS.Int(parseInt(hs.join(''), 16)).r("0x" + hs).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              r3 = parse_decimal();
              if (r3 !== null) {
                if (/^[eE]/.test(input.charAt(pos.offset))) {
                  r4 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed("[eE]");
                  }
                }
                if (r4 !== null) {
                  if (/^[+\-]/.test(input.charAt(pos.offset))) {
                    r5 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[+\\-]");
                    }
                  }
                  r5 = r5 !== null ? r5 : "";
                  if (r5 !== null) {
                    r6 = parse_decimal();
                    if (r6 !== null) {
                      r0 = [r3, r4, r5, r6];
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, base, e, sign, exponent) {
                    var raw = base.raw + e + sign + exponent.raw;
                    return new CS.Float(parseFloat('' + base.data + e + sign + exponent.data, 10)).r(raw).p(line, column, offset);
                  })(r1.offset, r1.line, r1.column, r3, r4, r5, r6);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
              if (r0 === null) {
                r0 = parse_decimal();
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_decimal() {
        var cacheKey = "decimal@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_integer();
        if (r3 !== null) {
          r5 = clone(pos);
          if (input.charCodeAt(pos.offset) === 46) {
            r6 = ".";
            advance(pos, 1);
          } else {
            r6 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (r6 !== null) {
            r8 = parse_decimalDigit();
            if (r8 !== null) {
              r7 = [];
              while (r8 !== null) {
                r7.push(r8);
                r8 = parse_decimalDigit();
              }
            } else {
              r7 = null;
            }
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, integral, fractional) {
              if(fractional) fractional = "." + fractional[1].join('');
              return fractional
                ? new CS.Float(parseFloat(integral + fractional, 10)).r(integral + fractional).p(line, column, offset)
                : new CS.Int(+integral).r(integral).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_integer() {
        var cacheKey = "integer@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        if (input.charCodeAt(pos.offset) === 48) {
          r0 = "0";
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (/^[1-9]/.test(input.charAt(pos.offset))) {
            r3 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (r3 !== null) {
            r4 = [];
            r5 = parse_decimalDigit();
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_decimalDigit();
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, a, bs) { return a + (bs ? bs.join('') : ''); })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_decimalDigit() {
        var cacheKey = "decimalDigit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-9]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_hexDigit() {
        var cacheKey = "hexDigit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_octalDigit() {
        var cacheKey = "octalDigit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-7]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-7]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_bit() {
        var cacheKey = "bit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[01]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[01]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_string() {
        var cacheKey = "string@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "\"\"\"") {
          r3 = "\"\"\"";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\\\"\\\"\"");
          }
        }
        if (r3 !== null) {
          r5 = parse_stringData();
          if (r5 === null) {
            if (input.charCodeAt(pos.offset) === 39) {
              r5 = "'";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (r5 === null) {
              r6 = clone(pos);
              r7 = clone(pos);
              if (input.charCodeAt(pos.offset) === 34) {
                r8 = "\"";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r8 !== null) {
                if (input.charCodeAt(pos.offset) === 34) {
                  r9 = "\"";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r11 = clone(pos);
                  reportFailures++;
                  if (input.charCodeAt(pos.offset) === 34) {
                    r10 = "\"";
                    advance(pos, 1);
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  reportFailures--;
                  if (r10 === null) {
                    r10 = "";
                  } else {
                    r10 = null;
                    pos = clone(r11);
                  }
                  if (r10 !== null) {
                    r5 = [r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                } else {
                  r5 = null;
                  pos = clone(r7);
                }
              } else {
                r5 = null;
                pos = clone(r7);
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column, s) { return s.join(''); })(r6.offset, r6.line, r6.column, r5);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_stringData();
              if (r5 === null) {
                if (input.charCodeAt(pos.offset) === 39) {
                  r5 = "'";
                  advance(pos, 1);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r5 === null) {
                  r6 = clone(pos);
                  r7 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 34) {
                    r8 = "\"";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r8 !== null) {
                    if (input.charCodeAt(pos.offset) === 34) {
                      r9 = "\"";
                      advance(pos, 1);
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r9 = r9 !== null ? r9 : "";
                    if (r9 !== null) {
                      r11 = clone(pos);
                      reportFailures++;
                      if (input.charCodeAt(pos.offset) === 34) {
                        r10 = "\"";
                        advance(pos, 1);
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r10 === null) {
                        r10 = "";
                      } else {
                        r10 = null;
                        pos = clone(r11);
                      }
                      if (r10 !== null) {
                        r5 = [r8, r9, r10];
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                  if (r5 !== null) {
                    r5 = (function(offset, line, column, s) { return s.join(''); })(r6.offset, r6.line, r6.column, r5);
                  }
                  if (r5 === null) {
                    pos = clone(r6);
                  }
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos.offset, 3) === "\"\"\"") {
              r5 = "\"\"\"";
              advance(pos, 3);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\\\"\\\"\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, d) {
              var data = stripLeadingWhitespace(d.join(''));
              return new CS.String(data).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.substr(pos.offset, 3) === "'''") {
            r3 = "'''";
            advance(pos, 3);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"'''\"");
            }
          }
          if (r3 !== null) {
            r5 = parse_stringData();
            if (r5 === null) {
              if (input.charCodeAt(pos.offset) === 34) {
                r5 = "\"";
                advance(pos, 1);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r5 === null) {
                if (input.charCodeAt(pos.offset) === 35) {
                  r5 = "#";
                  advance(pos, 1);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                if (r5 === null) {
                  r6 = clone(pos);
                  r7 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 39) {
                    r8 = "'";
                    advance(pos, 1);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                  if (r8 !== null) {
                    if (input.charCodeAt(pos.offset) === 39) {
                      r9 = "'";
                      advance(pos, 1);
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    r9 = r9 !== null ? r9 : "";
                    if (r9 !== null) {
                      r11 = clone(pos);
                      reportFailures++;
                      if (input.charCodeAt(pos.offset) === 39) {
                        r10 = "'";
                        advance(pos, 1);
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                      reportFailures--;
                      if (r10 === null) {
                        r10 = "";
                      } else {
                        r10 = null;
                        pos = clone(r11);
                      }
                      if (r10 !== null) {
                        r5 = [r8, r9, r10];
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                  if (r5 !== null) {
                    r5 = (function(offset, line, column, s) { return s.join(''); })(r6.offset, r6.line, r6.column, r5);
                  }
                  if (r5 === null) {
                    pos = clone(r6);
                  }
                }
              }
            }
            if (r5 !== null) {
              r4 = [];
              while (r5 !== null) {
                r4.push(r5);
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos.offset) === 34) {
                    r5 = "\"";
                    advance(pos, 1);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r5 === null) {
                    if (input.charCodeAt(pos.offset) === 35) {
                      r5 = "#";
                      advance(pos, 1);
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                    if (r5 === null) {
                      r6 = clone(pos);
                      r7 = clone(pos);
                      if (input.charCodeAt(pos.offset) === 39) {
                        r8 = "'";
                        advance(pos, 1);
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                      if (r8 !== null) {
                        if (input.charCodeAt(pos.offset) === 39) {
                          r9 = "'";
                          advance(pos, 1);
                        } else {
                          r9 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        r9 = r9 !== null ? r9 : "";
                        if (r9 !== null) {
                          r11 = clone(pos);
                          reportFailures++;
                          if (input.charCodeAt(pos.offset) === 39) {
                            r10 = "'";
                            advance(pos, 1);
                          } else {
                            r10 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          reportFailures--;
                          if (r10 === null) {
                            r10 = "";
                          } else {
                            r10 = null;
                            pos = clone(r11);
                          }
                          if (r10 !== null) {
                            r5 = [r8, r9, r10];
                          } else {
                            r5 = null;
                            pos = clone(r7);
                          }
                        } else {
                          r5 = null;
                          pos = clone(r7);
                        }
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                      if (r5 !== null) {
                        r5 = (function(offset, line, column, s) { return s.join(''); })(r6.offset, r6.line, r6.column, r5);
                      }
                      if (r5 === null) {
                        pos = clone(r6);
                      }
                    }
                  }
                }
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              if (input.substr(pos.offset, 3) === "'''") {
                r5 = "'''";
                advance(pos, 3);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'''\"");
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, d) {
                var data = stripLeadingWhitespace(d.join(''));
                return new CS.String(data).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.charCodeAt(pos.offset) === 34) {
              r3 = "\"";
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (r3 !== null) {
              r4 = [];
              r5 = parse_stringData();
              if (r5 === null) {
                if (input.charCodeAt(pos.offset) === 39) {
                  r5 = "'";
                  advance(pos, 1);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
              }
              while (r5 !== null) {
                r4.push(r5);
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos.offset) === 39) {
                    r5 = "'";
                    advance(pos, 1);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
              }
              if (r4 !== null) {
                if (input.charCodeAt(pos.offset) === 34) {
                  r5 = "\"";
                  advance(pos, 1);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, d) { return new CS.String(d ? d.join('') : '').p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              if (input.charCodeAt(pos.offset) === 39) {
                r3 = "'";
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos.offset) === 34) {
                    r5 = "\"";
                    advance(pos, 1);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r5 === null) {
                    if (input.charCodeAt(pos.offset) === 35) {
                      r5 = "#";
                      advance(pos, 1);
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                  }
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_stringData();
                  if (r5 === null) {
                    if (input.charCodeAt(pos.offset) === 34) {
                      r5 = "\"";
                      advance(pos, 1);
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    if (r5 === null) {
                      if (input.charCodeAt(pos.offset) === 35) {
                        r5 = "#";
                        advance(pos, 1);
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"#\"");
                        }
                      }
                    }
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos.offset) === 39) {
                    r5 = "'";
                    advance(pos, 1);
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                  if (r5 !== null) {
                    r0 = [r3, r4, r5];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, d) { return new CS.String(d ? d.join('') : '').p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_stringData() {
        var cacheKey = "stringData@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        if (/^[^"'\\#]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\"'\\\\#]");
          }
        }
        if (r0 === null) {
          r0 = parse_UnicodeEscapeSequence();
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.substr(pos.offset, 2) === "\\x") {
              r3 = "\\x";
              advance(pos, 2);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\x\"");
              }
            }
            if (r3 !== null) {
              r4 = parse_hexDigit();
              if (r4 !== null) {
                r5 = parse_hexDigit();
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, h0, h1) { return String.fromCharCode(parseInt(h0 + h1, 16)); })(r1.offset, r1.line, r1.column, r4, r5);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              if (input.substr(pos.offset, 2) === "\\0") {
                r3 = "\\0";
                advance(pos, 2);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\0\"");
                }
              }
              if (r3 !== null) {
                r5 = clone(pos);
                reportFailures++;
                r4 = parse_decimalDigit();
                reportFailures--;
                if (r4 === null) {
                  r4 = "";
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
                if (r4 !== null) {
                  r0 = [r3, r4];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column) { return '\0'; })(r1.offset, r1.line, r1.column);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                r2 = clone(pos);
                if (input.substr(pos.offset, 2) === "\\0") {
                  r3 = "\\0";
                  advance(pos, 2);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\\0\"");
                  }
                }
                if (r3 !== null) {
                  r5 = clone(pos);
                  reportFailures++;
                  r4 = parse_decimalDigit();
                  reportFailures--;
                  if (r4 !== null) {
                    r4 = "";
                    pos = clone(r5);
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    r0 = [r3, r4];
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
                if (r0 !== null) {
                  r0 = (function(offset, line, column) { throw new SyntaxError(['string data'], 'octal escape sequence', offset, line, column); })(r1.offset, r1.line, r1.column);
                }
                if (r0 === null) {
                  pos = clone(r1);
                }
                if (r0 === null) {
                  r1 = clone(pos);
                  if (input.substr(pos.offset, 2) === "\\b") {
                    r0 = "\\b";
                    advance(pos, 2);
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\b\"");
                    }
                  }
                  if (r0 !== null) {
                    r0 = (function(offset, line, column) { return '\b'; })(r1.offset, r1.line, r1.column);
                  }
                  if (r0 === null) {
                    pos = clone(r1);
                  }
                  if (r0 === null) {
                    r1 = clone(pos);
                    if (input.substr(pos.offset, 2) === "\\t") {
                      r0 = "\\t";
                      advance(pos, 2);
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\\t\"");
                      }
                    }
                    if (r0 !== null) {
                      r0 = (function(offset, line, column) { return '\t'; })(r1.offset, r1.line, r1.column);
                    }
                    if (r0 === null) {
                      pos = clone(r1);
                    }
                    if (r0 === null) {
                      r1 = clone(pos);
                      if (input.substr(pos.offset, 2) === "\\n") {
                        r0 = "\\n";
                        advance(pos, 2);
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\\n\"");
                        }
                      }
                      if (r0 !== null) {
                        r0 = (function(offset, line, column) { return '\n'; })(r1.offset, r1.line, r1.column);
                      }
                      if (r0 === null) {
                        pos = clone(r1);
                      }
                      if (r0 === null) {
                        r1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "\\v") {
                          r0 = "\\v";
                          advance(pos, 2);
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\v\"");
                          }
                        }
                        if (r0 !== null) {
                          r0 = (function(offset, line, column) { return '\v'; })(r1.offset, r1.line, r1.column);
                        }
                        if (r0 === null) {
                          pos = clone(r1);
                        }
                        if (r0 === null) {
                          r1 = clone(pos);
                          if (input.substr(pos.offset, 2) === "\\f") {
                            r0 = "\\f";
                            advance(pos, 2);
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\\f\"");
                            }
                          }
                          if (r0 !== null) {
                            r0 = (function(offset, line, column) { return '\f'; })(r1.offset, r1.line, r1.column);
                          }
                          if (r0 === null) {
                            pos = clone(r1);
                          }
                          if (r0 === null) {
                            r1 = clone(pos);
                            if (input.substr(pos.offset, 2) === "\\r") {
                              r0 = "\\r";
                              advance(pos, 2);
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"\\\\r\"");
                              }
                            }
                            if (r0 !== null) {
                              r0 = (function(offset, line, column) { return '\r'; })(r1.offset, r1.line, r1.column);
                            }
                            if (r0 === null) {
                              pos = clone(r1);
                            }
                            if (r0 === null) {
                              r1 = clone(pos);
                              r2 = clone(pos);
                              if (input.charCodeAt(pos.offset) === 92) {
                                r3 = "\\";
                                advance(pos, 1);
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"\\\\\"");
                                }
                              }
                              if (r3 !== null) {
                                if (input.length > pos.offset) {
                                  r4 = input.charAt(pos.offset);
                                  advance(pos, 1);
                                } else {
                                  r4 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("any character");
                                  }
                                }
                                if (r4 !== null) {
                                  r0 = [r3, r4];
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r2);
                              }
                              if (r0 !== null) {
                                r0 = (function(offset, line, column, c) { return c; })(r1.offset, r1.line, r1.column, r4);
                              }
                              if (r0 === null) {
                                pos = clone(r1);
                              }
                              if (r0 === null) {
                                r1 = clone(pos);
                                r2 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 35) {
                                  r3 = "#";
                                  advance(pos, 1);
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"#\"");
                                  }
                                }
                                if (r3 !== null) {
                                  r5 = clone(pos);
                                  reportFailures++;
                                  if (input.charCodeAt(pos.offset) === 123) {
                                    r4 = "{";
                                    advance(pos, 1);
                                  } else {
                                    r4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"{\"");
                                    }
                                  }
                                  reportFailures--;
                                  if (r4 === null) {
                                    r4 = "";
                                  } else {
                                    r4 = null;
                                    pos = clone(r5);
                                  }
                                  if (r4 !== null) {
                                    r0 = [r3, r4];
                                  } else {
                                    r0 = null;
                                    pos = clone(r2);
                                  }
                                } else {
                                  r0 = null;
                                  pos = clone(r2);
                                }
                                if (r0 !== null) {
                                  r0 = (function(offset, line, column, c) { return c; })(r1.offset, r1.line, r1.column, r3);
                                }
                                if (r0 === null) {
                                  pos = clone(r1);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_interpolation() {
        var cacheKey = "interpolation@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "\"\"\"") {
          r3 = "\"\"\"";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\\\"\\\"\"");
          }
        }
        if (r3 !== null) {
          r6 = clone(pos);
          r7 = parse_stringData();
          if (r7 === null) {
            if (input.charCodeAt(pos.offset) === 39) {
              r7 = "'";
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (r7 === null) {
              r8 = clone(pos);
              r9 = clone(pos);
              if (input.charCodeAt(pos.offset) === 34) {
                r10 = "\"";
                advance(pos, 1);
              } else {
                r10 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r10 !== null) {
                if (input.charCodeAt(pos.offset) === 34) {
                  r11 = "\"";
                  advance(pos, 1);
                } else {
                  r11 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                r11 = r11 !== null ? r11 : "";
                if (r11 !== null) {
                  r13 = clone(pos);
                  reportFailures++;
                  if (input.charCodeAt(pos.offset) === 34) {
                    r12 = "\"";
                    advance(pos, 1);
                  } else {
                    r12 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  reportFailures--;
                  if (r12 === null) {
                    r12 = "";
                  } else {
                    r12 = null;
                    pos = clone(r13);
                  }
                  if (r12 !== null) {
                    r7 = [r10, r11, r12];
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                } else {
                  r7 = null;
                  pos = clone(r9);
                }
              } else {
                r7 = null;
                pos = clone(r9);
              }
              if (r7 !== null) {
                r7 = (function(offset, line, column, s) { return s.join(''); })(r8.offset, r8.line, r8.column, r7);
              }
              if (r7 === null) {
                pos = clone(r8);
              }
            }
          }
          if (r7 !== null) {
            r5 = [];
            while (r7 !== null) {
              r5.push(r7);
              r7 = parse_stringData();
              if (r7 === null) {
                if (input.charCodeAt(pos.offset) === 39) {
                  r7 = "'";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 34) {
                    r10 = "\"";
                    advance(pos, 1);
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r10 !== null) {
                    if (input.charCodeAt(pos.offset) === 34) {
                      r11 = "\"";
                      advance(pos, 1);
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r13 = clone(pos);
                      reportFailures++;
                      if (input.charCodeAt(pos.offset) === 34) {
                        r12 = "\"";
                        advance(pos, 1);
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r12 === null) {
                        r12 = "";
                      } else {
                        r12 = null;
                        pos = clone(r13);
                      }
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, s) { return s.join(''); })(r8.offset, r8.line, r8.column, r7);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
              }
            }
          } else {
            r5 = null;
          }
          if (r5 !== null) {
            r5 = (function(offset, line, column, d) { return new CS.String(d.join('')).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
          }
          if (r5 === null) {
            pos = clone(r6);
          }
          if (r5 === null) {
            r6 = clone(pos);
            r7 = clone(pos);
            if (input.substr(pos.offset, 2) === "#{") {
              r8 = "#{";
              advance(pos, 2);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"#{\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_expression();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    if (input.charCodeAt(pos.offset) === 125) {
                      r12 = "}";
                      advance(pos, 1);
                    } else {
                      r12 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"}\"");
                      }
                    }
                    if (r12 !== null) {
                      r5 = [r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                } else {
                  r5 = null;
                  pos = clone(r7);
                }
              } else {
                r5 = null;
                pos = clone(r7);
              }
            } else {
              r5 = null;
              pos = clone(r7);
            }
            if (r5 !== null) {
              r5 = (function(offset, line, column, e) { return e; })(r6.offset, r6.line, r6.column, r10);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = clone(pos);
              r7 = parse_stringData();
              if (r7 === null) {
                if (input.charCodeAt(pos.offset) === 39) {
                  r7 = "'";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r7 === null) {
                  r8 = clone(pos);
                  r9 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 34) {
                    r10 = "\"";
                    advance(pos, 1);
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r10 !== null) {
                    if (input.charCodeAt(pos.offset) === 34) {
                      r11 = "\"";
                      advance(pos, 1);
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r13 = clone(pos);
                      reportFailures++;
                      if (input.charCodeAt(pos.offset) === 34) {
                        r12 = "\"";
                        advance(pos, 1);
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r12 === null) {
                        r12 = "";
                      } else {
                        r12 = null;
                        pos = clone(r13);
                      }
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                    } else {
                      r7 = null;
                      pos = clone(r9);
                    }
                  } else {
                    r7 = null;
                    pos = clone(r9);
                  }
                  if (r7 !== null) {
                    r7 = (function(offset, line, column, s) { return s.join(''); })(r8.offset, r8.line, r8.column, r7);
                  }
                  if (r7 === null) {
                    pos = clone(r8);
                  }
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  r7 = parse_stringData();
                  if (r7 === null) {
                    if (input.charCodeAt(pos.offset) === 39) {
                      r7 = "'";
                      advance(pos, 1);
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (r7 === null) {
                      r8 = clone(pos);
                      r9 = clone(pos);
                      if (input.charCodeAt(pos.offset) === 34) {
                        r10 = "\"";
                        advance(pos, 1);
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      if (r10 !== null) {
                        if (input.charCodeAt(pos.offset) === 34) {
                          r11 = "\"";
                          advance(pos, 1);
                        } else {
                          r11 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\"\"");
                          }
                        }
                        r11 = r11 !== null ? r11 : "";
                        if (r11 !== null) {
                          r13 = clone(pos);
                          reportFailures++;
                          if (input.charCodeAt(pos.offset) === 34) {
                            r12 = "\"";
                            advance(pos, 1);
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\"\"");
                            }
                          }
                          reportFailures--;
                          if (r12 === null) {
                            r12 = "";
                          } else {
                            r12 = null;
                            pos = clone(r13);
                          }
                          if (r12 !== null) {
                            r7 = [r10, r11, r12];
                          } else {
                            r7 = null;
                            pos = clone(r9);
                          }
                        } else {
                          r7 = null;
                          pos = clone(r9);
                        }
                      } else {
                        r7 = null;
                        pos = clone(r9);
                      }
                      if (r7 !== null) {
                        r7 = (function(offset, line, column, s) { return s.join(''); })(r8.offset, r8.line, r8.column, r7);
                      }
                      if (r7 === null) {
                        pos = clone(r8);
                      }
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column, d) { return new CS.String(d.join('')).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
              if (r5 === null) {
                r6 = clone(pos);
                r7 = clone(pos);
                if (input.substr(pos.offset, 2) === "#{") {
                  r8 = "#{";
                  advance(pos, 2);
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#{\"");
                  }
                }
                if (r8 !== null) {
                  r9 = parse__();
                  if (r9 !== null) {
                    r10 = parse_expression();
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        if (input.charCodeAt(pos.offset) === 125) {
                          r12 = "}";
                          advance(pos, 1);
                        } else {
                          r12 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"}\"");
                          }
                        }
                        if (r12 !== null) {
                          r5 = [r8, r9, r10, r11, r12];
                        } else {
                          r5 = null;
                          pos = clone(r7);
                        }
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                } else {
                  r5 = null;
                  pos = clone(r7);
                }
                if (r5 !== null) {
                  r5 = (function(offset, line, column, e) { return e; })(r6.offset, r6.line, r6.column, r10);
                }
                if (r5 === null) {
                  pos = clone(r6);
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos.offset, 3) === "\"\"\"") {
              r5 = "\"\"\"";
              advance(pos, 3);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\\\"\\\"\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, es) {
              return createInterpolation(es).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 34) {
            r3 = "\"";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (r3 !== null) {
            r6 = clone(pos);
            r7 = parse_stringData();
            if (r7 === null) {
              if (input.charCodeAt(pos.offset) === 39) {
                r7 = "'";
                advance(pos, 1);
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
            }
            if (r7 !== null) {
              r5 = [];
              while (r7 !== null) {
                r5.push(r7);
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos.offset) === 39) {
                    r7 = "'";
                    advance(pos, 1);
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
              }
            } else {
              r5 = null;
            }
            if (r5 !== null) {
              r5 = (function(offset, line, column, d) { return new CS.String(d.join('')).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
            if (r5 === null) {
              r6 = clone(pos);
              r7 = clone(pos);
              if (input.substr(pos.offset, 2) === "#{") {
                r8 = "#{";
                advance(pos, 2);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#{\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_expression();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      if (input.charCodeAt(pos.offset) === 125) {
                        r12 = "}";
                        advance(pos, 1);
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"}\"");
                        }
                      }
                      if (r12 !== null) {
                        r5 = [r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                } else {
                  r5 = null;
                  pos = clone(r7);
                }
              } else {
                r5 = null;
                pos = clone(r7);
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column, e) { return e; })(r6.offset, r6.line, r6.column, r10);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
            }
            if (r5 !== null) {
              r4 = [];
              while (r5 !== null) {
                r4.push(r5);
                r6 = clone(pos);
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos.offset) === 39) {
                    r7 = "'";
                    advance(pos, 1);
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos.offset) === 39) {
                        r7 = "'";
                        advance(pos, 1);
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  r5 = (function(offset, line, column, d) { return new CS.String(d.join('')).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
                }
                if (r5 === null) {
                  pos = clone(r6);
                }
                if (r5 === null) {
                  r6 = clone(pos);
                  r7 = clone(pos);
                  if (input.substr(pos.offset, 2) === "#{") {
                    r8 = "#{";
                    advance(pos, 2);
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#{\"");
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_expression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos.offset) === 125) {
                            r12 = "}";
                            advance(pos, 1);
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"}\"");
                            }
                          }
                          if (r12 !== null) {
                            r5 = [r8, r9, r10, r11, r12];
                          } else {
                            r5 = null;
                            pos = clone(r7);
                          }
                        } else {
                          r5 = null;
                          pos = clone(r7);
                        }
                      } else {
                        r5 = null;
                        pos = clone(r7);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r7);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r7);
                  }
                  if (r5 !== null) {
                    r5 = (function(offset, line, column, e) { return e; })(r6.offset, r6.line, r6.column, r10);
                  }
                  if (r5 === null) {
                    pos = clone(r6);
                  }
                }
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              if (input.charCodeAt(pos.offset) === 34) {
                r5 = "\"";
                advance(pos, 1);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, es) {
                return createInterpolation(es).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_regexp() {
        var cacheKey = "regexp@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "///") {
          r3 = "///";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"///\"");
          }
        }
        if (r3 !== null) {
          r6 = clone(pos);
          if (/^[ \r\n]/.test(input.charAt(pos.offset))) {
            r7 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("[ \\r\\n]");
            }
          }
          if (r7 !== null) {
            r5 = [];
            while (r7 !== null) {
              r5.push(r7);
              if (/^[ \r\n]/.test(input.charAt(pos.offset))) {
                r7 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[ \\r\\n]");
                }
              }
            }
          } else {
            r5 = null;
          }
          if (r5 !== null) {
            r5 = (function(offset, line, column) { return [new CS.String('').g().p(line, column, offset)]; })(r6.offset, r6.line, r6.column);
          }
          if (r5 === null) {
            pos = clone(r6);
          }
          if (r5 === null) {
            r6 = clone(pos);
            if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos.offset))) {
              r7 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\/#[ \\r\\n]");
              }
            }
            if (r7 !== null) {
              r5 = [];
              while (r7 !== null) {
                r5.push(r7);
                if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos.offset))) {
                  r7 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\\\\\/#[ \\r\\n]");
                  }
                }
              }
            } else {
              r5 = null;
            }
            if (r5 !== null) {
              r5 = (function(offset, line, column, s) { return [new CS.String(s.join('')).g().p(line, column, offset)]; })(r6.offset, r6.line, r6.column, r5);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
            if (r5 === null) {
              r5 = parse_hereregexpData();
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = clone(pos);
              if (/^[ \r\n]/.test(input.charAt(pos.offset))) {
                r7 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[ \\r\\n]");
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  if (/^[ \r\n]/.test(input.charAt(pos.offset))) {
                    r7 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[ \\r\\n]");
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column) { return [new CS.String('').g().p(line, column, offset)]; })(r6.offset, r6.line, r6.column);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
              if (r5 === null) {
                r6 = clone(pos);
                if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos.offset))) {
                  r7 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\\\\\/#[ \\r\\n]");
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos.offset))) {
                      r7 = input.charAt(pos.offset);
                      advance(pos, 1);
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\\\\\/#[ \\r\\n]");
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  r5 = (function(offset, line, column, s) { return [new CS.String(s.join('')).g().p(line, column, offset)]; })(r6.offset, r6.line, r6.column, r5);
                }
                if (r5 === null) {
                  pos = clone(r6);
                }
                if (r5 === null) {
                  r5 = parse_hereregexpData();
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos.offset, 3) === "///") {
              r5 = "///";
              advance(pos, 3);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"///\"");
              }
            }
            if (r5 !== null) {
              r6 = [];
              if (/^[gimy]/.test(input.charAt(pos.offset))) {
                r7 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[gimy]");
                }
              }
              while (r7 !== null) {
                r6.push(r7);
                if (/^[gimy]/.test(input.charAt(pos.offset))) {
                  r7 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[gimy]");
                  }
                }
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, es, flags) {
              if(!isValidRegExpFlags(flags))
                throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset, line, column);
              if(!flags) flags = [];
              var interp = createInterpolation(foldl(function(memo, e){ return memo.concat(e); }, [], es));
              if(interp instanceof CS.String) return new CS.RegExp(interp.data, flags).p(line, column, offset);
              return new CS.HeregExp(interp, flags).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 47) {
            r3 = "/";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (r3 !== null) {
            r4 = [];
            r5 = parse_regexpData();
            if (r5 === null) {
              r6 = clone(pos);
              if (/^[^\/\\[\n]/.test(input.charAt(pos.offset))) {
                r7 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\/\\\\[\\n]");
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  if (/^[^\/\\[\n]/.test(input.charAt(pos.offset))) {
                    r7 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^\\/\\\\[\\n]");
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column, d) { return d.join(''); })(r6.offset, r6.line, r6.column, r5);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
            }
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_regexpData();
              if (r5 === null) {
                r6 = clone(pos);
                if (/^[^\/\\[\n]/.test(input.charAt(pos.offset))) {
                  r7 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\/\\\\[\\n]");
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[^\/\\[\n]/.test(input.charAt(pos.offset))) {
                      r7 = input.charAt(pos.offset);
                      advance(pos, 1);
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\/\\\\[\\n]");
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  r5 = (function(offset, line, column, d) { return d.join(''); })(r6.offset, r6.line, r6.column, r5);
                }
                if (r5 === null) {
                  pos = clone(r6);
                }
              }
            }
            if (r4 !== null) {
              if (input.charCodeAt(pos.offset) === 47) {
                r5 = "/";
                advance(pos, 1);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
              if (r5 !== null) {
                r6 = [];
                if (/^[gimy]/.test(input.charAt(pos.offset))) {
                  r7 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[gimy]");
                  }
                }
                while (r7 !== null) {
                  r6.push(r7);
                  if (/^[gimy]/.test(input.charAt(pos.offset))) {
                    r7 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[gimy]");
                    }
                  }
                }
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, d, flags) {
                if(!isValidRegExpFlags(flags))
                  throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset, line, column);
                return new CS.RegExp(d ? d.join('') : '', flags || []).p(line, column, offset);;
              })(r1.offset, r1.line, r1.column, r4, r6);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_regexpData() {
        var cacheKey = "regexpData@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          r3 = "[";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          if (/^[^\\\]\n]/.test(input.charAt(pos.offset))) {
            r5 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r5 = null;
            if (reportFailures === 0) {
              matchFailed("[^\\\\\\]\\n]");
            }
          }
          if (r5 === null) {
            r5 = parse_regexpData();
          }
          while (r5 !== null) {
            r4.push(r5);
            if (/^[^\\\]\n]/.test(input.charAt(pos.offset))) {
              r5 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\]\\n]");
              }
            }
            if (r5 === null) {
              r5 = parse_regexpData();
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 93) {
              r5 = "]";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, d) { return "[" + d.join('') + "]"; })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 92) {
            r3 = "\\";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (r3 !== null) {
            if (input.length > pos.offset) {
              r4 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, c) { return '\\' + c; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_hereregexpData() {
        var cacheKey = "hereregexpData@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          r3 = "[";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r5 = parse_hereregexpData();
          if (r5 !== null) {
            r5 = (function(offset, line, column, h) { return h[0]; })(r6.offset, r6.line, r6.column, r5);
          }
          if (r5 === null) {
            pos = clone(r6);
          }
          if (r5 === null) {
            r6 = clone(pos);
            if (/^[^\\\/\]]/.test(input.charAt(pos.offset))) {
              r5 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\/\\]]");
              }
            }
            if (r5 !== null) {
              r5 = (function(offset, line, column, s) { return new CS.String(s).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r5 = parse_hereregexpData();
            if (r5 !== null) {
              r5 = (function(offset, line, column, h) { return h[0]; })(r6.offset, r6.line, r6.column, r5);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
            if (r5 === null) {
              r6 = clone(pos);
              if (/^[^\\\/\]]/.test(input.charAt(pos.offset))) {
                r5 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\\\\\/\\]]");
                }
              }
              if (r5 !== null) {
                r5 = (function(offset, line, column, s) { return new CS.String(s).p(line, column, offset); })(r6.offset, r6.line, r6.column, r5);
              }
              if (r5 === null) {
                pos = clone(r6);
              }
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 93) {
              r5 = "]";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, d) {
                return [new CS.String("[").p(line, column, offset)].concat(d || []).concat([new CS.String("]").p(line, column, offset)]);
              })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 92) {
            r3 = "\\";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (r3 !== null) {
            if (input.length > pos.offset) {
              r4 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, c) { return [new CS.String('\\' + c).p(line, column, offset)]; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            if (input.charCodeAt(pos.offset) === 47) {
              r3 = "/";
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (r3 !== null) {
              if (input.charCodeAt(pos.offset) === 47) {
                r4 = "/";
                advance(pos, 1);
              } else {
                r4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
              r4 = r4 !== null ? r4 : "";
              if (r4 !== null) {
                r6 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 47) {
                  r5 = "/";
                  advance(pos, 1);
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"/\"");
                  }
                }
                reportFailures--;
                if (r5 === null) {
                  r5 = "";
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, s) { return [new CS.String(s.join('')).p(line, column, offset)]; })(r1.offset, r1.line, r1.column, r0);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              r2 = clone(pos);
              if (input.charCodeAt(pos.offset) === 35) {
                r3 = "#";
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#\"");
                }
              }
              if (r3 !== null) {
                r5 = clone(pos);
                reportFailures++;
                if (input.charCodeAt(pos.offset) === 123) {
                  r4 = "{";
                  advance(pos, 1);
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"{\"");
                  }
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = "";
                } else {
                  r4 = null;
                  pos = clone(r5);
                }
                if (r4 !== null) {
                  r0 = [r3, r4];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
              if (r0 !== null) {
                r0 = (function(offset, line, column, c) { return [new CS.String(c).p(line, column, offset)]; })(r1.offset, r1.line, r1.column, r3);
              }
              if (r0 === null) {
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                r2 = clone(pos);
                if (input.substr(pos.offset, 2) === "#{") {
                  r3 = "#{";
                  advance(pos, 2);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#{\"");
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_expression();
                    if (r5 !== null) {
                      r6 = parse__();
                      if (r6 !== null) {
                        if (input.charCodeAt(pos.offset) === 125) {
                          r7 = "}";
                          advance(pos, 1);
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"}\"");
                          }
                        }
                        if (r7 !== null) {
                          r0 = [r3, r4, r5, r6, r7];
                        } else {
                          r0 = null;
                          pos = clone(r2);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r2);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r2);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r2);
                  }
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
                if (r0 !== null) {
                  r0 = (function(offset, line, column, e) { return [e]; })(r1.offset, r1.line, r1.column, r5);
                }
                if (r0 === null) {
                  pos = clone(r1);
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_throw() {
        var cacheKey = "throw@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_THROW();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_secondaryExpression();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, e) {
              return new CS.Throw(e).r('throw' + ws + e.raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_return() {
        var cacheKey = "return@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_RETURN();
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse___();
          if (r6 !== null) {
            r7 = parse_secondaryExpression();
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, maybeExpression) {
              var ws = maybeExpression ? maybeExpression[0] : '',
                  e = maybeExpression ? maybeExpression[1] : null;
              return new CS.Return(e).r('return' + ws + (e ? e.raw : '')).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_continue() {
        var cacheKey = "continue@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_CONTINUE();
        if (r0 !== null) {
          r0 = (function(offset, line, column) { return (new CS.Continue).r('continue').p(line, column, offset); })(r1.offset, r1.line, r1.column);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_break() {
        var cacheKey = "break@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_BREAK();
        if (r0 !== null) {
          r0 = (function(offset, line, column) { return (new CS.Break).r('break').p(line, column, offset); })(r1.offset, r1.line, r1.column);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_undefined() {
        var cacheKey = "undefined@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_UNDEFINED();
        if (r0 !== null) {
          r0 = (function(offset, line, column) { return (new CS.Undefined).r('undefined').p(line, column, offset); })(r1.offset, r1.line, r1.column);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_null() {
        var cacheKey = "null@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = clone(pos);
        r0 = parse_NULL();
        if (r0 !== null) {
          r0 = (function(offset, line, column) { return (new CS.Null).r('null').p(line, column, offset); })(r1.offset, r1.line, r1.column);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_unassignable() {
        var cacheKey = "unassignable@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 9) === "arguments") {
          r2 = "arguments";
          advance(pos, 9);
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"arguments\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos.offset, 4) === "eval") {
            r2 = "eval";
            advance(pos, 4);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"eval\"");
            }
          }
        }
        if (r2 !== null) {
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CompoundAssignable() {
        var cacheKey = "CompoundAssignable@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r0 = parse_memberAccess();
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_unassignable();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r4 = parse_identifier();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, i) { return i; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r0 = parse_contextVar();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_Assignable() {
        var cacheKey = "Assignable@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r0 = parse_memberAccess();
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_unassignable();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r4 = parse_identifier();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, i) { return i; })(r1.offset, r1.line, r1.column, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r0 = parse_contextVar();
            if (r0 === null) {
              r0 = parse_positionalDestructuring();
              if (r0 === null) {
                r0 = parse_namedDestructuring();
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuring() {
        var cacheKey = "positionalDestructuring@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 91) {
          r3 = "[";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_positionalDestructuringBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos.offset) === 93) {
                  r7 = "]";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, members, t, ws) {
              var raw = '{' + members.raw + t + ws + '}'
              return new CS.ArrayInitialiser(members.list).r(raw).p(line, column, offset);
            })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringBody() {
        var cacheKey = "positionalDestructuringBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_positionalDestructuringMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, members, d) { return {list: members.list, raw: t + members.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_positionalDestructuringMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, members) { return {list: members ? members.list : [], raw: ws + members ? members.raw : ''}; })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringMemberList() {
        var cacheKey = "positionalDestructuringMemberList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_positionalDestructuringMember();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos.offset) === 44) {
              r8 = ",";
              advance(pos, 1);
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_positionalDestructuringMember();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos.offset) === 44) {
                r8 = ",";
                advance(pos, 1);
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_positionalDestructuringMember();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, es) {
                var raw = e.raw + es.map(function(e){ return e[0] + e[1] + e[2] + e[3].raw; }).join('');
                return {list: [e].concat(es.map(function(e){ return e[3]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringMember() {
        var cacheKey = "positionalDestructuringMember@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_rest();
        if (r0 === null) {
          r0 = parse_Assignable();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuring() {
        var cacheKey = "namedDestructuring@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 123) {
          r3 = "{";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_namedDestructuringBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos.offset) === 125) {
                  r7 = "}";
                  advance(pos, 1);
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"}\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, members, t, ws) {
            var raw = '{' + members.raw + t + ws + '}'
            return new CS.ObjectInitialiser(members.list).r(raw).p(line, column, offset);
          })(r1.offset, r1.line, r1.column, r4, r5, r6);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringBody() {
        var cacheKey = "namedDestructuringBody@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_namedDestructuringMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, members, d) { return {list: members.list, raw: t + members.raw + d}; })(r1.offset, r1.line, r1.column, r3, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_namedDestructuringMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column, ws, members) { return {list: members ? members.list : [], raw: ws + members ? members.raw : ''}; })(r1.offset, r1.line, r1.column, r3, r4);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringMemberList() {
        var cacheKey = "namedDestructuringMemberList@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_namedDestructuringMember();
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = parse_TERMINATOR();
          r7 = r7 !== null ? r7 : "";
          if (r7 !== null) {
            r8 = parse__();
            if (r8 !== null) {
              if (input.charCodeAt(pos.offset) === 44) {
                r9 = ",";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r9 === null) {
                r9 = parse_TERMINATOR();
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_namedDestructuringMember();
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          } else {
            r5 = null;
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = parse_TERMINATOR();
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                if (input.charCodeAt(pos.offset) === 44) {
                  r9 = ",";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r9 === null) {
                  r9 = parse_TERMINATOR();
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_namedDestructuringMember();
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = clone(r6);
                      }
                    } else {
                      r5 = null;
                      pos = clone(r6);
                    }
                  } else {
                    r5 = null;
                    pos = clone(r6);
                  }
                } else {
                  r5 = null;
                  pos = clone(r6);
                }
              } else {
                r5 = null;
                pos = clone(r6);
              }
            } else {
              r5 = null;
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, e, es) {
                var raw = e.raw + es.map(function(e){ return e[0] + e[1] + e[2] + e[3] + e[4] + e[5].raw; }).join('');
                return {list: [e].concat(es.map(function(e){ return e[5]; })), raw: raw};
              })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringMember() {
        var cacheKey = "namedDestructuringMember@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 58) {
              r5 = ":";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_Assignable();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, key, ws0, ws1, val) {
                var raw = key.raw + ws0 + ':' + ws1 + val.raw;
                return new CS.ObjectInitialiserMember(key, val).r(raw).p(line, column, offset);
              })(r1.offset, r1.line, r1.column, r3, r4, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          r0 = parse_contextVar();
          if (r0 !== null) {
            r0 = (function(offset, line, column, v) {
                  var key = new CS.String(v.memberName).r(v.memberName).p(line, column + 1)
                  return new CS.ObjectInitialiserMember(key, v).r(v.raw).p(line, column, offset);
                })(r1.offset, r1.line, r1.column, r0);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            r2 = clone(pos);
            r4 = clone(pos);
            reportFailures++;
            r3 = parse_unassignable();
            reportFailures--;
            if (r3 === null) {
              r3 = "";
            } else {
              r3 = null;
              pos = clone(r4);
            }
            if (r3 !== null) {
              r4 = parse_identifier();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
            if (r0 !== null) {
              r0 = (function(offset, line, column, i) {
                    return new CS.ObjectInitialiserMember(i, i).r(i.raw).p(line, column, offset);
                  })(r1.offset, r1.line, r1.column, r4);
            }
            if (r0 === null) {
              pos = clone(r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_identifier() {
        var cacheKey = "identifier@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r4 = clone(pos);
        reportFailures++;
        r3 = parse_reserved();
        reportFailures--;
        if (r3 === null) {
          r3 = "";
        } else {
          r3 = null;
          pos = clone(r4);
        }
        if (r3 !== null) {
          r4 = parse_identifierName();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, i) { return new CS.Identifier(i).r(i).p(line, column, offset); })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierName() {
        var cacheKey = "identifierName@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_identifierStart();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_identifierPart();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_identifierPart();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, c, cs) { return c + cs.join(''); })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierStart() {
        var cacheKey = "identifierStart@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_UnicodeLetter();
        if (r0 === null) {
          if (/^[$_]/.test(input.charAt(pos.offset))) {
            r0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("[$_]");
            }
          }
          if (r0 === null) {
            r0 = parse_UnicodeEscapeSequence();
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierPart() {
        var cacheKey = "identifierPart@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_identifierStart();
        if (r0 === null) {
          r0 = parse_UnicodeCombiningMark();
          if (r0 === null) {
            r0 = parse_UnicodeDigit();
            if (r0 === null) {
              r0 = parse_UnicodeConnectorPunctuation();
              if (r0 === null) {
                r0 = parse_ZWNJ();
                if (r0 === null) {
                  r0 = parse_ZWJ();
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse___() {
        var cacheKey = "__@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r4 = parse_whitespace();
        if (r4 !== null) {
          r3 = [];
          while (r4 !== null) {
            r3.push(r4);
            r4 = parse_whitespace();
          }
        } else {
          r3 = null;
        }
        if (r3 !== null) {
          r5 = clone(pos);
          r6 = parse_blockComment();
          if (r6 !== null) {
            r8 = parse_whitespace();
            if (r8 !== null) {
              r7 = [];
              while (r8 !== null) {
                r7.push(r8);
                r8 = parse_whitespace();
              }
            } else {
              r7 = null;
            }
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = clone(r5);
            }
          } else {
            r4 = null;
            pos = clone(r5);
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws, c) { return ws.join('') + (c && c[0] + c[1].join('')); })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse__() {
        var cacheKey = "_@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse___();
        r0 = r0 !== null ? r0 : "";
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_comment() {
        var cacheKey = "comment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_blockComment();
        if (r0 === null) {
          r0 = parse_singleLineComment();
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_singleLineComment() {
        var cacheKey = "singleLineComment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 35) {
          r3 = "#";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"#\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          r6 = clone(pos);
          r7 = clone(pos);
          r9 = clone(pos);
          reportFailures++;
          r8 = parse_TERM();
          reportFailures--;
          if (r8 === null) {
            r8 = "";
          } else {
            r8 = null;
            pos = clone(r9);
          }
          if (r8 !== null) {
            if (input.length > pos.offset) {
              r9 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r9 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r9 !== null) {
              r5 = [r8, r9];
            } else {
              r5 = null;
              pos = clone(r7);
            }
          } else {
            r5 = null;
            pos = clone(r7);
          }
          if (r5 !== null) {
            r5 = (function(offset, line, column, c) { return c})(r6.offset, r6.line, r6.column, r9);
          }
          if (r5 === null) {
            pos = clone(r6);
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = clone(pos);
            r7 = clone(pos);
            r9 = clone(pos);
            reportFailures++;
            r8 = parse_TERM();
            reportFailures--;
            if (r8 === null) {
              r8 = "";
            } else {
              r8 = null;
              pos = clone(r9);
            }
            if (r8 !== null) {
              if (input.length > pos.offset) {
                r9 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (r9 !== null) {
                r5 = [r8, r9];
              } else {
                r5 = null;
                pos = clone(r7);
              }
            } else {
              r5 = null;
              pos = clone(r7);
            }
            if (r5 !== null) {
              r5 = (function(offset, line, column, c) { return c})(r6.offset, r6.line, r6.column, r9);
            }
            if (r5 === null) {
              pos = clone(r6);
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, cs) { return '#' + (cs && cs.join('')); })(r1.offset, r1.line, r1.column, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_blockComment() {
        var cacheKey = "blockComment@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "###") {
          r3 = "###";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"###\"");
          }
        }
        if (r3 !== null) {
          if (/^[^#]/.test(input.charAt(pos.offset))) {
            r4 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("[^#]");
            }
          }
          if (r4 !== null) {
            r5 = [];
            if (/^[^#]/.test(input.charAt(pos.offset))) {
              r6 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r6 = null;
              if (reportFailures === 0) {
                matchFailed("[^#]");
              }
            }
            if (r6 === null) {
              r7 = clone(pos);
              r8 = clone(pos);
              if (input.charCodeAt(pos.offset) === 35) {
                r9 = "#";
                advance(pos, 1);
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#\"");
                }
              }
              if (r9 !== null) {
                if (input.charCodeAt(pos.offset) === 35) {
                  r10 = "#";
                  advance(pos, 1);
                } else {
                  r10 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r12 = clone(pos);
                  reportFailures++;
                  if (input.charCodeAt(pos.offset) === 35) {
                    r11 = "#";
                    advance(pos, 1);
                  } else {
                    r11 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#\"");
                    }
                  }
                  reportFailures--;
                  if (r11 === null) {
                    r11 = "";
                  } else {
                    r11 = null;
                    pos = clone(r12);
                  }
                  if (r11 !== null) {
                    r6 = [r9, r10, r11];
                  } else {
                    r6 = null;
                    pos = clone(r8);
                  }
                } else {
                  r6 = null;
                  pos = clone(r8);
                }
              } else {
                r6 = null;
                pos = clone(r8);
              }
              if (r6 !== null) {
                r6 = (function(offset, line, column, a, b) {return a + b;})(r7.offset, r7.line, r7.column, r9, r10);
              }
              if (r6 === null) {
                pos = clone(r7);
              }
            }
            while (r6 !== null) {
              r5.push(r6);
              if (/^[^#]/.test(input.charAt(pos.offset))) {
                r6 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("[^#]");
                }
              }
              if (r6 === null) {
                r7 = clone(pos);
                r8 = clone(pos);
                if (input.charCodeAt(pos.offset) === 35) {
                  r9 = "#";
                  advance(pos, 1);
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                if (r9 !== null) {
                  if (input.charCodeAt(pos.offset) === 35) {
                    r10 = "#";
                    advance(pos, 1);
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#\"");
                    }
                  }
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r12 = clone(pos);
                    reportFailures++;
                    if (input.charCodeAt(pos.offset) === 35) {
                      r11 = "#";
                      advance(pos, 1);
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                    reportFailures--;
                    if (r11 === null) {
                      r11 = "";
                    } else {
                      r11 = null;
                      pos = clone(r12);
                    }
                    if (r11 !== null) {
                      r6 = [r9, r10, r11];
                    } else {
                      r6 = null;
                      pos = clone(r8);
                    }
                  } else {
                    r6 = null;
                    pos = clone(r8);
                  }
                } else {
                  r6 = null;
                  pos = clone(r8);
                }
                if (r6 !== null) {
                  r6 = (function(offset, line, column, a, b) {return a + b;})(r7.offset, r7.line, r7.column, r9, r10);
                }
                if (r6 === null) {
                  pos = clone(r7);
                }
              }
            }
            if (r5 !== null) {
              if (input.substr(pos.offset, 3) === "###") {
                r6 = "###";
                advance(pos, 3);
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"###\"");
                }
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, c, cs) { return '###' + c + cs.join('') + '###'; })(r1.offset, r1.line, r1.column, r4, r5);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_whitespace() {
        var cacheKey = "whitespace@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        if (/^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]");
          }
        }
        if (r0 === null) {
          r1 = clone(pos);
          r2 = clone(pos);
          if (input.charCodeAt(pos.offset) === 92) {
            r3 = "\\";
            advance(pos, 1);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (r3 !== null) {
            if (input.charCodeAt(pos.offset) === 13) {
              r4 = "\r";
              advance(pos, 1);
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              if (input.charCodeAt(pos.offset) === 10) {
                r5 = "\n";
                advance(pos, 1);
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\n\"");
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column) { return ''; })(r1.offset, r1.line, r1.column);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_INDENT() {
        var cacheKey = "INDENT@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse___();
        if (r3 !== null) {
          if (input.charCodeAt(pos.offset) === 61423) {
            r4 = "\uEFEF";
            advance(pos, 1);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uEFEF\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws) { return ws; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_DEDENT() {
        var cacheKey = "DEDENT@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos.offset) === 61438) {
              r5 = "\uEFFE";
              advance(pos, 1);
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uEFFE\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, ws) { return t + ws; })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TERM() {
        var cacheKey = "TERM@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.charCodeAt(pos.offset) === 13) {
          r3 = "\r";
          advance(pos, 1);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\"");
          }
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.charCodeAt(pos.offset) === 10) {
            r4 = "\n";
            advance(pos, 1);
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\n\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column) { return '\n'; })(r1.offset, r1.line, r1.column);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 61439) {
            r0 = "\uEFFF";
            advance(pos, 1);
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uEFFF\"");
            }
          }
          if (r0 !== null) {
            r0 = (function(offset, line, column) { return ''; })(r1.offset, r1.line, r1.column);
          }
          if (r0 === null) {
            pos = clone(r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TERMINATOR() {
        var cacheKey = "TERMINATOR@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r3 = clone(pos);
        r4 = parse__();
        if (r4 !== null) {
          r5 = parse_comment();
          r5 = r5 !== null ? r5 : "";
          if (r5 !== null) {
            r6 = parse_TERM();
            if (r6 !== null) {
              r7 = parse_blockComment();
              r7 = r7 !== null ? r7 : "";
              if (r7 !== null) {
                r2 = [r4, r5, r6, r7];
              } else {
                r2 = null;
                pos = clone(r3);
              }
            } else {
              r2 = null;
              pos = clone(r3);
            }
          } else {
            r2 = null;
            pos = clone(r3);
          }
        } else {
          r2 = null;
          pos = clone(r3);
        }
        if (r2 !== null) {
          r0 = [];
          while (r2 !== null) {
            r0.push(r2);
            r3 = clone(pos);
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_comment();
              r5 = r5 !== null ? r5 : "";
              if (r5 !== null) {
                r6 = parse_TERM();
                if (r6 !== null) {
                  r7 = parse_blockComment();
                  r7 = r7 !== null ? r7 : "";
                  if (r7 !== null) {
                    r2 = [r4, r5, r6, r7];
                  } else {
                    r2 = null;
                    pos = clone(r3);
                  }
                } else {
                  r2 = null;
                  pos = clone(r3);
                }
              } else {
                r2 = null;
                pos = clone(r3);
              }
            } else {
              r2 = null;
              pos = clone(r3);
            }
          }
        } else {
          r0 = null;
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, ws) {
            return ws.map(function(s){ return s.join(''); }).join('');
          })(r1.offset, r1.line, r1.column, r0);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TERMINDENT() {
        var cacheKey = "TERMINDENT@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        r2 = clone(pos);
        r3 = parse_TERMINATOR();
        if (r3 !== null) {
          r4 = parse_INDENT();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, t, i) {
            return t + i;
          })(r1.offset, r1.line, r1.column, r3, r4);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_AND() {
        var cacheKey = "AND@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "and") {
          r3 = "and";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"and\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_BREAK() {
        var cacheKey = "BREAK@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "break") {
          r3 = "break";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"break\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_BY() {
        var cacheKey = "BY@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "by") {
          r3 = "by";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"by\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CATCH() {
        var cacheKey = "CATCH@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "catch") {
          r3 = "catch";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"catch\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CONTINUE() {
        var cacheKey = "CONTINUE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 8) === "continue") {
          r3 = "continue";
          advance(pos, 8);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"continue\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CLASS() {
        var cacheKey = "CLASS@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "class") {
          r3 = "class";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"class\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_DELETE() {
        var cacheKey = "DELETE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 6) === "delete") {
          r3 = "delete";
          advance(pos, 6);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"delete\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_DO() {
        var cacheKey = "DO@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "do") {
          r3 = "do";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"do\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ELSE() {
        var cacheKey = "ELSE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "else") {
          r3 = "else";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"else\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_EXTENDS() {
        var cacheKey = "EXTENDS@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 7) === "extends") {
          r3 = "extends";
          advance(pos, 7);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"extends\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_FALSE() {
        var cacheKey = "FALSE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "false") {
          r3 = "false";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"false\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_FINALLY() {
        var cacheKey = "FINALLY@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 7) === "finally") {
          r3 = "finally";
          advance(pos, 7);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"finally\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_FOR() {
        var cacheKey = "FOR@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "for") {
          r3 = "for";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"for\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_IF() {
        var cacheKey = "IF@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "if") {
          r3 = "if";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"if\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_IN() {
        var cacheKey = "IN@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "in") {
          r3 = "in";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"in\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_INSTANCEOF() {
        var cacheKey = "INSTANCEOF@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 10) === "instanceof") {
          r3 = "instanceof";
          advance(pos, 10);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"instanceof\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_IS() {
        var cacheKey = "IS@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "is") {
          r3 = "is";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"is\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ISNT() {
        var cacheKey = "ISNT@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "isnt") {
          r3 = "isnt";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"isnt\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_LOOP() {
        var cacheKey = "LOOP@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "loop") {
          r3 = "loop";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"loop\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_NEW() {
        var cacheKey = "NEW@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "new") {
          r3 = "new";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"new\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_NO() {
        var cacheKey = "NO@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "no") {
          r3 = "no";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"no\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_NOT() {
        var cacheKey = "NOT@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "not") {
          r3 = "not";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"not\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_NULL() {
        var cacheKey = "NULL@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "null") {
          r3 = "null";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"null\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_OF() {
        var cacheKey = "OF@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "of") {
          r3 = "of";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"of\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_OFF() {
        var cacheKey = "OFF@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "off") {
          r3 = "off";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"off\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ON() {
        var cacheKey = "ON@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "on") {
          r3 = "on";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"on\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_OR() {
        var cacheKey = "OR@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "or") {
          r3 = "or";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"or\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_OWN() {
        var cacheKey = "OWN@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "own") {
          r3 = "own";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"own\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_RETURN() {
        var cacheKey = "RETURN@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 6) === "return") {
          r3 = "return";
          advance(pos, 6);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"return\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_SWITCH() {
        var cacheKey = "SWITCH@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 6) === "switch") {
          r3 = "switch";
          advance(pos, 6);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"switch\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_SUPER() {
        var cacheKey = "SUPER@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "super") {
          r3 = "super";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"super\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_THEN() {
        var cacheKey = "THEN@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "then") {
          r3 = "then";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"then\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_THIS() {
        var cacheKey = "THIS@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "this") {
          r3 = "this";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"this\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_THROW() {
        var cacheKey = "THROW@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "throw") {
          r3 = "throw";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"throw\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TRUE() {
        var cacheKey = "TRUE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "true") {
          r3 = "true";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"true\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TRY() {
        var cacheKey = "TRY@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "try") {
          r3 = "try";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"try\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_TYPEOF() {
        var cacheKey = "TYPEOF@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 6) === "typeof") {
          r3 = "typeof";
          advance(pos, 6);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"typeof\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UNDEFINED() {
        var cacheKey = "UNDEFINED@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 9) === "undefined") {
          r3 = "undefined";
          advance(pos, 9);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"undefined\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UNLESS() {
        var cacheKey = "UNLESS@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 6) === "unless") {
          r3 = "unless";
          advance(pos, 6);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"unless\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UNTIL() {
        var cacheKey = "UNTIL@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "until") {
          r3 = "until";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"until\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_WHEN() {
        var cacheKey = "WHEN@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 4) === "when") {
          r3 = "when";
          advance(pos, 4);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"when\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_WHILE() {
        var cacheKey = "WHILE@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 5) === "while") {
          r3 = "while";
          advance(pos, 5);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"while\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_YES() {
        var cacheKey = "YES@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 3) === "yes") {
          r3 = "yes";
          advance(pos, 3);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"yes\"");
          }
        }
        if (r3 !== null) {
          r5 = clone(pos);
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = clone(r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, w) { return w; })(r1.offset, r1.line, r1.column, r3);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_SharedKeywords() {
        var cacheKey = "SharedKeywords@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 4) === "true") {
          r2 = "true";
          advance(pos, 4);
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"true\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos.offset, 5) === "false") {
            r2 = "false";
            advance(pos, 5);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"false\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos.offset, 4) === "null") {
              r2 = "null";
              advance(pos, 4);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"null\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos.offset, 4) === "this") {
                r2 = "this";
                advance(pos, 4);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"this\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos.offset, 3) === "new") {
                  r2 = "new";
                  advance(pos, 3);
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"new\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos.offset, 6) === "delete") {
                    r2 = "delete";
                    advance(pos, 6);
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"delete\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos.offset, 6) === "typeof") {
                      r2 = "typeof";
                      advance(pos, 6);
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"typeof\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos.offset, 10) === "instanceof") {
                        r2 = "instanceof";
                        advance(pos, 10);
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"instanceof\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos.offset, 2) === "in") {
                          r2 = "in";
                          advance(pos, 2);
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"in\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos.offset, 6) === "return") {
                            r2 = "return";
                            advance(pos, 6);
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"return\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos.offset, 5) === "throw") {
                              r2 = "throw";
                              advance(pos, 5);
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"throw\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos.offset, 5) === "break") {
                                r2 = "break";
                                advance(pos, 5);
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"break\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos.offset, 8) === "continue") {
                                  r2 = "continue";
                                  advance(pos, 8);
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"continue\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos.offset, 8) === "debugger") {
                                    r2 = "debugger";
                                    advance(pos, 8);
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"debugger\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos.offset, 2) === "if") {
                                      r2 = "if";
                                      advance(pos, 2);
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"if\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos.offset, 4) === "else") {
                                        r2 = "else";
                                        advance(pos, 4);
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"else\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos.offset, 6) === "switch") {
                                          r2 = "switch";
                                          advance(pos, 6);
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"switch\"");
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos.offset, 3) === "for") {
                                            r2 = "for";
                                            advance(pos, 3);
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"for\"");
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos.offset, 5) === "while") {
                                              r2 = "while";
                                              advance(pos, 5);
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"while\"");
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos.offset, 2) === "do") {
                                                r2 = "do";
                                                advance(pos, 2);
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"do\"");
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos.offset, 3) === "try") {
                                                  r2 = "try";
                                                  advance(pos, 3);
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"try\"");
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos.offset, 5) === "catch") {
                                                    r2 = "catch";
                                                    advance(pos, 5);
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"catch\"");
                                                    }
                                                  }
                                                  if (r2 === null) {
                                                    if (input.substr(pos.offset, 7) === "finally") {
                                                      r2 = "finally";
                                                      advance(pos, 7);
                                                    } else {
                                                      r2 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"finally\"");
                                                      }
                                                    }
                                                    if (r2 === null) {
                                                      if (input.substr(pos.offset, 5) === "class") {
                                                        r2 = "class";
                                                        advance(pos, 5);
                                                      } else {
                                                        r2 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"class\"");
                                                        }
                                                      }
                                                      if (r2 === null) {
                                                        if (input.substr(pos.offset, 7) === "extends") {
                                                          r2 = "extends";
                                                          advance(pos, 7);
                                                        } else {
                                                          r2 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"extends\"");
                                                          }
                                                        }
                                                        if (r2 === null) {
                                                          if (input.substr(pos.offset, 5) === "super") {
                                                            r2 = "super";
                                                            advance(pos, 5);
                                                          } else {
                                                            r2 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"super\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_JSKeywords() {
        var cacheKey = "JSKeywords@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 4) === "case") {
          r2 = "case";
          advance(pos, 4);
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"case\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos.offset, 7) === "default") {
            r2 = "default";
            advance(pos, 7);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"default\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos.offset, 8) === "function") {
              r2 = "function";
              advance(pos, 8);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"function\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos.offset, 3) === "var") {
                r2 = "var";
                advance(pos, 3);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"var\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos.offset, 4) === "void") {
                  r2 = "void";
                  advance(pos, 4);
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"void\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos.offset, 4) === "with") {
                    r2 = "with";
                    advance(pos, 4);
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"with\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos.offset, 5) === "const") {
                      r2 = "const";
                      advance(pos, 5);
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"const\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos.offset, 3) === "let") {
                        r2 = "let";
                        advance(pos, 3);
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"let\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos.offset, 4) === "enum") {
                          r2 = "enum";
                          advance(pos, 4);
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"enum\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos.offset, 6) === "export") {
                            r2 = "export";
                            advance(pos, 6);
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"export\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos.offset, 6) === "import") {
                              r2 = "import";
                              advance(pos, 6);
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"import\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos.offset, 6) === "native") {
                                r2 = "native";
                                advance(pos, 6);
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"native\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos.offset, 10) === "implements") {
                                  r2 = "implements";
                                  advance(pos, 10);
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"implements\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos.offset, 9) === "interface") {
                                    r2 = "interface";
                                    advance(pos, 9);
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"interface\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos.offset, 7) === "package") {
                                      r2 = "package";
                                      advance(pos, 7);
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"package\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos.offset, 7) === "private") {
                                        r2 = "private";
                                        advance(pos, 7);
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"private\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos.offset, 9) === "protected") {
                                          r2 = "protected";
                                          advance(pos, 9);
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"protected\"");
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos.offset, 6) === "public") {
                                            r2 = "public";
                                            advance(pos, 6);
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"public\"");
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos.offset, 6) === "static") {
                                              r2 = "static";
                                              advance(pos, 6);
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"static\"");
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos.offset, 5) === "yield") {
                                                r2 = "yield";
                                                advance(pos, 5);
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"yield\"");
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_CSKeywords() {
        var cacheKey = "CSKeywords@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 9) === "undefined") {
          r2 = "undefined";
          advance(pos, 9);
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"undefined\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos.offset, 4) === "then") {
            r2 = "then";
            advance(pos, 4);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"then\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos.offset, 6) === "unless") {
              r2 = "unless";
              advance(pos, 6);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"unless\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos.offset, 5) === "until") {
                r2 = "until";
                advance(pos, 5);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"until\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos.offset, 4) === "loop") {
                  r2 = "loop";
                  advance(pos, 4);
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"loop\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos.offset, 3) === "off") {
                    r2 = "off";
                    advance(pos, 3);
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"off\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos.offset, 2) === "by") {
                      r2 = "by";
                      advance(pos, 2);
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"by\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos.offset, 4) === "when") {
                        r2 = "when";
                        advance(pos, 4);
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"when\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos.offset, 3) === "and") {
                          r2 = "and";
                          advance(pos, 3);
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"and\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos.offset, 2) === "or") {
                            r2 = "or";
                            advance(pos, 2);
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"or\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos.offset, 4) === "isnt") {
                              r2 = "isnt";
                              advance(pos, 4);
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"isnt\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos.offset, 2) === "is") {
                                r2 = "is";
                                advance(pos, 2);
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"is\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos.offset, 3) === "not") {
                                  r2 = "not";
                                  advance(pos, 3);
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"not\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos.offset, 3) === "yes") {
                                    r2 = "yes";
                                    advance(pos, 3);
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"yes\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos.offset, 2) === "no") {
                                      r2 = "no";
                                      advance(pos, 2);
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"no\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos.offset, 2) === "on") {
                                        r2 = "on";
                                        advance(pos, 2);
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"on\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos.offset, 2) === "of") {
                                          r2 = "of";
                                          advance(pos, 2);
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"of\"");
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = clone(pos);
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = clone(r4);
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_StandardPredefinedMacros() {
        var cacheKey = "StandardPredefinedMacros@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = clone(pos);
        if (input.substr(pos.offset, 2) === "__") {
          r2 = "__";
          advance(pos, 2);
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"__\"");
          }
        }
        if (r2 !== null) {
          if (input.substr(pos.offset, 8) === "FILENAME") {
            r3 = "FILENAME";
            advance(pos, 8);
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"FILENAME\"");
            }
          }
          if (r3 === null) {
            if (input.substr(pos.offset, 4) === "LINE") {
              r3 = "LINE";
              advance(pos, 4);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"LINE\"");
              }
            }
            if (r3 === null) {
              if (input.substr(pos.offset, 10) === "DATETIMEMS") {
                r3 = "DATETIMEMS";
                advance(pos, 10);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"DATETIMEMS\"");
                }
              }
              if (r3 === null) {
                if (input.substr(pos.offset, 4) === "DATE") {
                  r3 = "DATE";
                  advance(pos, 4);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"DATE\"");
                  }
                }
                if (r3 === null) {
                  if (input.substr(pos.offset, 4) === "TIME") {
                    r3 = "TIME";
                    advance(pos, 4);
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"TIME\"");
                    }
                  }
                }
              }
            }
          }
          if (r3 !== null) {
            if (input.substr(pos.offset, 2) === "__") {
              r4 = "__";
              advance(pos, 2);
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"__\"");
              }
            }
            if (r4 !== null) {
              r0 = [r2, r3, r4];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
        } else {
          r0 = null;
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_reserved() {
        var cacheKey = "reserved@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_StandardPredefinedMacros();
        if (r0 === null) {
          r0 = parse_SharedKeywords();
          if (r0 === null) {
            r0 = parse_CSKeywords();
            if (r0 === null) {
              r0 = parse_JSKeywords();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeEscapeSequence() {
        var cacheKey = "UnicodeEscapeSequence@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = clone(pos);
        r2 = clone(pos);
        if (input.substr(pos.offset, 2) === "\\u") {
          r3 = "\\u";
          advance(pos, 2);
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\u\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_hexDigit();
          if (r4 !== null) {
            r5 = parse_hexDigit();
            if (r5 !== null) {
              r6 = parse_hexDigit();
              if (r6 !== null) {
                r7 = parse_hexDigit();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = clone(r2);
                }
              } else {
                r0 = null;
                pos = clone(r2);
              }
            } else {
              r0 = null;
              pos = clone(r2);
            }
          } else {
            r0 = null;
            pos = clone(r2);
          }
        } else {
          r0 = null;
          pos = clone(r2);
        }
        if (r0 !== null) {
          r0 = (function(offset, line, column, h0, h1, h2, h3) { return String.fromCharCode(parseInt(h0 + h1 + h2 + h3, 16)); })(r1.offset, r1.line, r1.column, r4, r5, r6, r7);
        }
        if (r0 === null) {
          pos = clone(r1);
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeLetter() {
        var cacheKey = "UnicodeLetter@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uFF21-\uFF3Aa-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D62-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7C\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2D00-\u2D25\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA9CF\uAA70\uAADD\uFF70\uFF9E\uFF9F\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u2135-\u2138\u2D30-\u2D65\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FCB\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA2D\uFA30-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]");
          }
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 55340) {
            r2 = "\uD82C";
            advance(pos, 1);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uD82C\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDC00\uDC01]/.test(input.charAt(pos.offset))) {
              r3 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDC00\\uDC01]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            if (input.charCodeAt(pos.offset) === 55304) {
              r2 = "\uD808";
              advance(pos, 1);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD808\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDC00-\uDF6E]/.test(input.charAt(pos.offset))) {
                r3 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDC00-\\uDF6E]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = clone(r1);
              }
            } else {
              r0 = null;
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              if (input.charCodeAt(pos.offset) === 55401) {
                r2 = "\uD869";
                advance(pos, 1);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD869\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDED6\uDF00]/.test(input.charAt(pos.offset))) {
                  r3 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDED6\\uDF00]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = clone(r1);
                }
              } else {
                r0 = null;
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                if (input.charCodeAt(pos.offset) === 55305) {
                  r2 = "\uD809";
                  advance(pos, 1);
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\uD809\"");
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDC00-\uDC62]/.test(input.charAt(pos.offset))) {
                    r3 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\uDC00-\\uDC62]");
                    }
                  }
                  if (r3 !== null) {
                    r0 = [r2, r3];
                  } else {
                    r0 = null;
                    pos = clone(r1);
                  }
                } else {
                  r0 = null;
                  pos = clone(r1);
                }
                if (r0 === null) {
                  r1 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 55349) {
                    r2 = "\uD835";
                    advance(pos, 1);
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\uD835\"");
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/.test(input.charAt(pos.offset))) {
                      r3 = input.charAt(pos.offset);
                      advance(pos, 1);
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]");
                      }
                    }
                    if (r3 !== null) {
                      r0 = [r2, r3];
                    } else {
                      r0 = null;
                      pos = clone(r1);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r1);
                  }
                  if (r0 === null) {
                    r1 = clone(pos);
                    if (input.charCodeAt(pos.offset) === 55300) {
                      r2 = "\uD804";
                      advance(pos, 1);
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\uD804\"");
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDC03-\uDC37\uDC83-\uDCAF]/.test(input.charAt(pos.offset))) {
                        r3 = input.charAt(pos.offset);
                        advance(pos, 1);
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed("[\\uDC03-\\uDC37\\uDC83-\\uDCAF]");
                        }
                      }
                      if (r3 !== null) {
                        r0 = [r2, r3];
                      } else {
                        r0 = null;
                        pos = clone(r1);
                      }
                    } else {
                      r0 = null;
                      pos = clone(r1);
                    }
                    if (r0 === null) {
                      r1 = clone(pos);
                      if (input.charCodeAt(pos.offset) === 55296) {
                        r2 = "\uD800";
                        advance(pos, 1);
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\uD800\"");
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF40\uDF42-\uDF49\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]/.test(input.charAt(pos.offset))) {
                          r3 = input.charAt(pos.offset);
                          advance(pos, 1);
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed("[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]");
                          }
                        }
                        if (r3 !== null) {
                          r0 = [r2, r3];
                        } else {
                          r0 = null;
                          pos = clone(r1);
                        }
                      } else {
                        r0 = null;
                        pos = clone(r1);
                      }
                      if (r0 === null) {
                        r1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 55308) {
                          r2 = "\uD80C";
                          advance(pos, 1);
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\uD80C\"");
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDC00-\uDFFF]/.test(input.charAt(pos.offset))) {
                            r3 = input.charAt(pos.offset);
                            advance(pos, 1);
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed("[\\uDC00-\\uDFFF]");
                            }
                          }
                          if (r3 !== null) {
                            r0 = [r2, r3];
                          } else {
                            r0 = null;
                            pos = clone(r1);
                          }
                        } else {
                          r0 = null;
                          pos = clone(r1);
                        }
                        if (r0 === null) {
                          r1 = clone(pos);
                          if (input.charCodeAt(pos.offset) === 55297) {
                            r2 = "\uD801";
                            advance(pos, 1);
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\uD801\"");
                            }
                          }
                          if (r2 !== null) {
                            if (/^[\uDC00-\uDC9D]/.test(input.charAt(pos.offset))) {
                              r3 = input.charAt(pos.offset);
                              advance(pos, 1);
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed("[\\uDC00-\\uDC9D]");
                              }
                            }
                            if (r3 !== null) {
                              r0 = [r2, r3];
                            } else {
                              r0 = null;
                              pos = clone(r1);
                            }
                          } else {
                            r0 = null;
                            pos = clone(r1);
                          }
                          if (r0 === null) {
                            r1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 55406) {
                              r2 = "\uD86E";
                              advance(pos, 1);
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"\\uD86E\"");
                              }
                            }
                            if (r2 !== null) {
                              if (/^[\uDC1D]/.test(input.charAt(pos.offset))) {
                                r3 = input.charAt(pos.offset);
                                advance(pos, 1);
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("[\\uDC1D]");
                                }
                              }
                              if (r3 !== null) {
                                r0 = [r2, r3];
                              } else {
                                r0 = null;
                                pos = clone(r1);
                              }
                            } else {
                              r0 = null;
                              pos = clone(r1);
                            }
                            if (r0 === null) {
                              r1 = clone(pos);
                              if (input.charCodeAt(pos.offset) === 55299) {
                                r2 = "\uD803";
                                advance(pos, 1);
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"\\uD803\"");
                                }
                              }
                              if (r2 !== null) {
                                if (/^[\uDC00-\uDC48]/.test(input.charAt(pos.offset))) {
                                  r3 = input.charAt(pos.offset);
                                  advance(pos, 1);
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("[\\uDC00-\\uDC48]");
                                  }
                                }
                                if (r3 !== null) {
                                  r0 = [r2, r3];
                                } else {
                                  r0 = null;
                                  pos = clone(r1);
                                }
                              } else {
                                r0 = null;
                                pos = clone(r1);
                              }
                              if (r0 === null) {
                                r1 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 55360) {
                                  r2 = "\uD840";
                                  advance(pos, 1);
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"\\uD840\"");
                                  }
                                }
                                if (r2 !== null) {
                                  if (/^[\uDC00]/.test(input.charAt(pos.offset))) {
                                    r3 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("[\\uDC00]");
                                    }
                                  }
                                  if (r3 !== null) {
                                    r0 = [r2, r3];
                                  } else {
                                    r0 = null;
                                    pos = clone(r1);
                                  }
                                } else {
                                  r0 = null;
                                  pos = clone(r1);
                                }
                                if (r0 === null) {
                                  r1 = clone(pos);
                                  if (input.charCodeAt(pos.offset) === 55422) {
                                    r2 = "\uD87E";
                                    advance(pos, 1);
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"\\uD87E\"");
                                    }
                                  }
                                  if (r2 !== null) {
                                    if (/^[\uDC00-\uDE1D]/.test(input.charAt(pos.offset))) {
                                      r3 = input.charAt(pos.offset);
                                      advance(pos, 1);
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("[\\uDC00-\\uDE1D]");
                                      }
                                    }
                                    if (r3 !== null) {
                                      r0 = [r2, r3];
                                    } else {
                                      r0 = null;
                                      pos = clone(r1);
                                    }
                                  } else {
                                    r0 = null;
                                    pos = clone(r1);
                                  }
                                  if (r0 === null) {
                                    r1 = clone(pos);
                                    if (input.charCodeAt(pos.offset) === 55405) {
                                      r2 = "\uD86D";
                                      advance(pos, 1);
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"\\uD86D\"");
                                      }
                                    }
                                    if (r2 !== null) {
                                      if (/^[\uDF34\uDF40]/.test(input.charAt(pos.offset))) {
                                        r3 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("[\\uDF34\\uDF40]");
                                        }
                                      }
                                      if (r3 !== null) {
                                        r0 = [r2, r3];
                                      } else {
                                        r0 = null;
                                        pos = clone(r1);
                                      }
                                    } else {
                                      r0 = null;
                                      pos = clone(r1);
                                    }
                                    if (r0 === null) {
                                      r1 = clone(pos);
                                      if (input.charCodeAt(pos.offset) === 55322) {
                                        r2 = "\uD81A";
                                        advance(pos, 1);
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"\\uD81A\"");
                                        }
                                      }
                                      if (r2 !== null) {
                                        if (/^[\uDC00-\uDE38]/.test(input.charAt(pos.offset))) {
                                          r3 = input.charAt(pos.offset);
                                          advance(pos, 1);
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("[\\uDC00-\\uDE38]");
                                          }
                                        }
                                        if (r3 !== null) {
                                          r0 = [r2, r3];
                                        } else {
                                          r0 = null;
                                          pos = clone(r1);
                                        }
                                      } else {
                                        r0 = null;
                                        pos = clone(r1);
                                      }
                                      if (r0 === null) {
                                        r1 = clone(pos);
                                        if (input.charCodeAt(pos.offset) === 55298) {
                                          r2 = "\uD802";
                                          advance(pos, 1);
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\uD802\"");
                                          }
                                        }
                                        if (r2 !== null) {
                                          if (/^[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72]/.test(input.charAt(pos.offset))) {
                                            r3 = input.charAt(pos.offset);
                                            advance(pos, 1);
                                          } else {
                                            r3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]");
                                            }
                                          }
                                          if (r3 !== null) {
                                            r0 = [r2, r3];
                                          } else {
                                            r0 = null;
                                            pos = clone(r1);
                                          }
                                        } else {
                                          r0 = null;
                                          pos = clone(r1);
                                        }
                                        if (r0 === null) {
                                          r1 = clone(pos);
                                          if (input.charCodeAt(pos.offset) === 55309) {
                                            r2 = "\uD80D";
                                            advance(pos, 1);
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"\\uD80D\"");
                                            }
                                          }
                                          if (r2 !== null) {
                                            if (/^[\uDC00-\uDC2E]/.test(input.charAt(pos.offset))) {
                                              r3 = input.charAt(pos.offset);
                                              advance(pos, 1);
                                            } else {
                                              r3 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("[\\uDC00-\\uDC2E]");
                                              }
                                            }
                                            if (r3 !== null) {
                                              r0 = [r2, r3];
                                            } else {
                                              r0 = null;
                                              pos = clone(r1);
                                            }
                                          } else {
                                            r0 = null;
                                            pos = clone(r1);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeCombiningMark() {
        var cacheKey = "UnicodeCombiningMark@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u19B0-\u19C0\u19C8\u19C9\u1A19-\u1A1B\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]");
          }
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 56128) {
            r2 = "\uDB40";
            advance(pos, 1);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uDB40\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDD00-\uDDEF]/.test(input.charAt(pos.offset))) {
              r3 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDD00-\\uDDEF]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            if (input.charCodeAt(pos.offset) === 55348) {
              r2 = "\uD834";
              advance(pos, 1);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD834\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDD65\uDD66\uDD6D-\uDD72]/.test(input.charAt(pos.offset))) {
                r3 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = clone(r1);
              }
            } else {
              r0 = null;
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              if (input.charCodeAt(pos.offset) === 55300) {
                r2 = "\uD804";
                advance(pos, 1);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD804\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDC01\uDC38-\uDC46\uDC80\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8]/.test(input.charAt(pos.offset))) {
                  r3 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = clone(r1);
                }
              } else {
                r0 = null;
                pos = clone(r1);
              }
              if (r0 === null) {
                r1 = clone(pos);
                if (input.charCodeAt(pos.offset) === 55296) {
                  r2 = "\uD800";
                  advance(pos, 1);
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\uD800\"");
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDDFD]/.test(input.charAt(pos.offset))) {
                    r3 = input.charAt(pos.offset);
                    advance(pos, 1);
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\uDDFD]");
                    }
                  }
                  if (r3 !== null) {
                    r0 = [r2, r3];
                  } else {
                    r0 = null;
                    pos = clone(r1);
                  }
                } else {
                  r0 = null;
                  pos = clone(r1);
                }
                if (r0 === null) {
                  r1 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 55298) {
                    r2 = "\uD802";
                    advance(pos, 1);
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\uD802\"");
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F]/.test(input.charAt(pos.offset))) {
                      r3 = input.charAt(pos.offset);
                      advance(pos, 1);
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]");
                      }
                    }
                    if (r3 !== null) {
                      r0 = [r2, r3];
                    } else {
                      r0 = null;
                      pos = clone(r1);
                    }
                  } else {
                    r0 = null;
                    pos = clone(r1);
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeDigit() {
        var cacheKey = "UnicodeDigit@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]");
          }
        }
        if (r0 === null) {
          r1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 55349) {
            r2 = "\uD835";
            advance(pos, 1);
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uD835\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDFCE-\uDFFF]/.test(input.charAt(pos.offset))) {
              r3 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDFCE-\\uDFFF]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = clone(r1);
            }
          } else {
            r0 = null;
            pos = clone(r1);
          }
          if (r0 === null) {
            r1 = clone(pos);
            if (input.charCodeAt(pos.offset) === 55300) {
              r2 = "\uD804";
              advance(pos, 1);
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD804\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDC66-\uDC6F]/.test(input.charAt(pos.offset))) {
                r3 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDC66-\\uDC6F]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = clone(r1);
              }
            } else {
              r0 = null;
              pos = clone(r1);
            }
            if (r0 === null) {
              r1 = clone(pos);
              if (input.charCodeAt(pos.offset) === 55297) {
                r2 = "\uD801";
                advance(pos, 1);
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD801\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDCA0-\uDCA9]/.test(input.charAt(pos.offset))) {
                  r3 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDCA0-\\uDCA9]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = clone(r1);
                }
              } else {
                r0 = null;
                pos = clone(r1);
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeConnectorPunctuation() {
        var cacheKey = "UnicodeConnectorPunctuation@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/.test(input.charAt(pos.offset))) {
          r0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ZWNJ() {
        var cacheKey = "ZWNJ@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.charCodeAt(pos.offset) === 8204) {
          r0 = "\u200C";
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u200C\"");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      function parse_ZWJ() {
        var cacheKey = "ZWJ@" + pos.offset;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = clone(cachedResult.nextPos);
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.charCodeAt(pos.offset) === 8205) {
          r0 = "\u200D";
          advance(pos, 1);
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u200D\"");
          }
        }
        
        cache[cacheKey] = {
          nextPos: clone(pos),
          result:  r0
        };
        return r0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      
      
      var CS = require("./nodes"),
          inspect = function(o){ console.log(require('util').inspect(o, false, 9e9, true)); },
          constructorLookup =
            { ';': CS.SeqOp
            , '=': CS.AssignOp
            , '&&': CS.LogicalAndOp
            , and: CS.LogicalAndOp
            , '||': CS.LogicalOrOp
            , or: CS.LogicalOrOp
            , '|': CS.BitOrOp
            , '^': CS.BitXorOp
            , '&': CS.BitAndOp
            , '?': CS.ExistsOp
            , '==': CS.EQOp
            , is: CS.EQOp
            , '!=': CS.NEQOp
            , isnt: CS.NEQOp
            , '<=': CS.LTEOp
            , '>=': CS.GTEOp
            , '<': CS.LTOp
            , '>': CS.GTOp
            , extends: CS.ExtendsOp
            , instanceof: CS.InstanceofOp
            , in: CS.InOp
            , of: CS.OfOp
            , '<<': CS.LeftShiftOp
            , '>>': CS.SignedRightShiftOp
            , '>>>': CS.UnsignedRightShiftOp
            , '+': CS.PlusOp
            , '-': CS.SubtractOp
            , '*': CS.MultiplyOp
            , '/': CS.DivideOp
            , '%': CS.RemOp
            , '**': CS.ExpOp
            },
          foldl = function(fn, memo, list){
            for(var i = 0, l = list.length; i < l; ++i)
              memo = fn(memo, list[i]);
            return memo;
          },
          foldr = function(fn, memo, list){
            for(var i = list.length; i--;)
              memo = fn(memo, list[i]);
            return memo;
          },
          createInterpolation = function(es){
            var init = new CS.String('').g();
            return foldl(function(memo, s){
              if(s instanceof CS.String) {
                var left = memo;
                while(left)
                  if(left instanceof CS.String) {
                    if(left === init) delete left.p(s.line, s.column, s.offset).generated;
                    left.data = left.data + s.data;
                    return memo;
                  } else if(left instanceof CS.ConcatOp) {
                    left = left.right
                  } else {
                    break;
                  }
              }
              return new CS.ConcatOp(memo, s);
            }, init, es);
          },
          createMemberExpression = function(e, accesses){
            return foldl(function(left, access){
              var F = function(){};
              F.prototype = access.op.prototype;
              var o = new F;
              // rather safely assumes access.op is returning non-Object
              access.op.apply(o, [left].concat(access.operands));
              return o.r(left.raw + access.raw).p(access.line, access.column, access.offset);
            }, e, accesses);
          },
          isValidRegExpFlags = function(flags) {
            if(!flags) return true;
            if(flags.length > 4) return false;
            flags.sort();
            var flag = null;
            for(var i = 0, l = flags.length; i < l; ++i)
              if(flag == flags[i]) return false;
              else flag = flags[i];
            return true;
          },
          stripLeadingWhitespace = function(str){
            str = str.replace(/\s+$/, '');
            var attempt, match, matchStr = str, indent = null;
            while(match = /\n+([^\n\S]*)/.exec(matchStr)) {
              attempt = match[1];
              matchStr = matchStr.slice(match.index + match[0].length);
              if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                indent = attempt;
            }
            if(indent) str = str.replace(new RegExp('\\n' + indent, 'g'), '\n');
            str = str.replace(/^\n/, '');
            return str;
          };
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos.offset === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos.offset < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos.offset === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos.offset !== input.length) {
        var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = (function(){
    var SyntaxError = result.SyntaxError;
    var F = function(){
      this.constructor = SyntaxError;
      this.name = "SyntaxError";
    };
    F.prototype = Error.prototype;
    return new F;
  })();
  
  return result;
})();

});

require.define("/node_modules/coffee2ls-codegen/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"./lib/coffee2ls-codegen"}
});

require.define("/node_modules/coffee2ls-codegen/lib/coffee2ls-codegen.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 1.3.3
(function() {
  var codegen,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (function(exports) {
    var TAB, clone, eq, formatInterpolation, formatStringData, genVar, generate, generateArgs, indent, levels, lsReserved, needsParensWhenOnLeft, operators, parens, precedence;
    TAB = '  ';
    indent = function(code) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = code.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push("" + TAB + line);
        }
        return _results;
      })()).join('\n');
    };
    parens = function(code) {
      return "(" + code + ")";
    };
    formatStringData = function(data) {
      return data.replace(/[^\x20-\x7e]|['\\]/g, function(c) {
        var escape, pad;
        switch (c) {
          case '\0':
            return '\\0';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\n':
            return '\\n';
          case '\f':
            return '\\f';
          case '\r':
            return '\\r';
          case '\'':
            return '\\\'';
          case '\\':
            return '\\\\';
          default:
            escape = (c.charCodeAt(0)).toString(16);
            pad = "0000".slice(escape.length);
            return "\\u" + pad + escape;
        }
      });
    };
    formatInterpolation = function(ast, options) {
      var left, right;
      switch (ast.className) {
        case "ConcatOp":
          left = formatInterpolation(ast.left, options);
          right = formatInterpolation(ast.right, options);
          return "" + left + right;
        case "String":
          return formatStringData(ast.data);
        default:
          return "\#{" + (generate(ast, options)) + "}";
      }
    };
    needsParensWhenOnLeft = function(ast) {
      switch (ast.className) {
        case 'Function':
        case 'BoundFunction':
        case 'NewOp':
        case 'Class':
          return true;
        case 'Conditional':
        case 'Switch':
        case 'While':
        case 'ForIn':
        case 'ForOf':
        case 'Block':
          return true;
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'LogicalNotOp':
        case 'BitNotOp':
        case 'DoOp':
        case 'TypeofOp':
        case 'DeleteOp':
          return needsParensWhenOnLeft(ast.expression);
        case 'FunctionApplication':
          return ast["arguments"].length > 0;
        case 'Super':
        case 'Try':
          return true;
        default:
          return false;
      }
    };
    eq = function(nodeA, nodeB) {
      var i, prop, v, val, _i, _len;
      for (prop in nodeA) {
        if (!__hasProp.call(nodeA, prop)) continue;
        val = nodeA[prop];
        if (prop === 'raw' || prop === 'line' || prop === 'column') {
          continue;
        }
        switch (Object.prototype.toString.call(val)) {
          case '[object Object]':
            if (!eq(nodeB[prop], val)) {
              return false;
            }
            break;
          case '[object Array]':
            for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
              v = val[i];
              if (!eq(nodeB[prop][i], v)) {
                return false;
              }
            }
            break;
          default:
            if (nodeB[prop] !== val) {
              return false;
            }
        }
      }
      return true;
    };
    clone = function(obj, overrides) {
      var newObj, prop, val;
      if (overrides == null) {
        overrides = {};
      }
      newObj = {};
      for (prop in obj) {
        if (!__hasProp.call(obj, prop)) continue;
        val = obj[prop];
        newObj[prop] = val;
      }
      for (prop in overrides) {
        if (!__hasProp.call(overrides, prop)) continue;
        val = overrides[prop];
        newObj[prop] = val;
      }
      return newObj;
    };
    generateArgs = function(args, options) {
      var a, arg, argList, i;
      if (options == null) {
        options = {};
      }
      if (args.length) {
        argList = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
            a = args[i];
            arg = generate(a, options);
            if (((needsParensWhenOnLeft(a)) && i + 1 !== args.length) || (a.className === 'Function' && i === 0)) {
              arg = parens(arg);
            }
            _results.push(arg);
          }
          return _results;
        })();
        return argList.join(', ');
      } else {
        return '';
      }
    };
    genVar = function(options, name) {
      var i, out, _ref;
      if (name == null) {
        name = 'ref';
      }
      i = 0;
      while (_ref = (out = "" + name + (i || '') + "$$"), __indexOf.call(options.varsTotal, _ref) >= 0) {
        ++i;
      }
      options.varsTotal.push(out);
      options.varsFunc.push(out);
      return out;
    };
    levels = [['SeqOp'], ['Conditional', 'ForIn', 'ForOf', 'While'], ['FunctionApplication', 'SoakedFunctionApplication'], ['AssignOp', 'CompoundAssignOp', 'ExistsAssignOp'], ['LogicalOrOp'], ['LogicalAndOp'], ['BitOrOp'], ['BitXorOp'], ['BitAndOp'], ['ExistsOp'], ['EQOp', 'NEQOp'], ['LTOp', 'LTEOp', 'GTOp', 'GTEOp', 'InOp', 'OfOp', 'InstanceofOp'], ['LeftShiftOp', 'SignedRightShiftOp', 'UnsignedRightShiftOp'], ['PlusOp', 'SubtractOp'], ['MultiplyOp', 'DivideOp', 'RemOp'], ['ExpOp', 'ExtendOp'], ['UnaryPlusOp', 'UnaryNegateOp', 'LogicalNotOp', 'BitNotOp', 'DoOp', 'TypeofOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'], ['UnaryExistsOp', 'ShallowCopyArray', 'PostIncrementOp', 'PostDecrementOp', 'Spread'], ['NewOp'], ['MemberAccessOp', 'SoakedMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicProtoMemberAccessOp', 'SoakedProtoMemberAccessOp', 'SoakedDynamicProtoMemberAccessOp']];
    precedence = {};
    (function() {
      var level, op, ops, _i, _len, _results;
      _results = [];
      for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
        ops = levels[level];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
            op = ops[_j];
            _results1.push(precedence[op] = level);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    operators = {
      SeqOp: ';',
      LogicalOrOp: '||',
      LogicalAndOp: '&&',
      BitOrOp: '.|.',
      BitXorOp: '.^.',
      BitAndOp: '.&.',
      EQOp: 'is',
      NEQOp: 'isnt',
      LTOp: '<',
      LTEOp: '<=',
      GTOp: '>',
      GTEOp: '>=',
      InOp: 'in',
      OfOp: 'of',
      InstanceofOp: 'instanceof',
      ExtendsOp: 'extends',
      LeftShiftOp: '.<<.',
      SignedRightShiftOp: '.>>.',
      UnsignedRightShiftOp: '.>>>.',
      PlusOp: '+',
      SubtractOp: '-',
      MultiplyOp: '*',
      DivideOp: '/',
      RemOp: '%',
      ExpOp: '**',
      AssignOp: '=',
      ExistsAssignOp: '?:=',
      ExistsOp: '?',
      UnaryPlusOp: '+',
      UnaryNegateOp: '-',
      LogicalNotOp: 'not ',
      BitNotOp: '~',
      NewOp: 'new ',
      TypeofOp: 'typeof ',
      PreIncrementOp: '++',
      PreDecrementOp: '--',
      Spread: '...',
      UnaryExistsOp: '?',
      ShallowCopyArray: '[..]',
      PostIncrementOp: '++',
      PostDecrementOp: '--',
      FunctionApplication: '',
      SoakedFunctionApplication: '?',
      MemberAccessOp: '.',
      SoakedMemberAccessOp: '?.',
      ProtoMemberAccessOp: '::',
      SoakedProtoMemberAccessOp: '?::',
      DynamicMemberAccessOp: '',
      SoakedDynamicMemberAccessOp: '?',
      DynamicProtoMemberAccessOp: '::',
      SoakedDynamicProtoMemberAccessOp: '?::'
    };
    lsReserved = ['it', 'that', 'fallthrough', 'otherwise', 'where', 'xor', 'match'];
    return exports.generate = generate = function(ast, options) {
      var absNum, allNew, allReassign, c, comprehension, exp, expression_, finallyBody, findIds, firstRef, flag, hasAlternate, i, isMultiline, key_, left, line, m, matched, memberAccessOps, members_, needsParens, newline, nonLiteral, out, output, p, parameters, parent, parentClassName, prec, reg, right, s, secondRef, sep, spaces, src, state, type, usedAsExpression, v, vars, _alternate, _argList, _args, _assg, _assignee, _block, _body, _by, _catchAssg, _catchBody, _condition, _conditions, _consequent, _ctor, _expr, _expression, _exprs, _filter, _finally, _firstAssg, _flags, _fn, _fn_indented, _indexingExpr, _left, _main, _mainPart, _mid, _nameAssg, _op, _output, _own, _paramList, _parent, _rangeLeft, _rangeRight, _ref, _ref1, _ref2, _ref3, _right, _s, _secondAssg, _step, _symbol, _target;
      if (options == null) {
        options = {};
      }
      if (!(ast != null)) {
        return '';
      }
      needsParens = false;
      if ((_ref = options.precedence) == null) {
        options.precedence = 0;
      }
      if ((_ref1 = options.ancestors) == null) {
        options.ancestors = [];
      }
      if ((_ref2 = options.varsTotal) == null) {
        options.varsTotal = [];
      }
      if ((_ref3 = options.varsFunc) == null) {
        options.varsFunc = [];
      }
      parent = options.ancestors[0];
      parentClassName = parent != null ? parent.className : void 0;
      usedAsExpression = (parent != null) && parentClassName !== 'Block';
      src = (function() {
        var _i, _j, _len, _len1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (ast.className) {
          case 'Program':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            if (ast.body != null) {
              return generate(ast.body, options);
            } else {
              return '';
            }
            break;
          case 'Block':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: 0
            });
            if (ast.statements.length === 0) {
              return generate((new Undefined).g(), options);
            } else {
              sep = parentClassName === 'Program' ? '\n\n' : '\n';
              return ((function() {
                var _i, _len, _ref4, _results;
                _ref4 = ast.statements;
                _results = [];
                for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                  s = _ref4[_i];
                  _results.push(generate(s, options));
                }
                return _results;
              })()).join(sep);
            }
            break;
          case 'Conditional':
            options.ancestors.unshift(ast);
            options.precedence = 0;
            hasAlternate = (ast.consequent != null) && (ast.alternate != null);
            _consequent = generate((_ref4 = ast.consequent) != null ? _ref4 : (new Undefined).g(), options);
            _alternate = hasAlternate ? generate(ast.alternate, options) : "";
            _condition = generate(ast.condition, options);
            isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
            if (hasAlternate) {
              _alternate = isMultiline ? "\nelse\n" + (indent(_alternate)) : " else " + _alternate;
            }
            if (!isMultiline && !hasAlternate && !usedAsExpression) {
              return "" + _consequent + " if " + _condition;
            } else if (isMultiline) {
              return "if " + _condition + "\n" + (indent(_consequent)) + _alternate;
            } else {
              return "if " + _condition + " then " + _consequent + _alternate;
            }
            break;
          case 'Identifier':
            if (_ref5 = ast.data, __indexOf.call(lsReserved, _ref5) >= 0) {
              return genVar(options, ast.data);
            } else {
              return ast.data;
            }
            break;
          case 'Null':
            return 'null';
          case 'This':
            return 'this';
          case 'Undefined':
            return 'void';
          case 'Int':
            absNum = ast.data < 0 ? -ast.data : ast.data;
            if (absNum >= 1e12 || (absNum > 0x90 && 0 === (absNum & (absNum - 1)))) {
              return "0x" + (ast.data.toString(16));
            } else {
              return ast.data.toString(10);
            }
            break;
          case 'Float':
            return ast.data.toString(10);
          case 'String':
            return "'" + (formatStringData(ast.data)) + "'";
          case 'Bool':
            return "" + (ast.data.toString());
          case 'ArrayInitialiser':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            members_ = (function() {
              var _i, _len, _ref6, _results;
              _ref6 = ast.members;
              _results = [];
              for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
                m = _ref6[_i];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return "[" + (members_.join(', ')) + "]";
              default:
                return "[\n" + (indent(members_.join('\n'))) + "\n]";
            }
            break;
          case 'ObjectInitialiser':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            members_ = (function() {
              var _j, _len1, _ref6, _results;
              _ref6 = ast.members;
              _results = [];
              for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
                m = _ref6[_j];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return "{" + (members_.join(', ')) + "}";
              default:
                return "{\n" + (indent(members_.join('\n'))) + "\n}";
            }
            break;
          case 'ObjectInitialiserMember':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            key_ = generate(ast.key, options);
            expression_ = generate(ast.expression, options);
            memberAccessOps = ['MemberAccessOp', 'ProtoMemberAccessOp', 'SoakedMemberAccessOp', 'SoakedProtoMemberAccessOp'];
            if (eq(ast.key, ast.expression)) {
              return "" + key_;
            } else if ((_ref6 = ast.expression.className, __indexOf.call(memberAccessOps, _ref6) >= 0) && ast.key.data === ast.expression.memberName) {
              return "" + expression_;
            } else {
              return "" + key_ + ": " + expression_;
            }
            break;
          case 'Function':
          case 'BoundFunction':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression,
              varsTotal: options.varsTotal.slice(0),
              varsFunc: []
            });
            parameters = (function() {
              var _j, _len1, _ref7, _results;
              _ref7 = ast.parameters;
              _results = [];
              for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
                p = _ref7[_j];
                _results.push(generate(p, options));
              }
              return _results;
            })();
            options.precedence = 0;
            _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
            _paramList = ast.parameters.length > 0 ? "(" + (parameters.join(', ')) + ") " : '';
            _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? " " + _body : "\n" + (indent(_body));
            switch (ast.className) {
              case 'Function':
                return "" + _paramList + "->" + _block;
              case 'BoundFunction':
                return "" + _paramList + "~>" + _block;
            }
            break;
          case 'AssignOp':
          case 'ExistsAssignOp':
            _op = operators[ast.className];
            if (ast.className === 'AssignOp') {
              vars = [];
              findIds = function(node) {
                var member, _j, _len1, _ref7;
                switch (node.className) {
                  case 'Identifier':
                    vars.push(node.data);
                    break;
                  case 'Rest':
                    vars.push(node.expression.data);
                    break;
                  case 'ObjectInitialiserMember':
                    vars.push(node.expression.data);
                    break;
                  case 'ArrayInitialiser':
                  case 'ObjectInitialiser':
                    _ref7 = node.members;
                    for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
                      member = _ref7[_j];
                      findIds(member);
                    }
                }
                return void 0;
              };
              findIds(ast.assignee);
              if (vars.length) {
                allNew = true;
                allReassign = true;
                for (_j = 0, _len1 = vars.length; _j < _len1; _j++) {
                  v = vars[_j];
                  if (__indexOf.call(options.varsTotal, v) >= 0 && __indexOf.call(options.varsFunc, v) < 0) {
                    allNew = false;
                  } else {
                    allReassign = false;
                    options.varsTotal.push(v);
                    options.varsFunc.push(v);
                  }
                }
                if (allReassign) {
                  _op = ':=';
                } else if (!allNew) {
                  throw new Error('mixed reassign and initialisation in destructuring is not currently supported');
                }
              }
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " " + _op + " " + _expr;
          case 'CompoundAssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _op = operators[ast.op];
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            _assg = (_ref7 = ast.op) === 'LogicalOrOp' || _ref7 === 'LogicalAndOp' ? ':=' : '=';
            return "" + _assignee + " " + _op + _assg + " " + _expr;
          case 'SeqOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            _right = generate(ast.right, options);
            return "" + _left + "; " + _right;
          case 'LogicalOrOp':
          case 'LogicalAndOp':
          case 'BitOrOp':
          case 'BitXorOp':
          case 'BitAndOp':
          case 'LeftShiftOp':
          case 'SignedRightShiftOp':
          case 'UnsignedRightShiftOp':
          case 'EQOp':
          case 'NEQOp':
          case 'LTOp':
          case 'LTEOp':
          case 'GTOp':
          case 'GTEOp':
          case 'InOp':
          case 'OfOp':
          case 'InstanceofOp':
          case 'PlusOp':
          case 'SubtractOp':
          case 'MultiplyOp':
          case 'DivideOp':
          case 'RemOp':
          case 'ExistsOp':
          case 'ExpOp':
          case 'ExtendsOp':
            _op = operators[ast.className];
            if (((_ref8 = ast.className) === 'InOp' || _ref8 === 'OfOp' || _ref8 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
              _op = "not " + _op;
            }
            if (!options.inFunctionApplication) {
              if (ast.className === 'LogicalOrOp') {
                _op = 'or';
              } else if (ast.className === 'LogicalAndOp') {
                _op = 'and';
              }
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            if (needsParensWhenOnLeft(ast.left)) {
              _left = parens(_left);
            }
            _right = generate(ast.right, options);
            return "" + _left + " " + _op + " " + _right;
          case 'ChainedComparisonOp':
            return generate(ast.expression, options);
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'TypeofOp':
          case 'PreIncrementOp':
          case 'PreDecrementOp':
          case 'Spread':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            if (ast.className === 'LogicalNotOp') {
              if ((_ref9 = ast.expression.className) === 'InOp' || _ref9 === 'OfOp' || _ref9 === 'InstanceofOp') {
                _op = '';
                prec = precedence[ast.expression.className];
              }
              if (('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) || 'EQOp' === parentClassName) {
                _op = '!';
              }
            }
            needsParens = prec < options.precedence;
            if (parentClassName === ast.className && ((_ref10 = ast.className) === 'UnaryPlusOp' || _ref10 === 'UnaryNegateOp')) {
              needsParens = true;
            }
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.className === 'UnaryNegateOp' && ast.expression.className === 'PreDecrementOp') {
              return "-" + (parens(generate(ast.expression, options)));
            } else {
              return "" + _op + (generate(ast.expression, options));
            }
            break;
          case 'DeleteOp':
            return "delete! " + (generate(ast.expression, options));
          case 'UnaryExistsOp':
          case 'PostIncrementOp':
          case 'PostDecrementOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _expr = generate(ast.expression, options);
            if (needsParensWhenOnLeft(ast.expression)) {
              _expr = parens(_expr);
            }
            return "" + _expr + _op;
          case 'NewOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _ctor = generate(ast.ctor, options);
            if (ast["arguments"].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
              _ctor = parens(_ctor);
            }
            options.precedence = precedence['AssignOp'];
            _args = ast["arguments"].length ? " " + (generateArgs(ast["arguments"], options)) : '';
            return "" + _op + _ctor + _args;
          case 'FunctionApplication':
          case 'SoakedFunctionApplication':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence[ast.className],
              inFunctionApplication: true
            });
            _op = operators[ast.className];
            _fn = generate(ast["function"], options);
            if (needsParensWhenOnLeft(ast["function"])) {
              _fn = parens(_fn);
            }
            if (ast.className === 'FunctionApplication' && ast["arguments"].length === 0 && (parentClassName !== 'UnaryExistsOp' && parentClassName !== 'SoakedMemberAccessOp')) {
              return "" + _fn + "!";
            } else {
              _argList = ast["arguments"].length ? " " + (generateArgs(ast["arguments"], options)) : '()';
              if (_fn_indented = _fn.match(/\n(\s+).*$/)) {
                matched = _fn_indented[0], spaces = _fn_indented[1];
                _argList = ((function() {
                  var _k, _len2, _ref11, _results;
                  _ref11 = _argList.split('\n');
                  _results = [];
                  for (_k = 0, _len2 = _ref11.length; _k < _len2; _k++) {
                    line = _ref11[_k];
                    _results.push(line.replace(new RegExp("^" + spaces), "" + TAB + spaces));
                  }
                  return _results;
                })()).join('\n');
              }
              return "" + _fn + _op + _argList;
            }
            break;
          case 'MemberAccessOp':
          case 'SoakedMemberAccessOp':
          case 'ProtoMemberAccessOp':
          case 'SoakedProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            newline = false;
            if (ast.expression.className === 'This') {
              _expr = '@';
              if (ast.className === 'MemberAccessOp') {
                _op = '';
              }
            } else {
              _expr = generate(ast.expression, options);
              reg = new RegExp("\\n\\s*\\." + ast.memberName + "$");
              if (ast.raw && ast.raw.match(reg)) {
                newline = true;
              } else {
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
            }
            if (newline) {
              return ("" + _expr + "\n") + indent("" + _op + ast.memberName);
            } else {
              return "" + _expr + _op + ast.memberName;
            }
            break;
          case 'DynamicMemberAccessOp':
          case 'SoakedDynamicMemberAccessOp':
          case 'DynamicProtoMemberAccessOp':
          case 'SoakedDynamicProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            options.precedence = 0;
            _indexingExpr = generate(ast.indexingExpr, options);
            if (ast.className === 'DynamicMemberAccessOp' && ((_ref11 = ast.indexingExpr.className) === 'String' || _ref11 === 'Int')) {
              return "" + _expr + _op + "." + _indexingExpr;
            } else {
              return "" + _expr + _op + "[" + _indexingExpr + "]";
            }
            break;
          case 'ConcatOp':
            _left = formatInterpolation(ast.left, options);
            _right = formatInterpolation(ast.right, options);
            return "\"" + _left + _right + "\"";
          case 'Rest':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _expr = generate(ast.expression, options);
            return "..." + _expr;
          case 'RegExp':
          case 'HeregExp':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _symbol = '//';
            _exprs = ast.className === 'RegExp' ? ast.data : formatInterpolation(ast.expression, options);
            _flags = '';
            _ref12 = ast.flags;
            for (flag in _ref12) {
              state = _ref12[flag];
              if (state) {
                _flags += flag;
              }
            }
            return "" + _symbol + _exprs + _symbol + _flags;
          case 'DoOp':
            exp = ast.expression;
            if (exp.className === 'Function' && (((exp.body != null) && exp.body.className !== 'Undefined') || exp.parameters.length)) {
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec,
                varsTotal: options.varsTotal.slice(0),
                varsFunc: []
              });
              _op = 'let ';
              parameters = (function() {
                var _k, _len2, _ref13, _results;
                _ref13 = exp.parameters;
                _results = [];
                for (_k = 0, _len2 = _ref13.length; _k < _len2; _k++) {
                  p = _ref13[_k];
                  _results.push(generate(p, options));
                }
                return _results;
              })();
              options.precedence = 0;
              if ((exp.body != null) && exp.body.className !== 'Undefined') {
                _body = generate(exp.body, options);
              } else {
                _body = 'void';
              }
              _paramList = parameters.length > 0 ? "" + (parameters.join(', ')) : '';
              return "" + _op + _paramList + "\n" + (indent(_body));
            } else {
              _op = 'do ';
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              return "" + _op + (generate(ast.expression, options));
            }
            break;
          case 'DefaultParam':
            return "" + (generate(ast.param, options)) + " = " + (generate(ast["default"], options));
          case 'JavaScript':
            return "``" + ast.data + "``";
          case 'Range':
          case 'Slice':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _by = '';
            if (ast.left && ast.right && ast.className === 'Range') {
              left = +(generate(ast.left, options));
              right = +(generate(ast.right, options));
              if (left === left && right === right) {
                if (left === right && !ast.isInclusive) {
                  _main = '[]';
                }
              } else {
                nonLiteral = true;
              }
            } else {
              '';

            }
            _mid = ast.isInclusive ? 'to' : 'til';
            _left = ast.left ? generate(ast.left, options) : '';
            _right = ast.right ? generate(ast.right, options) : '';
            _target = ast.expression ? generate(ast.expression, options) : '';
            if (ast.className === 'Slice') {
              if (_left == null) {
                _left = '0';
              }
              if (ast.left && ast.left.className === 'String') {
                _left = "+" + _left;
              }
              if (ast.right && ast.right.className === 'String') {
                _right = "+" + _right;
              }
              if (_right && _mid === 'to') {
                _right = "" + _right + " + 1 || 9e9";
              }
              _args = [_left, _right].join(', ');
              return "" + _target + ".slice(" + _args + ")";
            } else {
              if (_main) {
                return _main;
              } else if (nonLiteral && !_by) {
                firstRef = genVar(options);
                secondRef = genVar(options);
                return parens("if (" + firstRef + " = " + _left + ") > (" + secondRef + " = " + _right + ") then [" + firstRef + " " + _mid + " " + secondRef + " by -1] else [" + firstRef + " " + _mid + " " + secondRef + "]");
              } else {
                return "[" + _left + " " + _mid + " " + _right + _by + "]";
              }
            }
            break;
          case 'ForIn':
          case 'ForOf':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            type = ast.className === 'ForIn' ? 'in' : 'of';
            _own = ast.isOwn ? 'own ' : '';
            _firstAssg = ast.valAssignee ? generate(ast.valAssignee, options) : '';
            _secondAssg = ast.keyAssignee ? generate(ast.keyAssignee, options) : '';
            if (type === 'of') {
              _ref13 = [_secondAssg, _firstAssg], _firstAssg = _ref13[0], _secondAssg = _ref13[1];
            }
            if (_secondAssg) {
              _secondAssg = ", " + _secondAssg;
            }
            _target = type === 'in' && ast.target.className === 'Range' ? (_mid = ast.target.isInclusive ? 'to' : 'til', ast.target.left.className === 'Int' && ast.target.left.data === 0 ? _rangeLeft = '' : _rangeLeft = "from " + (generate(ast.target.left, options)) + " ", _rangeRight = generate(ast.target.right, options), "" + _rangeLeft + _mid + " " + _rangeRight) : "" + type + " " + (generate(ast.target, options));
            _step = !ast.step || ast.step.className === 'Int' && ast.step.data === 1 ? '' : " by " + (generate(ast.step, options));
            _filter = ast.filter ? " when " + (generate(ast.filter, options)) : '';
            comprehension = false;
            _body = ast.body ? (comprehension = ast.body.className === 'Block' ? 1 === ast.body.statements.length && 'For' !== ast.body.statements[0].className.slice(0, 3) : ((_ref14 = ast.body.className) !== 'Function' && _ref14 !== 'BoundFunction') && 'For' !== ast.body.className.slice(0, 3), comprehension && (comprehension = usedAsExpression), generate(ast.body, options)) : 'void';
            _mainPart = "for " + _own + _firstAssg + _secondAssg + " " + _target + _step + _filter;
            if (comprehension) {
              return "[" + _body + " " + _mainPart + "]";
            } else {
              _output = "" + _mainPart + "\n" + (indent(_body));
              if (usedAsExpression && parentClassName !== 'AssignOp') {
                return parens(_output);
              } else {
                return _output;
              }
            }
            break;
          case 'While':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _condition = generate(ast.condition, options);
            _body = ast.body ? generate(ast.body, options) : 'void';
            return "while " + _condition + "\n" + (indent(_body));
          case 'Switch':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _expression = ast.expression ? " " + (generate(ast.expression, options)) : '';
            output = "switch" + _expression + "\n";
            output += ((function() {
              var _k, _len2, _ref15, _results;
              _ref15 = ast.cases;
              _results = [];
              for (_k = 0, _len2 = _ref15.length; _k < _len2; _k++) {
                c = _ref15[_k];
                _results.push(generate(c, options));
              }
              return _results;
            })()).join('\n');
            if (ast.alternate) {
              output += "\ndefault\n" + (indent(generate(ast.alternate, options)));
            }
            return output;
          case 'SwitchCase':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _conditions = ast.conditions.length ? ((function() {
              var _k, _len2, _ref15, _results;
              _ref15 = ast.conditions;
              _results = [];
              for (_k = 0, _len2 = _ref15.length; _k < _len2; _k++) {
                c = _ref15[_k];
                _results.push(generate(c, options));
              }
              return _results;
            })()).join(', ') : generate(ast.conditions, options);
            return "case " + _conditions + "\n" + (indent(generate(ast.consequent, options)));
          case 'Return':
            return "return " + (generate(ast.expression, options));
          case 'Break':
            return 'break';
          case 'Continue':
            return 'continue';
          case 'Throw':
            return "throw " + (generate(ast.expression, options));
          case 'Try':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _body = ast.body ? generate(ast.body, options) : 'void';
            _catchAssg = ast.catchAssignee ? " " + (generate(ast.catchAssignee)) : '';
            _catchBody = ast.catchBody ? "\n" + (indent(generate(ast.catchBody, options))) : '';
            finallyBody = ast.finallyBody ? generate(ast.finallyBody, options) : '';
            _finally = finallyBody ? "\nfinally\n" + (indent(finallyBody)) : '';
            out = "try\n" + (indent(_body)) + "\ncatch" + _catchAssg + _catchBody + _finally;
            if (usedAsExpression) {
              return parens(out);
            } else {
              return out;
            }
            break;
          case 'Super':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _args = ast["arguments"].length ? "" + (generateArgs(ast["arguments"], options)) : '...';
            return "super " + _args;
          case 'Class':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _s = '';
            _nameAssg = ast.nameAssignee ? (_s = ' ', generate(ast.nameAssignee, options)) : '';
            _parent = ast.parent ? " extends " + (generate(ast.parent, options)) : '';
            _body = ast.body ? "\n" + (indent(generate(ast.body, options))) : '';
            if (((_ref15 = ast.nameAssignee) != null ? _ref15.className : void 0) === 'MemberAccessOp') {
              return "" + _nameAssg + " = class" + _parent + _body;
            } else {
              return "class" + _s + _nameAssg + _parent + _body;
            }
            break;
          case 'Constructor':
            _body = generate(ast.expression, options);
            if (ast.expression.className === 'Function') {
              return _body;
            } else {
              return "constructor$$: " + _body;
            }
            break;
          case 'ClassProtoAssignOp':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _assignee = generate(ast.assignee, options);
            _expression = generate(ast.expression, options);
            return "" + _assignee + ": " + _expression;
          default:
            throw new Error("Non-exhaustive patterns in case: " + ast.className);
        }
      })();
      if (needsParens) {
        return parens(src);
      } else {
        return src;
      }
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this.coffee2ls - (codegen = {}));

}).call(this);

});

require.define("/node_modules/LiveScript/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"./lib/livescript"}
});

require.define("/node_modules/LiveScript/lib/livescript.js",function(require,module,exports,__dirname,__filename,process,global){var lexer, parser;
lexer = require('./lexer');
parser = require('./parser').parser;
parser.yy = require('./ast');
parser.lexer = {
  lex: function(){
    var ref$, tag;
    ref$ = this.tokens[++this.pos] || [''], tag = ref$[0], this.yytext = ref$[1], this.yylineno = ref$[2];
    return tag;
  },
  setInput: function(it){
    this.pos = -1;
    return this.tokens = it;
  },
  upcomingInput: function(){
    return '';
  }
};
exports.VERSION = '1.1.0';
exports.compile = function(code, options){
  var e, that;
  try {
    return parser.parse(lexer.lex(code)).compileRoot(options);
  } catch (e$) {
    e = e$;
    if (that = options != null ? options.filename : void 8) {
      e.message += "\nat " + that;
    }
    throw e;
  }
};
exports.ast = function(it){
  return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
};
exports.tokens = lexer.lex;
exports.lex = function(it){
  return lexer.lex(it, {
    raw: true
  });
};
exports.run = function(code, options){
  var ref$;
  return Function(exports.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$)))();
};
exports.tokens.rewrite = lexer.rewrite;
importAll$(exports.ast, parser.yy);
if (require.extensions) {
  require('./node')(exports);
} else {
  exports.require = require;
  if ('' + this === '[object BackstagePass]') {
    this.EXPORTED_SYMBOLS = ['LiveScript'];
  }
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
});

require.define("/node_modules/LiveScript/lib/lexer.js",function(require,module,exports,__dirname,__filename,process,global){var string, TABS, unlines, enlines, enslash, reslash, camelize, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, KEYWORDS, ID, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, slice$ = [].slice;
exports.lex = function(code, options){
  return clone$(exports).tokenize(code || '', options || {});
};
exports.rewrite = function(it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
    it.shift();
  }
  return it;
};
exports.tokenize = function(code, o){
  var i, c, that;
  this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, ''));
  code = '\n' + code;
  this.tokens = [this.last = ['NEWLINE', '\n', 0]];
  this.line = ~-o.line;
  this.dents = [];
  this.closes = [];
  this.parens = [];
  i = 0;
  while (c = code.charAt(i)) {
    switch (c) {
    case ' ':
      i += this.doSpace(code, i);
      break;
    case '\n':
      i += this.doLine(code, i);
      break;
    case '\\':
      i += this.doBackslash(code, i);
      break;
    case '\'':
    case '"':
      i += this.doString(code, i, c);
      break;
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      i += this.doNumber(code, i);
      break;
    case '/':
      switch (code.charAt(i + 1)) {
      case '*':
        i += this.doComment(code, i);
        break;
      case '/':
        i += this.doHeregex(code, i);
        break;
      default:
        i += this.doRegex(code, i) || this.doLiteral(code, i);
      }
      break;
    case '`':
      if ('`' === code.charAt(i + 1)) {
        i += this.doJS(code, i);
      } else {
        i += this.doLiteral(code, i);
      }
      break;
    default:
      i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
    }
  }
  this.dedent(this.dent);
  if (that = this.closes.pop()) {
    this.carp("missing `" + that + "`");
  }
  if (this.inter) {
    this.rest == null && this.carp('unterminated interpolation');
  } else {
    this.last.spaced = true;
    this.newline();
  }
  o.raw || this.rewrite();
  return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
  if (this.hasOwn.call(this.identifiers, camel) && this.identifiers[camel] !== id) {
    throw new ReferenceError("Inconsistent use of " + camel + " as " + id + " on line " + (-~this.line));
  } else {
    return this.identifiers[camel] = id;
  }
};
exports.doID = function(code, index){
  var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
  input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
  if (!input) {
    return 0;
  }
  id = camelize(regexMatch[1]);
  if (/-/.test(regexMatch[1])) {
    this.checkConsistency(id, regexMatch[1]);
  }
  if (NONASCII.test(id)) {
    try {
      Function("var " + id);
    } catch (e$) {
      e = e$;
      this.carp("invalid identifier \"" + id + "\"");
    }
  }
  last = this.last;
  if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
    this.token('ID', in$(id, KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
    if (regexMatch[2]) {
      this.token(':', ':');
    }
    return input.length;
  }
  switch (id) {
  case 'true':
  case 'false':
  case 'on':
  case 'off':
  case 'yes':
  case 'no':
  case 'null':
  case 'void':
  case 'undefined':
  case 'arguments':
  case 'debugger':
    tag = 'LITERAL';
    break;
  case 'new':
  case 'do':
  case 'typeof':
  case 'delete':
    tag = 'UNARY';
    break;
  case 'return':
  case 'throw':
    tag = 'HURL';
    break;
  case 'break':
  case 'continue':
    tag = 'JUMP';
    break;
  case 'this':
  case 'eval':
  case 'super':
    return this.token('LITERAL', id, true).length;
  case 'for':
    this.seenFor = true;
    // fallthrough
  case 'then':
    this.wantBy = false;
    break;
  case 'catch':
  case 'function':
    id = '';
    break;
  case 'where':
    break;
  case 'in':
  case 'of':
    if (this.seenFor) {
      this.seenFor = false;
      if (id === 'in') {
        this.wantBy = true;
        id = '';
        if (last[0] === 'ID' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) == ',' || ref$ == ']' || ref$ == '}')) {
          id = this.tokens.pop()[1];
          if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
            this.tokens.pop();
          }
        }
      }
      break;
    }
    // fallthrough
  case 'instanceof':
    if (last[1] === '!') {
      id = this.tokens.pop()[1] + id;
    }
    tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';
    break;
  case 'not':
    if (last.alias && last[1] === '===') {
      return last[1] = '!==', 3;
    }
    tag = 'UNARY';
    id = '!';
    break;
  case 'and':
  case 'or':
  case 'xor':
  case 'is':
  case 'isnt':
    this.unline();
    tag = id == 'is' || id == 'isnt' ? 'COMPARE' : 'LOGIC';
    if (last[0] === '(') {
      tag = 'BIOP';
    }
    this.token(tag, (function(){
      switch (id) {
      case 'is':
        return '===';
      case 'isnt':
        return '!==';
      case 'or':
        return '||';
      case 'and':
        return '&&';
      case 'xor':
        return 'xor';
      }
    }()));
    this.last.alias = true;
    return id.length;
  case 'unless':
    tag = 'IF';
    break;
  case 'until':
    tag = 'WHILE';
    break;
  case 'import':
    if (last[0] === '(') {
      id = '<<<';
      tag = 'BIOP';
    } else {
      if (able(this.tokens)) {
        id = '<<<';
      } else {
        tag = 'DECL';
      }
    }
    break;
  case 'export':
  case 'const':
  case 'var':
    tag = 'DECL';
    break;
  case 'with':
    tag = (function(){
      switch (false) {
      case !able(this.tokens):
        return 'CLONEPORT';
      case last[0] !== '(':
        return 'BIOP';
      default:
        return 'WITH';
      }
    }.call(this));
    break;
  case 'when':
    tag = 'CASE';
    // fallthrough
  case 'case':
    if (this.doCase()) {
      return input.length;
    }
    break;
  case 'match':
    tag = 'SWITCH';
    break;
  case 'loop':
    this.token('WHILE', id);
    this.token('LITERAL', 'true');
    return input.length;
  default:
    if (in$(id, KEYWORDS_SHARED)) {
      break;
    }
    if (in$(id, KEYWORDS_UNUSED)) {
      this.carp("reserved word \"" + id + "\"");
    }
    if (!last[1] && ((ref$ = last[0]) == 'FUNCTION' || ref$ == 'LABEL')) {
      last[1] = id;
      last.spaced = false;
      return input.length;
    }
    tag = 'ID';
    switch (id) {
    case 'own':
      if (last[0] === 'FOR') {
        tag = 'OWN';
      }
      break;
    case 'otherwise':
      if ((ref$ = last[0]) == 'CASE' || ref$ == '|') {
        last[0] = 'DEFAULT';
        return id.length;
      }
      break;
    case 'all':
      if (that = last[1] === '<<<' && '<' || last[1] === 'import' && 'All') {
        last[1] += that;
        return 3;
      }
      break;
    case 'from':
      this.forange() && (tag = 'FROM');
      break;
    case 'to':
    case 'til':
      this.forange() && this.tokens.push(['FROM', '', this.line], ['STRNUM', '0', this.line]);
      if (this.seenFrom) {
        this.seenFrom = false;
        this.wantBy = true;
        tag = 'TO';
      } else if (!last.callable && last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === '[') {
        last[0] = 'RANGE';
        last.op = id;
        return id.length;
      } else if (in$(']', this.closes)) {
        this.token('TO', id);
        return id.length;
      }
      break;
    case 'by':
      if (last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === 'RANGE' && (ref$ = this.tokens)[ref$.length - 3][0] === '[') {
        tag = 'RANGE_BY';
      } else if (in$(']', this.closes)) {
        tag = 'BY';
      } else {
        this.wantBy && (this.wantBy = !(tag = 'BY'));
      }
      break;
    case 'ever':
      if (last[0] === 'FOR') {
        this.seenFor = false;
        last[0] = 'WHILE';
        tag = 'LITERAL';
        id = 'true';
      }
    }
  }
  tag || (tag = regexMatch[1].toUpperCase());
  if ((tag == 'COMPARE' || tag == 'LOGIC' || tag == 'RELATION') && last[0] === '(') {
    tag = tag === 'RELATION' ? 'BIOPR' : 'BIOP';
  }
  if (tag == 'RELATION' || tag == 'THEN' || tag == 'ELSE' || tag == 'CASE' || tag == 'DEFAULT' || tag == 'CATCH' || tag == 'FINALLY' || tag == 'IN' || tag == 'OF' || tag == 'FROM' || tag == 'TO' || tag == 'BY' || tag == 'EXTENDS' || tag == 'IMPLEMENTS' || tag == 'WHERE') {
    this.unline();
  }
  this.token(tag, id);
  return input.length;
};
exports.doNumber = function(code, lastIndex){
  var input, regexMatch, last, radix, num, rnum, ref$;
  NUMBER.lastIndex = lastIndex;
  if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
    return 0;
  }
  last = this.last;
  if (regexMatch[5] && (last[0] === 'DOT' || this.adi())) {
    this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));
    return regexMatch[4].length;
  }
  if (radix = regexMatch[1]) {
    num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);
    if (radix > 36 || radix < 2) {
      this.carp("invalid number base " + radix + " (with number " + rnum + "), base must be from 2 to 36");
    }
    if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
      this.carp("invalid number " + rnum + " in base " + radix);
    }
    num += '';
  } else {
    num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
    if (regexMatch[3] && num.charAt() === '0' && ((ref$ = num.charAt(1)) != '' && ref$ != '.')) {
      this.carp("deprecated octal literal " + regexMatch[4]);
    }
  }
  if (!last.spaced && last[0] === '+-') {
    last[0] = 'STRNUM';
    last[1] += num;
    return input.length;
  }
  this.strnum(num);
  return input.length;
};
exports.doString = function(code, index, q){
  var parts, str;
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === '"') {
    parts = this.interpolate(code, index, q);
    this.addInterpolated(parts, unlines);
    return 1 + parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
  var end, raw, doc, parts, tabs, i$, len$, i, t;
  if (q === '\'') {
    ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
    raw = code.slice(index + 3, end);
    doc = raw.replace(LASTDENT, '');
    this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
    return this.countLines(raw).length + 6;
  }
  parts = this.interpolate(code, index, q + q + q);
  tabs = heretabs(code.slice(index + 3, index + parts.size).replace(LASTDENT, ''));
  for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === 'S') {
      if (i + 1 === parts.length) {
        t[1] = t[1].replace(LASTDENT, '');
      }
      t[1] = detab(t[1], tabs);
      if (i === 0) {
        t[1] = lchomp(t[1]);
      }
    }
  }
  this.addInterpolated(parts, enlines);
  return 3 + parts.size;
};
exports.doComment = function(code, index){
  var comment, end, ref$;
  comment = ~(end = code.indexOf('*/', index + 2))
    ? code.slice(index, end + 2)
    : code.slice(index) + '*/';
  if ((ref$ = this.last[0]) == 'NEWLINE' || ref$ == 'INDENT' || ref$ == 'THEN') {
    this.token('COMMENT', detab(comment, this.dent));
    this.token('NEWLINE', '\n');
  }
  return this.countLines(comment).length;
};
exports.doJS = function(code, lastIndex){
  var js, ref$;
  JSTOKEN.lastIndex = lastIndex;
  js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');
  this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
  return this.countLines(js).length;
};
exports.doRegex = function(code, index){
  var divisible, ref$, input, body, flag;
  if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
    if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) == ' ' || ref$ == '=')) {
      return 0;
    }
  }
  ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
  if (input) {
    this.regex(body, flag);
  } else if (!divisible && this.last[0] !== '(') {
    this.carp('unterminated regex');
  }
  return input.length;
};
exports.doHeregex = function(code, index){
  var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
  tokens = this.tokens, last = this.last;
  parts = this.interpolate(code, index, '//');
  rest = code.slice(index + 2 + parts.size);
  flag = this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
  if (parts[1]) {
    if (flag === '$') {
      this.adi();
      this.token('(', '"');
    } else {
      tokens.push(['ID', 'RegExp', last[2]], ['CALL(', '', last[2]]);
      if (flag === '?') {
        for (i$ = parts.length - 1; i$ >= 0; --i$) {
          i = i$;
          t = parts[i$];
          if (t[0] === 'TOKENS') {
            dynaflag = parts.splice(i, 1)[0][1];
            break;
          }
        }
      }
    }
    for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
      i = i$;
      t = parts[i$];
      if (t[0] === 'TOKENS') {
        tokens.push.apply(tokens, t[1]);
      } else {
        val = t[1].replace(HEREGEX_OMIT, '');
        if (one && !val) {
          continue;
        }
        one = tokens.push((t[0] = 'STRNUM', t[1] = this.string('\'', enslash(val)), t));
      }
      tokens.push(['+-', '+', tokens[tokens.length - 1][2]]);
    }
    --tokens.length;
    if (dynaflag || flag >= 'g') {
      this.token(',', ',');
      if (dynaflag) {
        tokens.push.apply(tokens, dynaflag);
      } else {
        this.token('STRNUM', "'" + flag + "'");
      }
    }
    this.token(flag === '$' ? ')' : ')CALL', '');
  } else {
    this.regex(reslash(parts[0][1].replace(HEREGEX_OMIT, '')), flag);
  }
  return 2 + parts.size + flag.length;
};
exports.doBackslash = function(code, lastIndex){
  var ref$, input, word;
  BSTOKEN.lastIndex = lastIndex;
  ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
  if (word) {
    this.strnum(this.string('\'', word));
  } else {
    this.countLines(input);
  }
  return input.length;
};
exports.doLine = function(code, index){
  var ref$, input, tabs, length, last, that, delta, tag, val;
  ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
  length = this.countLines(input).length;
  last = this.last;
  last.eol = true;
  last.spaced = true;
  if (index + length >= code.length) {
    return length;
  }
  if (that = tabs && (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {
    this.carp("contaminated indent " + escape(that));
  }
  if (0 > (delta = tabs.length - this.dent)) {
    this.dedent(-delta);
    this.newline();
  } else {
    tag = last[0], val = last[1];
    if (tag === 'ASSIGN' && ((ref$ = val + '') != '=' && ref$ != ':=' && ref$ != '+=') || (tag == '+-' || tag == 'PIPE' || tag == 'BACKPIPE' || tag == 'DOT' || tag == 'LOGIC' || tag == 'MATH' || tag == 'COMPARE' || tag == 'RELATION' || tag == 'SHIFT' || tag == 'IN' || tag == 'OF' || tag == 'TO' || tag == 'BY' || tag == 'FROM' || tag == 'EXTENDS' || tag == 'IMPLEMENTS')) {
      return length;
    }
    if (delta) {
      this.indent(delta);
    } else {
      this.newline();
    }
  }
  this.wantBy = false;
  return length;
};
exports.doSpace = function(code, lastIndex){
  var input;
  SPACE.lastIndex = lastIndex;
  if (input = SPACE.exec(code)[0]) {
    this.last.spaced = true;
  }
  return input.length;
};
exports.doCase = function(){
  var ref$, ref1$;
  if (((ref$ = this.last[0]) == 'ASSIGN' || ref$ == '->' || ref$ == ':') || (this.last[0] === 'INDENT' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) == 'ASSIGN' || ref$ == '->' || ref$ == ':'))) {
    this.token('SWITCH', 'switch');
    this.line++;
    return this.token('CASE', 'case');
  }
};
exports.doLiteral = function(code, index){
  var sym, tag, val, ref$, ref1$, arrow, i$, i, t, that, up, this$ = this;
  if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
    return 0;
  }
  switch (tag = val = sym) {
  case '=>':
    tag = 'THEN';
    this.unline();
    break;
  case '|':
    tag = 'CASE';
    if (this.doCase()) {
      return sym.length;
    }
    break;
  case '|>':
    tag = 'PIPE';
    break;
  case '`':
    tag = 'BACKTICK';
    break;
  case '<<':
  case '>>':
    tag = 'COMPOSE';
    break;
  case '<|':
    tag = 'BACKPIPE';
    break;
  case '+':
  case '-':
    tag = '+-';
    break;
  case '&&':
  case '||':
    tag = 'LOGIC';
    break;
  case '.&.':
  case '.|.':
  case '.^.':
    tag = 'BITWISE';
    break;
  case '^^':
    tag = 'CLONE';
    break;
  case '**':
  case '^':
    tag = 'POWER';
    break;
  case '?':
  case '!?':
    if (this.last[0] === '(') {
      createItFunc();
    } else {
      if (this.last.spaced) {
        tag = 'LOGIC';
      }
    }
    break;
  case '/':
  case '%':
  case '%':
    tag = 'MATH';
    break;
  case '+++':
    tag = 'CONCAT';
    break;
  case '++':
  case '--':
    tag = 'CREMENT';
    break;
  case '<<<':
  case '<<<<':
    tag = 'IMPORT';
    break;
  case ';':
    tag = 'NEWLINE';
    this.wantBy = false;
    break;
  case '..':
    if (able(this.tokens)) {
      this.token('CASCADE', '..');
    }
    this.token('LITERAL', '..', true);
    return 2;
  case '.':
    if (this.last[0] === '(') {
      createItFunc();
    }
    if (this.last[1] === '?') {
      this.last[0] = '?';
    }
    tag = 'DOT';
    break;
  case ',':
    switch (this.last[0]) {
    case ',':
    case '[':
    case '(':
    case 'CALL(':
      this.token('LITERAL', 'void');
      break;
    case 'FOR':
    case 'OWN':
      this.token('ID', '');
    }
    break;
  case '!=':
  case '~=':
    if (!(able(this.tokens) || ((ref$ = this.last[0]) == '(' || ref$ == 'CREMENT'))) {
      this.tokens.push(val === '!='
        ? ['UNARY', '!', this.line]
        : ['UNARY', '~', this.line], ['ASSIGN', '=', this.line]);
      return 2;
    }
    // fallthrough
  case '!~=':
  case '==':
    val = (function(){
      switch (val) {
      case '~=':
        return '==';
      case '!~=':
        return '!=';
      case '==':
        return '===';
      case '!=':
        return '!==';
      }
    }());
    tag = 'COMPARE';
    break;
  case '===':
  case '!==':
    val += '=';
    // fallthrough
  case '<':
  case '>':
  case '<=':
  case '>=':
  case '<==':
  case '>==':
  case '>>=':
  case '<<=':
    tag = 'COMPARE';
    break;
  case '.<<.':
  case '.>>.':
  case '.>>>.':
  case '<?':
  case '>?':
    tag = 'SHIFT';
    break;
  case '(':
    if (!(((ref$ = this.last[0]) == 'FUNCTION' || ref$ == 'LET') || this.able(true) || this.last[1] === '.@')) {
      this.token('(', '(');
      this.closes.push(')');
      this.parens.push(this.last);
      return 1;
    }
    tag = 'CALL(';
    this.closes.push(')CALL');
    break;
  case '[':
  case '{':
    this.adi();
    this.closes.push(']}'.charAt(val === '{'));
    break;
  case '}':
    if (this.inter && val !== (ref$ = this.closes)[ref$.length - 1]) {
      this.rest = code.slice(index + 1);
      return 9e9;
    }
    // fallthrough
  case ']':
  case ')':
    if (tag === ')' && ((ref$ = this.last[0]) == '+-' || ref$ == 'COMPARE' || ref$ == 'LOGIC' || ref$ == 'MATH' || ref$ == 'POWER' || ref$ == 'SHIFT' || ref$ == 'BITWISE' || ref$ == 'CONCAT' || ref$ == 'COMPOSE' || ref$ == 'RELATION' || ref$ == 'PIPE' || ref$ == 'BACKPIPE' || ref$ == 'IMPORT' || ref$ == 'CLONEPORT' || ref$ == 'ASSIGN')) {
      (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
        switch (this.last[0]) {
        case 'RELATION':
          return 'BIOPR';
        case 'PIPE':
          this.parameters(false, -1);
          return 'BIOPP';
        default:
          return 'BIOP';
        }
      }.call(this));
    }
    if (')' === (tag = val = this.pair(val))) {
      this.lpar = this.parens.pop();
    }
    break;
  case '=':
  case ':':
    if (this.last[0] === 'UNARY' && this.last[1] === '!' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][1]) == '.@' || ref$ == 'this')) {
      this.tokens.pop();
      this.token('CALL(', '(');
      this.token(')CALL', ')');
    } else if (this.last[0] === ')CALL') {
      if (typeof console != 'undefined' && console !== null) {
        console.warn("WARNING on line " + this.line + ": `func(x) = ...` type functions are deprecated and will be removed in a future LiveScript release. Please use long arrows --> for your curried functions instead.");
      }
      if (val === '=') {
        tag = 'ASSIGN';
      }
      arrow = '-->';
      this.tokens.pop();
      this.token(')PARAM', ')');
      for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {
        i = i$;
        t = ref$[i$];
        if (t[0] === 'CALL(') {
          break;
        }
      }
      this.tokens.splice(i, 1, [tag, val, this.line], ['PARAM(', '(', this.line]);
      if ((ref$ = (ref1$ = this.tokens[i - 2]) != null ? ref1$[1] : void 8) == '.~' || ref$ == '~') {
        this.tokens.splice(i - 2, 1);
        --i;
        if (able(this.tokens.slice(0, i - 1))) {
          this.tokens.splice(i - 2 + 1, 0, ['DOT', '.', this.line]);
          ++i;
        }
        arrow = '~~>';
      }
      this.token('->', arrow);
      return sym.length;
    }
    if (val === ':') {
      switch (this.last[0]) {
      case 'ID':
      case 'STRNUM':
      case ')':
        break;
      case '...':
        this.last[0] = 'STRNUM';
        break;
      default:
        tag = 'LABEL';
        val = '';
      }
      this.token(tag, val);
      return sym.length;
    }
    // fallthrough
  case ':=':
  case '+=':
  case '-=':
  case '*=':
  case '/=':
  case '%=':
  case '%=':
  case '<?=':
  case '>?=':
  case '**=':
  case '^=':
  case '.&.=':
  case '.|.=':
  case '.^.=':
  case '.<<.=':
  case '.>>.=':
  case '.>>>.=':
    if (this.last[1] === '.' || this.last[0] === '?' && this.adi()) {
      this.last[1] += val;
      return val.length;
    }
    if (this.last[0] === 'LOGIC') {
      (val = Object(val)).logic = this.tokens.pop()[1];
    } else if ((val == '+=' || val == '-=') && !able(this.tokens) && ((ref$ = this.last[0]) != '+-' && ref$ != 'UNARY' && ref$ != 'LABEL')) {
      this.token('UNARY', val.charAt());
      val = '=';
    }
    tag = 'ASSIGN';
    break;
  case '::=':
    this.token('DOT', '.');
    this.token('ID', 'prototype');
    this.token('IMPORT', '<<');
    return sym.length;
  case '*':
    if (that = ((ref$ = this.last[0]) == 'NEWLINE' || ref$ == 'INDENT' || ref$ == 'THEN' || ref$ == '=>') && (INLINEDENT.lastIndex = index + 1, INLINEDENT).exec(code)[0].length) {
      this.tokens.push(['LITERAL', 'void', this.line], ['ASSIGN', '=', this.line]);
      this.indent(index + that - 1 - this.dent - code.lastIndexOf('\n', index - 1));
      return that;
    }
    tag = able(this.tokens) || this.last[0] === 'CREMENT' && able(this.tokens, this.tokens.length - 1) || this.last[0] === '(' ? 'MATH' : 'STRNUM';
    break;
  case '@':
    this.adi();
    if (this.last[0] === 'DOT' && this.last[1] === '.' && (ref$ = this.tokens)[ref$.length - 2][0] === 'ID' && (ref$ = this.tokens)[ref$.length - 2][1] === 'constructor') {
      this.tokens.pop();
      this.tokens.pop();
      this.token('LITERAL', 'this', true);
      this.adi();
      this.token('ID', 'constructor', true);
    } else {
      this.token('LITERAL', 'this', true);
    }
    return 1;
  case '@@':
    this.adi();
    this.token('ID', 'constructor', true);
    return 2;
  case '&':
    this.token('LITERAL', 'arguments');
    return 1;
  case '!':
    switch (false) {
    default:
      if (!this.last.spaced) {
        if (this.last[1] === 'require') {
          this.last[0] = 'REQUIRE';
          this.last[1] = 'require!';
        } else if (able(this.tokens, null, true)) {
          this.token('CALL(', '!');
          this.token(')CALL', ')');
        } else if (this.last[1] === 'typeof') {
          this.last[1] = 'classof';
        } else if (this.last[1] === 'delete') {
          this.last[1] = 'jsdelete';
        } else {
          break;
        }
        return 1;
      }
    }
    tag = 'UNARY';
    break;
  case '&':
    if (!able(this.tokens)) {
      tag = 'LITERAL';
    }
    break;
  case '|':
    tag = 'BITWISE';
    break;
  case '~':
    if (this.dotcat(val)) {
      return 1;
    }
    tag = 'UNARY';
    break;
  case '->':
  case '~>':
  case '-->':
  case '~~>':
    up = '->';
    // fallthrough
  case '<-':
  case '<~':
  case '<--':
  case '<~~':
    this.parameters(tag = up || '<-');
    break;
  case '::':
    this.adi();
    val = 'prototype';
    tag = 'ID';
    break;
  default:
    switch (val.charAt(0)) {
    case '(':
      this.token('CALL(', '(');
      tag = ')CALL';
      val = ')';
      break;
    case '<':
      if (val.length < 4) {
        this.carp('unterminated words');
      }
      this.token('WORDS', val.slice(2, -2), this.adi());
      return val.length;
    }
  }
  if ((tag == '+-' || tag == 'COMPARE' || tag == 'LOGIC' || tag == 'MATH' || tag == 'POWER' || tag == 'SHIFT' || tag == 'BITWISE' || tag == 'CONCAT' || tag == 'COMPOSE' || tag == 'RELATION' || tag == 'PIPE' || tag == 'BACKPIPE' || tag == 'IMPORT') && this.last[0] === '(') {
    tag = tag === 'BACKPIPE' ? 'BIOPBP' : 'BIOP';
  }
  if (tag == ',' || tag == 'CASE' || tag == 'PIPE' || tag == 'BACKPIPE' || tag == 'DOT' || tag == 'LOGIC' || tag == 'COMPARE' || tag == 'MATH' || tag == 'POWER' || tag == 'IMPORT' || tag == 'SHIFT' || tag == 'BITWISE') {
    this.unline();
  }
  function createItFunc(){
    this$.token('PARAM(', '(');
    this$.token(')PARAM', ')');
    this$.token('->', '->');
    return this$.token('ID', 'it');
  }
  this.token(tag, val);
  return sym.length;
};
exports.token = function(tag, value, callable){
  this.tokens.push(this.last = [tag, value, this.line]);
  if (callable) {
    this.last.callable = true;
  }
  return value;
};
exports.indent = function(delta){
  this.dent += delta;
  this.dents.push(this.token('INDENT', delta));
  this.closes.push('DEDENT');
};
exports.dedent = function(debt){
  var dent;
  this.dent -= debt;
  while (debt > 0 && (dent = this.dents.pop())) {
    if (debt < dent && !this.inter) {
      this.carp("unmatched dedent (" + debt + " for " + dent + ")");
    }
    this.pair('DEDENT');
    debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;
  }
};
exports.newline = function(){
  var ref$;
  this.last[1] === '\n' || this.tokens.push(this.last = (ref$ = ['NEWLINE', '\n', this.line], ref$.spaced = true, ref$));
};
exports.unline = function(){
  var ref$;
  if (!this.tokens[1]) {
    return;
  }
  switch (this.last[0]) {
  case 'INDENT':
    (ref$ = this.dents)[ref$.length - 1] += '';
    // fallthrough
  case 'NEWLINE':
    this.tokens.length--;
  }
};
exports.parameters = function(arrow, offset){
  var i$, ref$, i, t, ref1$;
  if (this.last[0] === ')' && ')' === this.last[1]) {
    this.lpar[0] = 'PARAM(';
    this.last[0] = ')PARAM';
    return;
  }
  if (arrow === '->') {
    this.token('PARAM(', '');
  } else {
    for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {
      i = i$;
      t = ref$[i$];
      if ((ref1$ = t[0]) == 'NEWLINE' || ref1$ == 'INDENT' || ref1$ == 'THEN' || ref1$ == '=>' || ref1$ == '(') {
        break;
      }
    }
    this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2]]);
  }
  if (offset) {
    this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2]]);
  } else {
    this.token(')PARAM', '');
  }
};
exports.interpolate = function(str, idx, end){
  var parts, end0, pos, i, ch, c1, id, stringified, length, tag, e, delta, nested, clone, ref$;
  parts = [];
  end0 = end.charAt(0);
  pos = 0;
  i = -1;
  str = str.slice(idx + end.length);
  while (ch = str.charAt(++i)) {
    switch (ch) {
    case end0:
      if (end !== str.slice(i, i + end.length)) {
        continue;
      }
      parts.push(['S', this.countLines(str.slice(0, i)), this.line]);
      return parts.size = pos + i + end.length, parts;
    case '#':
      c1 = str.charAt(i + 1);
      id = in$(c1, ['@']) && c1 || (ID.lastIndex = i + 1, ID).exec(str)[1];
      if (!(id || c1 === '{')) {
        continue;
      }
      break;
    case '\\':
      ++i;
      // fallthrough
    default:
      continue;
    }
    if (i || nested && !stringified) {
      stringified = parts.push(['S', this.countLines(str.slice(0, i)), this.line]);
    }
    if (id) {
      length = id.length;
      if (id === '@') {
        id = 'this';
      }
      if (in$(id, ['this'])) {
        tag = 'LITERAL';
      } else {
        id = camelize(id);
        try {
          Function("'use strict'; var " + id);
        } catch (e$) {
          e = e$;
          this.carp("invalid variable interpolation \"" + id + "\"");
        }
        tag = 'ID';
      }
      str = str.slice(delta = i + 1 + length);
      parts.push(['TOKENS', nested = [[tag, id, this.line]]]);
    } else {
      clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
      nested = clone.tokenize(str.slice(i + 2), {
        line: this.line,
        raw: true
      });
      delta = str.length - clone.rest.length;
      str = clone.rest, this.line = clone.line;
      while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
        nested.shift();
      }
      if (nested.length) {
        nested.unshift(['(', '(', nested[0][2]]);
        nested.push([')', ')', this.line]);
        parts.push(['TOKENS', nested]);
      }
    }
    pos += delta;
    i = -1;
  }
  this.carp("missing `" + end + "`");
};
exports.addInterpolated = function(parts, nlines){
  var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
  if (!parts[1]) {
    return this.strnum(nlines(this.string('"', parts[0][1])));
  }
  tokens = this.tokens, last = this.last;
  ref$ = !last.spaced && last[1] === '%'
    ? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])
    : ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];
  callable = this.adi();
  tokens.push([left, '"', last[2]]);
  for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === 'TOKENS') {
      tokens.push.apply(tokens, t[1]);
    } else {
      if (i > 1 && !t[1]) {
        continue;
      }
      tokens.push(['STRNUM', nlines(this.string('"', t[1])), t[2]]);
    }
    tokens.push(joint.concat(tokens[tokens.length - 1][2]));
  }
  --tokens.length;
  this.token(right, '', callable);
};
exports.strnum = function(it){
  this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');
};
exports.regex = function(body, flag){
  var e;
  try {
    RegExp(body);
  } catch (e$) {
    e = e$;
    this.carp(e.message);
  }
  if (flag === '$') {
    return this.strnum(this.string('\'', enslash(body)));
  }
  return this.token('LITERAL', "/" + (body || '(?:)') + "/" + this.validate(flag));
};
exports.adi = function(){
  if (this.last.spaced) {
    return;
  }
  if (this.last[0] === '!?') {
    this.last[0] = 'CALL(';
    this.token(')CALL', '');
    this.token('?', '?');
  } else if (!able(this.tokens)) {
    return;
  }
  return this.token('DOT', '.');
};
exports.dotcat = function(it){
  if (this.last[1] === '.' || this.adi()) {
    return this.last[1] += it;
  }
};
exports.pair = function(it){
  var wanted, ref$;
  if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted && it === ')')) {
    if ('DEDENT' !== wanted) {
      this.carp("unmatched `" + it + "`");
    }
    this.dedent((ref$ = this.dents)[ref$.length - 1]);
    return this.pair(it);
  }
  this.unline();
  return this.closes.pop();
};
exports.able = function(call){
  return !this.last.spaced && able(this.tokens, null, call);
};
exports.countLines = function(it){
  var pos;
  while (pos = 1 + it.indexOf('\n', pos)) {
    ++this.line;
  }
  return it;
};
exports.forange = function(){
  var ref$, ref1$, ref2$;
  if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) == 'NEWLINE' || ref2$ == 'INDENT')]) != null ? ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {
    return this.seenFor = false, this.seenFrom = true, this;
  }
};
exports.validate = function(flag){
  var that;
  if (that = flag && /(.).*\1/.exec(flag)) {
    this.carp("duplicate regex flag `" + that[1] + "`");
  }
  return flag;
};
exports.carp = function(it){
  carp(it, this.line);
};
exports.string = function(q, body){
  return string(q, body, this.line);
};
function carp(msg, lno){
  throw SyntaxError(msg + " on line " + (-~lno));
}
function able(tokens, i, call){
  var token, tag;
  i == null && (i = tokens.length);
  tag = (token = tokens[i - 1])[0];
  return (tag == 'ID' || tag == ']' || tag == '?') || (call
    ? token.callable || (tag == ')' || tag == ')CALL' || tag == 'BIOPBP') && token[1]
    : tag == '}' || tag == ')' || tag == ')CALL' || tag == 'STRNUM' || tag == 'LITERAL' || tag == 'WORDS');
}
string = (function(re){
  return function(q, body, lno){
    body = body.replace(re, function(it, oct, xu, rest){
      if (it == q || it == '\\') {
        return '\\' + it;
      }
      if (oct) {
        return '\\x' + (0x100 + parseInt(oct, 8)).toString(16).slice(1);
      }
      if (xu) {
        carp('malformed character escape sequence', lno);
      }
      if (!rest || q === rest) {
        return it;
      } else {
        return rest;
      }
    });
    return q + body + q;
  };
}.call(this, /['"]|\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|([xu])|[\\0bfnrtv]|[^\n\S]|([\w\W]))?/g));
function heretabs(doc){
  var dent, that, ref$;
  dent = 0 / 0;
  while (that = TABS.exec(doc)) {
    dent <= (ref$ = that[0].length - 1) || (dent = ref$);
  }
  return dent;
}
TABS = /\n(?!$)[^\n\S]*/mg;
function detab(str, len){
  if (len) {
    return str.replace(detab[len] || (detab[len] = RegExp('\\n[^\\n\\S]{1,' + len + '}', 'g')), '\n');
  } else {
    return str;
  }
}
function replacer(re, to){
  return function(it){
    return it.replace(re, to);
  };
}
unlines = replacer(/\n[^\n\S]*/g, '');
enlines = replacer(/\n/g, '\\n');
enslash = replacer(/\\/g, '\\\\');
reslash = replacer(/(\\.)|\//g, function(){
  return arguments[1] || '\\/';
});
camelize = replacer(/-[a-z]/ig, function(it){
  return it.charAt(1).toUpperCase();
});
function lchomp(it){
  return it.slice(1 + it.lastIndexOf('\n', 0));
}
function decode(val, lno){
  if (!isNaN(val)) {
    return [+val];
  }
  val = val.length > 8
    ? 'ng'
    : Function('return' + val)();
  val.length === 1 || carp('bad string in range', lno);
  return [val.charCodeAt(), true];
}
function uxxxx(it){
  return '"\\u' + ('000' + it.toString(16)).slice(-4) + '"';
}
character = typeof JSON == 'undefined' || JSON === null
  ? uxxxx
  : function(it){
    switch (it) {
    case 0x2028:
    case 0x2029:
      return uxxxx(it);
    default:
      return JSON.stringify(String.fromCharCode(it));
    }
  };
function firstPass(tokens){
  var prev, i, token, tag, val, line, parens, i$, j;
  prev = ['NEWLINE', '\n', 0];
  i = 0;
  while (token = tokens[++i]) {
    tag = token[0], val = token[1], line = token[2];
    switch (false) {
    case !(tag === 'DOT' && prev[0] === ']' && tokens[i - 2][0] === '[' && tokens[i - 3][0] === 'DOT'):
      tokens.splice(i - 2, 3);
      tokens[i - 3][1] = '[]';
      break;
    case !(tag === 'DOT' && prev[0] === '}' && tokens[i - 2][0] === '{' && tokens[i - 3][0] === 'DOT'):
      tokens.splice(i - 2, 3);
      tokens[i - 3][1] = '{}';
      break;
    case !(tag === 'CASCADE' && val === '..'):
      if (tokens[i + 2][0] !== 'DOT') {
        tokens.splice(i, 1);
      }
      break;
    case !(val === '.' && token.spaced && prev.spaced):
      tokens[i] = ['COMPOSE', '<<', line];
      break;
    case !(tag === ')' && prev[1] === '.'):
      tokens.splice(i, 0, ['[', '[', line], ['ID', 'it', line], [']', ']', line]);
      parens = 1;
      LOOP: for (i$ = i; i$ >= 0; --i$) {
        j = i$;
        switch (tokens[j][0]) {
        case ')':
          ++parens;
          break;
        case '(':
          if (--parens === 0) {
            tokens.splice(j + 1, 0, ['PARAM(', '(', line], ['ID', 'it', line], [')PARAM', ')', line], ['->', '->', line]);
            break LOOP;
          }
        }
      }
    }
    prev = token;
    continue;
  }
}
function rewriteBlockless(tokens){
  var i$, len$, i, token, tag;
  for (i$ = 0, len$ = tokens.length; i$ < len$; ++i$) {
    i = i$;
    token = tokens[i$], tag = token[0];
    if (tag == 'IF' || tag == 'CLASS' || tag == 'CATCH') {
      detectEnd(tokens, i + 1, ok, go);
    }
  }
  function ok(it){
    var ref$;
    return (ref$ = it[0]) == 'NEWLINE' || ref$ == 'INDENT';
  }
  function go(it, i){
    var lno;
    if (tag === 'IF') {
      if (it[0] !== 'INDENT' || !it[1] && !it.then || in$(tokens[i - 1][0], BLOCK_USERS)) {
        token[0] = 'POST_IF';
      }
    } else if (it[0] !== 'INDENT') {
      tokens.splice(i, 0, ['INDENT', 0, lno = tokens[i - 1][2]], ['DEDENT', 0, lno]);
    }
  }
}
function addImplicitIndentation(tokens){
  var i, token, tag, next, indent, dedent, ref$, idx;
  i = 0;
  while (token = tokens[++i]) {
    tag = token[0];
    if (tag != '->' && tag != 'THEN' && tag != 'ELSE' && tag != 'DEFAULT' && tag != 'TRY' && tag != 'FINALLY' && tag != 'DECL') {
      continue;
    }
    switch (next = tokens[i + 1][0]) {
    case 'IF':
      if (tag === 'ELSE') {
        continue;
      }
      break;
    case 'INDENT':
    case 'THEN':
      if (tag === 'THEN') {
        tokens.splice(i--, 1);
      }
      continue;
    }
    indent = ['INDENT', 0, token[2]];
    dedent = ['DEDENT', 0];
    if (tag === 'THEN') {
      (tokens[i] = indent).then = true;
    } else {
      tokens.splice(++i, 0, indent);
    }
    switch (false) {
    case tag !== 'DECL':
      break;
    case next != 'DOT' && next != '?' && next != ',' && next != 'PIPE' && next != 'BACKPIPE':
      --i;
      // fallthrough
    case !((next == 'ID' || next == 'STRNUM' || next == 'LITERAL') && ',' === ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8)):
      go(0, i += 2);
      ++i;
      continue;
    case !((next == '(' || next == '[' || next == '{') && ',' === ((ref$ = tokens[idx = 1 + indexOfPair(tokens, i + 1)]) != null ? ref$[0] : void 8)):
      go(0, idx);
      ++i;
      continue;
    }
    detectEnd(tokens, i + 1, ok, go);
  }
  function ok(token, i){
    var t0, t;
    t0 = token[0];
    t = tag;
    if (tag === t0 || tag === 'THEN' && t0 === 'SWITCH') {
      tag = '';
    }
    switch (t0) {
    case 'NEWLINE':
      return token[1] !== ';';
    case 'DOT':
    case '?':
    case ',':
    case 'PIPE':
    case 'BACKPIPE':
      return tokens[i - 1].eol;
    case 'ELSE':
      return t === 'THEN';
    case 'CATCH':
      return t === 'TRY';
    case 'FINALLY':
      return t == 'TRY' || t == 'CATCH' || t == 'THEN';
    case 'CASE':
    case 'DEFAULT':
      return t == 'CASE' || t == 'THEN';
    }
  }
  function go(arg$, i){
    var prev;
    prev = tokens[i - 1];
    tokens.splice(prev[0] === ',' ? i - 1 : i, 0, (dedent[2] = prev[2], dedent));
  }
}
function addImplicitParentheses(tokens){
  var i, brackets, token, endi, ref$, tpair, tag, prev, skipBlock, seenSwitch;
  i = 0;
  brackets = [];
  while (token = tokens[++i]) {
    if (token[1] === 'do' && tokens[i + 1][0] === 'INDENT') {
      endi = indexOfPair(tokens, i + 1);
      if (tokens[endi + 1][0] === 'NEWLINE' && ((ref$ = tokens[endi + 2]) != null ? ref$[0] : void 8) === 'WHILE') {
        token[0] = 'DO';
        tokens[endi + 2].done = true;
        tokens.splice(endi + 1, 1);
      } else {
        (token = tokens[1 + i])[0] = '(';
        (tpair = tokens[endi])[0] = ')';
        token.doblock = true;
        tokens.splice(i, 1);
      }
    }
    tag = token[0];
    prev = tokens[i - 1];
    tag === '[' && brackets.push(prev[0] === 'DOT');
    if (prev[0] === ']') {
      if (brackets.pop()) {
        prev.index = true;
      } else {
        continue;
      }
    }
    if (!(((ref$ = prev[0]) == 'FUNCTION' || ref$ == 'LET' || ref$ == 'WHERE') || prev.spaced && able(tokens, i, true))) {
      continue;
    }
    if (token.doblock) {
      token[0] = 'CALL(';
      tpair[0] = ')CALL';
      continue;
    }
    if (!exp(token)) {
      continue;
    }
    if (tag === 'CREMENT') {
      if (token.spaced || !in$((ref$ = tokens[i + 1]) != null ? ref$[0] : void 8, CHAIN)) {
        continue;
      }
    }
    skipBlock = seenSwitch = false;
    tokens.splice(i++, 0, ['CALL(', '', token[2]]);
    detectEnd(tokens, i, ok, go);
  }
  function exp(token){
    var tag;
    tag = token[0];
    return in$(tag, ARG) || !token.spaced && (tag == '+-' || tag == 'CLONE');
  }
  function ok(token, i){
    var tag, ref$, pre;
    tag = token[0];
    if (tag == 'POST_IF' || tag == 'PIPE' || tag == 'BACKPIPE') {
      return true;
    }
    if (!skipBlock) {
      if (token.alias && ((ref$ = token[1]) == '&&' || ref$ == '||' || ref$ == 'xor') || (tag == 'TO' || tag == 'BY' || tag == 'IMPLEMENTS')) {
        return true;
      }
    }
    pre = tokens[i - 1];
    switch (tag) {
    case 'NEWLINE':
      return pre[0] !== ',';
    case 'DOT':
    case '?':
    case 'CASCADE':
      return !skipBlock && (pre.spaced || pre[0] === 'DEDENT');
    case 'SWITCH':
      seenSwitch = true;
      // fallthrough
    case 'IF':
    case 'CLASS':
    case 'FUNCTION':
    case 'LET':
    case 'WITH':
    case 'CATCH':
      skipBlock = true;
      break;
    case 'CASE':
      if (seenSwitch) {
        skipBlock = true;
      } else {
        return true;
      }
      break;
    case 'INDENT':
      if (skipBlock) {
        return skipBlock = false;
      }
      return !in$(pre[0], BLOCK_USERS);
    case 'WHILE':
      if (token.done) {
        return false;
      }
      // fallthrough
    case 'FOR':
      skipBlock = true;
      return able(tokens, i) || pre[0] === 'CREMENT' || pre[0] === '...' && pre.spaced;
    }
    return false;
  }
  function go(token, i){
    tokens.splice(i, 0, [')CALL', '', tokens[i - 1][2]]);
  }
}
function addImplicitBraces(tokens){
  var stack, i, token, tag, start, paren, index, pre, ref$, inline;
  stack = [];
  i = 0;
  while (token = tokens[++i]) {
    if (':' !== (tag = token[0])) {
      switch (false) {
      case !in$(tag, CLOSERS):
        start = stack.pop();
        break;
      case !in$(tag, OPENERS):
        if (tag === 'INDENT' && tokens[i - 1][0] === '{') {
          tag = '{';
        }
        stack.push([tag, i]);
      }
      continue;
    }
    paren = tokens[i - 1][0] === ')';
    index = paren
      ? start[1]
      : i - 1;
    pre = tokens[index - 1];
    if (!(((ref$ = pre[0]) == ':' || ref$ == 'ASSIGN' || ref$ == 'IMPORT') || ((ref$ = stack[stack.length - 1]) != null ? ref$[0] : void 8) !== '{')) {
      continue;
    }
    stack.push(['{']);
    inline = !pre.doblock && ((ref$ = pre[0]) != 'NEWLINE' && ref$ != 'INDENT');
    while (((ref$ = tokens[index - 2]) != null ? ref$[0] : void 8) === 'COMMENT') {
      index -= 2;
    }
    tokens.splice(index, 0, ['{', '{', tokens[index][2]]);
    detectEnd(tokens, ++i + 1, ok, go);
  }
  function ok(token, i){
    var tag, t1, ref$;
    switch (tag = token[0]) {
    case ',':
      break;
    case 'NEWLINE':
      if (inline) {
        return true;
      }
      break;
    case 'DEDENT':
      return true;
    case 'POST_IF':
    case 'FOR':
    case 'WHILE':
      return inline;
    default:
      return false;
    }
    t1 = (ref$ = tokens[i + 1]) != null ? ref$[0] : void 8;
    return t1 !== (tag === ',' ? 'NEWLINE' : 'COMMENT') && ':' !== ((ref$ = tokens[t1 === '('
      ? 1 + indexOfPair(tokens, i + 1)
      : i + 2]) != null ? ref$[0] : void 8);
  }
  function go(token, i){
    tokens.splice(i, 0, ['}', '', token[2]]);
  }
}
function expandLiterals(tokens){
  var i, token, sig, lno, ref$, fromNum, char, toNum, tochar, byNum, byp, ts, enc, add, i$, n, len$, word, that;
  i = 0;
  while (token = tokens[++i]) {
    switch (token[0]) {
    case 'STRNUM':
      if (~'-+'.indexOf(sig = token[1].charAt(0))) {
        token[1] = token[1].slice(1);
        tokens.splice(i++, 0, ['+-', sig, token[2]]);
      }
      if (token.callable) {
        continue;
      }
      break;
    case 'RANGE':
      lno = token[2];
      if (tokens[i - 1][0] === '[' && tokens[i + 1][0] === 'STRNUM' && ((tokens[i + 2][0] === ']' && (((ref$ = tokens[i + 1][1].charAt(0)) == '\'' || ref$ == '"') || +tokens[i + 1][1] >= 0)) || (tokens[i + 2][0] === 'RANGE_BY' && ((ref$ = tokens[i + 3]) != null ? ref$[0] : void 8) === 'STRNUM' && ((ref$ = tokens[i + 4]) != null ? ref$[0] : void 8) === ']'))) {
        ref$ = decode(token[1], lno), fromNum = ref$[0], char = ref$[1];
        ref$ = decode(tokens[i + 1][1], lno), toNum = ref$[0], tochar = ref$[1];
        if (toNum == null || char ^ tochar) {
          carp('bad "to" in range', lno);
        }
        byNum = 1;
        if (byp = ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8) === 'RANGE_BY') {
          if (!(byNum = +((ref$ = tokens[i + 3]) != null ? ref$[1] : void 8))) {
            carp('bad "by" in range', tokens[i + 2][2]);
          }
        } else if (fromNum > toNum) {
          byNum = -1;
        }
        ts = [];
        enc = char ? character : String;
        add = fn$;
        if (token.op === 'to') {
          for (i$ = fromNum; byNum < 0 ? i$ >= toNum : i$ <= toNum; i$ += byNum) {
            n = i$;
            add();
          }
        } else {
          for (i$ = fromNum; byNum < 0 ? i$ > toNum : i$ < toNum; i$ += byNum) {
            n = i$;
            add();
          }
        }
        ts.pop() || carp('empty range', lno);
        tokens.splice.apply(tokens, [i, 2 + 2 * byp].concat(slice$.call(ts)));
        i += ts.length - 1;
      } else {
        token[0] = 'STRNUM';
        if (((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8) === 'RANGE_BY') {
          tokens.splice(i + 2, 1, ['BY', 'by', lno]);
        }
        tokens.splice(i + 1, 0, ['TO', token.op, lno]);
      }
      break;
    case 'WORDS':
      ts = [['[', '[', lno = token[2]]];
      for (i$ = 0, len$ = (ref$ = token[1].match(/\S+/g) || '').length; i$ < len$; ++i$) {
        word = ref$[i$];
        ts.push(['STRNUM', string('\'', word, lno), lno], [',', ',', lno]);
      }
      tokens.splice.apply(tokens, [i, 1].concat(slice$.call(ts), [[']', ']', lno]]));
      i += ts.length;
      break;
    case 'INDENT':
      if (that = tokens[i - 1]) {
        if (that[1] === 'new') {
          tokens.splice(i++, 0, ['PARAM(', '', token[2]], [')PARAM', '', token[2]], ['->', '', token[2]]);
        } else if ((ref$ = that[0]) == 'FUNCTION' || ref$ == 'LET') {
          tokens.splice(i, 0, ['CALL(', '', token[2]], [')CALL', '', token[2]]);
          i += 2;
        }
      }
      continue;
    case 'LITERAL':
    case '}':
    case '!?':
      break;
    case ')':
    case ')CALL':
      if (token[1]) {
        continue;
      }
      break;
    case ']':
      if (token.index) {
        continue;
      }
      break;
    case 'CREMENT':
      if (!able(tokens, i)) {
        continue;
      }
      break;
    case 'BIOP':
      if (!token.spaced && ((ref$ = token[1]) == '+' || ref$ == '-') && tokens[i + 1][0] !== ')') {
        tokens[i][0] = '+-';
      }
      continue;
    default:
      continue;
    }
    if (token.spaced && in$(tokens[i + 1][0], ARG)) {
      tokens.splice(++i, 0, [',', ',', token[2]]);
    }
  }
  function fn$(){
    if (0x10000 < ts.push(['STRNUM', enc(n), lno], [',', ',', lno])) {
      carp('range limit exceeded', lno);
    }
  }
}
function detectEnd(tokens, i, ok, go){
  var levels, token, tag;
  levels = 0;
  for (; token = tokens[i]; ++i) {
    if (!levels && ok(token, i)) {
      return go(token, i);
    }
    tag = token[0];
    if (0 > (levels += in$(tag, OPENERS) || -in$(tag, CLOSERS))) {
      return go(token, i);
    }
  }
}
function indexOfPair(tokens, i){
  var level, end, start, that;
  level = 1;
  end = INVERSES[start = tokens[i][0]];
  while (that = tokens[++i]) {
    switch (that[0]) {
    case start:
      ++level;
      break;
    case end:
      if (!--level) {
        return i;
      }
    }
  }
  return -1;
}
KEYWORDS_SHARED = ['true', 'false', 'null', 'this', 'void', 'super', 'return', 'throw', 'break', 'continue', 'if', 'else', 'for', 'while', 'switch', 'case', 'default', 'try', 'catch', 'finally', 'function', 'class', 'extends', 'implements', 'new', 'do', 'delete', 'typeof', 'in', 'instanceof', 'let', 'with', 'var', 'const', 'import', 'export', 'debugger'];
KEYWORDS_UNUSED = ['enum', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield'];
KEYWORDS = KEYWORDS_SHARED.concat(KEYWORDS_UNUSED);
ID = /((?!\s)[a-z_$\xAA-\uFFDC](?:(?!\s)[\w$\xAA-\uFFDC]|-[a-z])*)([^\n\S]*:(?![:=]))?|/ig;
SYMBOL = /[-+*\/^]=|%?=|::?=|\.(?:[&\|\^]|<<|>>>?)\.=?|\.{1,3}|\^\^|\+\+\+|-->|~~>|<--|<~~|([-+&|:])\1|%|&|\([^\n\S]*\)|[-~]>|<[-~]|[!=]==?|!?\~=|@@?|<\[(?:[\s\S]*?\]>)?|<<<<?|<\||[<>]==|<<=|>>=|<<|>>|[<>]\??=?|!\?|\|>|\||=>|\*\*=?|\^|`|[^\s#]?/g;
SPACE = /[^\n\S]*(?:#.*)?/g;
MULTIDENT = /(?:\s*#.*)*(?:\n([^\n\S]*))+/g;
SIMPLESTR = /'[^\\']*(?:\\[\s\S][^\\']*)*'|/g;
JSTOKEN = /``[^\\`]*(?:\\[\s\S][^\\`]*)*``|/g;
BSTOKEN = /\\(?:(\S[^\s,;)}\]]*)|\s*)/g;
NUMBER = /0x[\dA-Fa-f][\dA-Fa-f_]*|(\d*)~([\dA-Za-z]\w*)|((\d[\d_]*)(\.\d[\d_]*)?(?:e[+-]?\d[\d_]*)?)[$\w]*|/g;
NUMBER_OMIT = /_+/g;
REGEX = /\/([^[\/\n\\]*(?:(?:\\.|\[[^\]\n\\]*(?:\\.[^\]\n\\]*)*\])[^[\/\n\\]*)*)\/([gimy]{1,4}|\$?)|/g;
HEREGEX_OMIT = /\s+(?:#.*)?/g;
LASTDENT = /\n[^\n\S]*$/;
INLINEDENT = /[^\n\S]*[^#\s]?/g;
NONASCII = /[\x80-\uFFFF]/;
OPENERS = ['(', '[', '{', 'CALL(', 'PARAM(', 'INDENT'];
CLOSERS = [')', ']', '}', ')CALL', ')PARAM', 'DEDENT'];
INVERSES = import$((function(){
  var i$, ref$, len$, results$ = {};
  for (i$ = 0, len$ = (ref$ = OPENERS).length; i$ < len$; ++i$) {
    i = i$;
    o = ref$[i$];
    results$[o] = CLOSERS[i];
  }
  return results$;
}()), (function(){
  var i$, ref$, len$, results$ = {};
  for (i$ = 0, len$ = (ref$ = CLOSERS).length; i$ < len$; ++i$) {
    i = i$;
    c = ref$[i$];
    results$[c] = OPENERS[i];
  }
  return results$;
}()));
CHAIN = ['(', '{', '[', 'ID', 'STRNUM', 'LITERAL', 'LET', 'WITH', 'WORDS'];
ARG = CHAIN.concat(['...', 'UNARY', 'CREMENT', 'PARAM(', 'FUNCTION', 'IF', 'SWITCH', 'TRY', 'CLASS', 'RANGE', 'LABEL', 'DECL', 'DO', 'BIOPBP']);
BLOCK_USERS = [',', ':', '->', 'ELSE', 'ASSIGN', 'IMPORT', 'UNARY', 'DEFAULT', 'TRY', 'FINALLY', 'HURL', 'DECL', 'DO', 'LET', 'FUNCTION'];
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function in$(x, arr){
  var i = -1, l = arr.length >>> 0;
  while (++i < l) if (x === arr[i] && i in arr) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
});

require.define("/node_modules/LiveScript/lib/parser.js",function(require,module,exports,__dirname,__filename,process,global){exports.parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Chain":3,"ID":4,"Parenthetical":5,"List":6,"STRNUM":7,"LITERAL":8,"DOT":9,"Key":10,"CALL(":11,"ArgList":12,"OptComma":13,")CALL":14,"?":15,"LET":16,"Block":17,"WITH":18,"Expression":19,"[":20,"LoopHeads":21,"]":22,"DEDENT":23,"{":24,"}":25,"(":26,"BIOP":27,")":28,"BIOPR":29,"BIOPBP":30,"BIOPP":31,"PARAM(":32,")PARAM":33,"UNARY":34,"CREMENT":35,"BACKTICK":36,"TO":37,"BY":38,"Properties":39,"LABEL":40,"KeyBase":41,"Arg":42,",":43,"NEWLINE":44,"INDENT":45,"...":46,"Lines":47,"Line":48,"<-":49,"COMMENT":50,"REQUIRE":51,"Cascade":52,"CASCADE":53,"WHERE":54,"CLONEPORT":55,"ASSIGN":56,"IMPORT":57,"+-":58,"CLONE":59,"COMPARE":60,"LOGIC":61,"MATH":62,"POWER":63,"SHIFT":64,"BITWISE":65,"CONCAT":66,"COMPOSE":67,"RELATION":68,"PIPE":69,"BACKPIPE":70,"!?":71,"->":72,"FUNCTION":73,"IF":74,"Else":75,"POST_IF":76,"LoopHead":77,"DO":78,"WHILE":79,"HURL":80,"JUMP":81,"SWITCH":82,"Exprs":83,"Cases":84,"DEFAULT":85,"ELSE":86,"TRY":87,"CATCH":88,"FINALLY":89,"CLASS":90,"OptExtends":91,"OptImplements":92,"EXTENDS":93,"DECL":94,"KeyValue":95,"Property":96,":":97,"Body":98,"FOR":99,"IN":100,"CASE":101,"OF":102,"OWN":103,"FROM":104,"IMPLEMENTS":105,"Root":106,"$accept":0,"$end":1},
terminals_: {2:"error",4:"ID",7:"STRNUM",8:"LITERAL",9:"DOT",11:"CALL(",14:")CALL",15:"?",16:"LET",18:"WITH",20:"[",22:"]",23:"DEDENT",24:"{",25:"}",26:"(",27:"BIOP",28:")",29:"BIOPR",30:"BIOPBP",31:"BIOPP",32:"PARAM(",33:")PARAM",34:"UNARY",35:"CREMENT",36:"BACKTICK",37:"TO",38:"BY",40:"LABEL",43:",",44:"NEWLINE",45:"INDENT",46:"...",49:"<-",50:"COMMENT",51:"REQUIRE",53:"CASCADE",54:"WHERE",55:"CLONEPORT",56:"ASSIGN",57:"IMPORT",58:"+-",59:"CLONE",60:"COMPARE",61:"LOGIC",62:"MATH",63:"POWER",64:"SHIFT",65:"BITWISE",66:"CONCAT",67:"COMPOSE",68:"RELATION",69:"PIPE",70:"BACKPIPE",71:"!?",72:"->",73:"FUNCTION",74:"IF",76:"POST_IF",78:"DO",79:"WHILE",80:"HURL",81:"JUMP",82:"SWITCH",85:"DEFAULT",86:"ELSE",87:"TRY",88:"CATCH",89:"FINALLY",90:"CLASS",93:"EXTENDS",94:"DECL",97:":",99:"FOR",100:"IN",101:"CASE",102:"OF",103:"OWN",104:"FROM",105:"IMPLEMENTS"},
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,3],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,4],[3,6],[3,7],[3,6],[3,6],[3,5],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[41,1],[41,1],[12,0],[12,1],[12,3],[12,4],[12,6],[42,1],[42,2],[42,1],[13,0],[13,1],[47,0],[47,1],[47,3],[47,2],[48,1],[48,2],[48,6],[48,1],[48,1],[48,2],[17,3],[52,2],[52,3],[19,2],[19,6],[19,3],[19,3],[19,3],[19,5],[19,1],[19,3],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,3],[19,3],[19,2],[19,2],[19,2],[19,5],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[83,1],[83,3],[95,1],[95,1],[95,3],[95,3],[95,5],[95,5],[96,3],[96,6],[96,1],[96,3],[96,3],[96,2],[96,2],[96,2],[96,1],[39,0],[39,1],[39,3],[39,4],[39,4],[5,3],[98,1],[98,1],[98,3],[75,0],[75,2],[75,5],[77,4],[77,6],[77,6],[77,8],[77,4],[77,6],[77,6],[77,8],[77,5],[77,7],[77,7],[77,9],[77,6],[77,5],[77,8],[77,7],[77,8],[77,10],[77,10],[77,2],[77,4],[77,4],[77,6],[21,1],[21,2],[21,3],[21,3],[84,3],[84,4],[91,2],[91,0],[92,2],[92,0],[106,1]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1:this.$ = yy.Chain(yy.L(yylineno, yy.Var($$[$0])));
break;
case 2:
case 3:this.$ = yy.Chain($$[$0]);
break;
case 4:
case 5:this.$ = yy.Chain(yy.L(yylineno, yy.Literal($$[$0])));
break;
case 6:
case 7:this.$ = $$[$0-2].add(yy.Index($$[$0], $$[$0-1], true));
break;
case 8:this.$ = $$[$0-4].add(yy.Call($$[$0-2]));
break;
case 9:this.$ = yy.Chain(yy.Existence($$[$0-1].unwrap()));
break;
case 10:this.$ = yy.Chain(yy.Call['let']($$[$0-3], $$[$0]));
break;
case 11:this.$ = yy.Chain(new yy.Cascade($$[$0-1], $$[$0]));
break;
case 12:this.$ = yy.Chain($$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)));
break;
case 13:this.$ = yy.Chain($$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)));
break;
case 14:this.$ = yy.Chain($$[$0-1][0].addObjComp().makeComprehension(yy.L(yylineno, yy.Arr($$[$0-4])), $$[$0-1].slice(1)));
break;
case 15:this.$ = yy.Chain(yy.Binary($$[$0-1]));
break;
case 16:this.$ = yy.Chain(yy.Binary($$[$0-2], void 8, $$[$0-1]));
break;
case 17:this.$ = yy.Chain(yy.Binary($$[$0-1], $$[$0-2]));
break;
case 18:this.$ = yy.Chain('!' === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1)).invertIt()
        : yy.Binary($$[$0-1]));
break;
case 19:this.$ = yy.Chain('!' === $$[$0-2].charAt(0)
        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
        : yy.Binary($$[$0-2], void 8, $$[$0-1]));
break;
case 20:this.$ = yy.Chain('!' === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1), $$[$0-2]).invertIt()
        : yy.Binary($$[$0-1], $$[$0-2]));
break;
case 21:this.$ = yy.Chain(yy.Binary($$[$0-1]));
break;
case 22:this.$ = yy.Chain(yy.Binary($$[$0-5], void 8, $$[$0-3]));
break;
case 23:this.$ = yy.Chain(yy.Binary($$[$0-1]));
break;
case 24:this.$ = yy.Chain(yy.Binary($$[$0-1], $$[$0-4]));
break;
case 25:
case 26:this.$ = yy.Chain(yy.Unary($$[$0-1]));
break;
case 27:this.$ = yy.Chain($$[$0-2]);
break;
case 28:this.$ = yy.Chain($$[$0-2].add(yy.Call([$$[$0-4]])));
break;
case 29:this.$ = yy.Chain(yy.Chain(yy.Var('flip$')).add(yy.Call([$$[$0-3]]))).flipIt().add(yy.Call([$$[$0-1]]));
break;
case 30:this.$ = yy.Chain(new yy.For({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }));
break;
case 31:this.$ = yy.Chain(new yy.For({
        from: $$[$0-5],
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }));
break;
case 32:this.$ = yy.Chain(new yy.For({
        from: yy.Chain(yy.Literal(0)),
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }));
break;
case 33:this.$ = yy.Chain(new yy.For({
        from: yy.Chain(yy.Literal(0)),
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }));
break;
case 34:this.$ = yy.Chain(yy.Slice({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }));
break;
case 35:this.$ = yy.Chain(yy.Slice({
        type: $$[$0-1],
        target: $$[$0-5],
        from: $$[$0-2]
      }));
break;
case 36:this.$ = yy.Chain(yy.Slice({
        type: $$[$0-2],
        target: $$[$0-5],
        to: $$[$0-1]
      }));
break;
case 37:this.$ = yy.Chain(yy.Slice({
        type: $$[$0-1],
        target: $$[$0-4]
      }));
break;
case 38:this.$ = yy.L(yylineno, yy.Arr($$[$0-2]));
break;
case 39:this.$ = yy.L(yylineno, yy.Obj($$[$0-2]));
break;
case 40:this.$ = yy.L(yylineno, yy.Arr($$[$0-3])).named($$[$0]);
break;
case 41:this.$ = yy.L(yylineno, yy.Obj($$[$0-3])).named($$[$0]);
break;
case 44:this.$ = yy.L(yylineno, yy.Key($$[$0]));
break;
case 45:this.$ = yy.L(yylineno, yy.Literal($$[$0]));
break;
case 46:this.$ = [];
break;
case 47:this.$ = [$$[$0]];
break;
case 48:this.$ = $$[$0-2].concat($$[$0]);
break;
case 49:this.$ = $$[$0-3].concat($$[$0]);
break;
case 50:this.$ = $$[$0-5].concat($$[$0-2]);
break;
case 52:this.$ = yy.Splat($$[$0]);
break;
case 53:this.$ = yy.Splat(yy.L(yylineno, yy.Arr()), true);
break;
case 56:this.$ = yy.L(yylineno, yy.Block());
break;
case 57:this.$ = yy.Block($$[$0]);
break;
case 58:this.$ = $$[$0-2].add($$[$0]);
break;
case 61:this.$ = new yy.Cascade($$[$0-1], $$[$0]);
break;
case 62:this.$ = yy.Call.back($$[$0-4], $$[$0], $$[$0-1].charAt(1) === '~', $$[$0-1].length === 3);
break;
case 63:this.$ = yy.L(yylineno, yy.JS($$[$0], true, true));
break;
case 64:this.$ = yy.L(yylineno, yy.Throw(yy.JS("Error('unimplemented')")));
break;
case 65:this.$ = yy.Require($$[$0].unwrap());
break;
case 66:this.$ = $$[$0-1].chomp();
break;
case 67:this.$ = [$$[$0-1]];
break;
case 68:this.$ = $$[$0-2].concat($$[$0-1]);
break;
case 69:this.$ = new yy.Cascade($$[$0-1][0], yy.Block($$[$0-1].slice(1).concat($$[$0])));
break;
case 70:this.$ = yy.Chain(yy.Call.where($$[$0-2], yy.Block([$$[$0-5]])));
break;
case 71:this.$ = yy.Chain(yy.Call.where($$[$0].lines, yy.Block([$$[$0-2]])));
break;
case 72:this.$ = yy.Import(yy.Unary('^^', $$[$0-2], {
        prec: 'yy.UNARY'
      }), $$[$0], false);
break;
case 73:this.$ = yy.Import(yy.Unary('^^', $$[$0-2], {
        prec: 'yy.UNARY'
      }), $$[$0].unwrap(), false);
break;
case 74:this.$ = $$[$0-2].add(yy.Call([$$[$0-4], $$[$0]]));
break;
case 75:this.$ = $$[$0].unwrap();
break;
case 76:this.$ = yy.Assign($$[$0-2].unwrap(), $$[$0], $$[$0-1]);
break;
case 77:this.$ = yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), $$[$0-4]);
break;
case 78:this.$ = yy.Import($$[$0-2], $$[$0], $$[$0-1] === '<<<<');
break;
case 79:this.$ = yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '<<<<');
break;
case 80:this.$ = yy.Unary($$[$0-1], $$[$0].unwrap());
break;
case 81:this.$ = yy.Unary($$[$0], $$[$0-1].unwrap(), true);
break;
case 82:
case 83:
case 84:this.$ = yy.Assign($$[$0].unwrap(), [$$[$0-2]], $$[$0-1]);
break;
case 85:
case 86:
case 87:this.$ = yy.Unary($$[$0-1], $$[$0]);
break;
case 88:this.$ = yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2]));
break;
case 89:
case 90:
case 91:
case 92:
case 93:
case 94:
case 95:
case 96:
case 97:this.$ = yy.Binary($$[$0-1], $$[$0-2], $$[$0]);
break;
case 98:this.$ = '!' === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert()
        : yy.Binary($$[$0-1], $$[$0-2], $$[$0]);
break;
case 99:this.$ = yy.Block($$[$0-2]).pipe($$[$0], $$[$0-1]);
break;
case 100:this.$ = yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]);
break;
case 101:this.$ = yy.Existence($$[$0-1].unwrap(), true);
break;
case 102:this.$ = yy.L(yylineno, yy.Fun($$[$0-4], $$[$0], $$[$0-1].charAt(0) === '~', $$[$0-1].length === 3));
break;
case 103:this.$ = yy.L(yylineno, yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 104:this.$ = yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]);
break;
case 105:this.$ = yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless');
break;
case 106:this.$ = $$[$0-2].addBody($$[$0-1]).addElse($$[$0]);
break;
case 107:this.$ = new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]);
break;
case 108:this.$ = yy.Jump[$$[$0-1]]($$[$0]);
break;
case 109:this.$ = yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2]));
break;
case 110:this.$ = yy.L(yylineno, yy.Jump[$$[$0]]());
break;
case 111:this.$ = yy.L(yylineno, new yy.Jump($$[$0]));
break;
case 112:this.$ = yy.L(yylineno, new yy.Jump($$[$0-1], $$[$0]));
break;
case 113:this.$ = new yy.Switch($$[$0-2], $$[$0-1], $$[$0]);
break;
case 114:
case 115:this.$ = new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]);
break;
case 116:this.$ = new yy.Switch($$[$0-1], null, $$[$0]);
break;
case 117:
case 118:this.$ = new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]);
break;
case 119:this.$ = new yy.Switch($$[$0-1], null, [], $$[$0]);
break;
case 120:this.$ = new yy.Try($$[$0]);
break;
case 121:this.$ = new yy.Try($$[$0-2], void 8, $$[$0]);
break;
case 122:this.$ = new yy.Try($$[$0-4], void 8, $$[$0-2], $$[$0]);
break;
case 123:this.$ = new yy.Try($$[$0-3], $$[$0-1], $$[$0]);
break;
case 124:this.$ = new yy.Try($$[$0-5], $$[$0-3], $$[$0-2], $$[$0]);
break;
case 125:this.$ = new yy.Try($$[$0-2], void 8, void 8, $$[$0]);
break;
case 126:this.$ = new yy.Class({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      });
break;
case 127:this.$ = new yy.Class({
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      });
break;
case 128:this.$ = yy.Util.Extends($$[$0-2].unwrap(), $$[$0]);
break;
case 129:
case 130:this.$ = new yy.Label($$[$0-1], $$[$0]);
break;
case 131:this.$ = yy.Decl($$[$0-4], $$[$0-2], yylineno + 1);
break;
case 132:this.$ = [$$[$0]];
break;
case 133:this.$ = $$[$0-2].concat($$[$0]);
break;
case 135:this.$ = yy.Prop(yy.L(yylineno, yy.Key($$[$0], $$[$0] != 'arguments' && $$[$0] != 'eval')), yy.L(yylineno, yy.Literal($$[$0])));
break;
case 136:this.$ = yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.Index($$[$0], $$[$0-1])]));
break;
case 137:this.$ = yy.Prop($$[$0], yy.Chain(yy.L(yylineno, yy.Literal($$[$0-2])), [yy.Index($$[$0], $$[$0-1])]));
break;
case 138:this.$ = yy.Prop(yy.L(yylineno, yy.Key($$[$0])), yy.L(yylineno, yy.Obj($$[$0-3]).named($$[$0])));
break;
case 139:this.$ = yy.Prop(yy.L(yylineno, yy.Key($$[$0])), yy.L(yylineno, yy.Arr($$[$0-3]).named($$[$0])));
break;
case 140:this.$ = yy.Prop($$[$0-2], $$[$0]);
break;
case 141:this.$ = yy.Prop($$[$0-5], yy.Arr.maybe($$[$0-2]));
break;
case 143:this.$ = yy.Binary($$[$0-1], $$[$0-2], $$[$0]);
break;
case 144:this.$ = yy.Binary($$[$0-1], $$[$0-2], $$[$0], true);
break;
case 145:this.$ = yy.Prop($$[$0].maybeKey(), yy.L(yylineno, yy.Literal($$[$0-1] === '+')));
break;
case 146:this.$ = yy.Prop(yy.L(yylineno, yy.Key($$[$0], true)), yy.L(yylineno, yy.Literal($$[$0-1] === '+')));
break;
case 147:this.$ = yy.Splat($$[$0]);
break;
case 148:this.$ = yy.L(yylineno, yy.JS($$[$0], true, true));
break;
case 149:this.$ = [];
break;
case 150:this.$ = [$$[$0]];
break;
case 151:this.$ = $$[$0-2].concat($$[$0]);
break;
case 152:this.$ = $$[$0-3].concat($$[$0]);
break;
case 153:this.$ = $$[$0-2];
break;
case 154:this.$ = yy.Parens($$[$0-1].chomp().unwrap(), false, $$[$0-2] === '"');
break;
case 157:this.$ = $$[$0-2].add($$[$0]);
break;
case 158:this.$ = null;
break;
case 159:this.$ = $$[$0];
break;
case 160:this.$ = yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]);
break;
case 161:this.$ = new yy.For({
        item: $$[$0-2].unwrap(),
        index: $$[$0-1],
        source: $$[$0]
      });
break;
case 162:this.$ = new yy.For({
        item: $$[$0-4].unwrap(),
        index: $$[$0-3],
        source: $$[$0-2],
        guard: $$[$0]
      });
break;
case 163:this.$ = new yy.For({
        item: $$[$0-4].unwrap(),
        index: $$[$0-3],
        source: $$[$0-2],
        step: $$[$0]
      });
break;
case 164:this.$ = new yy.For({
        item: $$[$0-6].unwrap(),
        index: $$[$0-5],
        source: $$[$0-4],
        step: $$[$0-2],
        guard: $$[$0]
      });
break;
case 165:this.$ = new yy.For({
        object: true,
        index: $$[$0-2],
        source: $$[$0]
      });
break;
case 166:this.$ = new yy.For({
        object: true,
        index: $$[$0-4],
        source: $$[$0-2],
        guard: $$[$0]
      });
break;
case 167:this.$ = new yy.For({
        object: true,
        index: $$[$0-4],
        item: $$[$0-2].unwrap(),
        source: $$[$0]
      });
break;
case 168:this.$ = new yy.For({
        object: true,
        index: $$[$0-6],
        item: $$[$0-4].unwrap(),
        source: $$[$0-2],
        guard: $$[$0]
      });
break;
case 169:this.$ = new yy.For({
        object: true,
        own: true,
        index: $$[$0-2],
        source: $$[$0]
      });
break;
case 170:this.$ = new yy.For({
        object: true,
        own: true,
        index: $$[$0-4],
        source: $$[$0-2],
        guard: $$[$01]
      });
break;
case 171:this.$ = new yy.For({
        object: true,
        own: true,
        index: $$[$0-4],
        item: $$[$0-2].unwrap(),
        source: $$[$0]
      });
break;
case 172:this.$ = new yy.For({
        object: true,
        own: true,
        index: $$[$0-6],
        item: $$[$0-4].unwrap(),
        source: $$[$0-2],
        guard: $$[$0-1]
      });
break;
case 173:this.$ = new yy.For({
        index: $$[$0-4],
        from: $$[$0-2],
        op: $$[$0-1],
        to: $$[$0]
      });
break;
case 174:this.$ = new yy.For({
        from: $$[$0-2],
        op: $$[$0-1],
        to: $$[$0]
      });
break;
case 175:this.$ = new yy.For({
        index: $$[$0-6],
        from: $$[$0-4],
        op: $$[$0-3],
        to: $$[$0-2],
        guard: $$[$0]
      });
break;
case 176:this.$ = new yy.For({
        from: $$[$0-4],
        op: $$[$0-3],
        to: $$[$0-2],
        guard: $$[$0]
      });
break;
case 177:this.$ = new yy.For({
        index: $$[$0-6],
        from: $$[$0-4],
        op: $$[$0-3],
        to: $$[$0-2],
        step: $$[$0]
      });
break;
case 178:this.$ = new yy.For({
        index: $$[$0-8],
        from: $$[$0-6],
        op: $$[$0-5],
        to: $$[$0-4],
        step: $$[$0-2],
        guard: $$[$0]
      });
break;
case 179:this.$ = new yy.For({
        index: $$[$0-8],
        from: $$[$0-6],
        op: $$[$0-5],
        to: $$[$0-4],
        guard: $$[$0-2],
        step: $$[$0]
      });
break;
case 180:this.$ = new yy.While($$[$0], $$[$0-1] === 'until');
break;
case 181:this.$ = new yy.While($$[$0-2], $$[$0-3] === 'until').addGuard($$[$0]);
break;
case 182:this.$ = new yy.While($$[$0-2], $$[$0-3] === 'until', $$[$0]);
break;
case 183:this.$ = new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]);
break;
case 184:this.$ = [$$[$0]];
break;
case 185:this.$ = $$[$0-1].concat($$[$0]);
break;
case 186:
case 187:this.$ = $$[$0-2].concat($$[$0]);
break;
case 188:this.$ = [new yy.Case($$[$0-1], $$[$0])];
break;
case 189:this.$ = $$[$0-3].concat(new yy.Case($$[$0-1], $$[$0]));
break;
case 190:this.$ = $$[$0];
break;
case 191:this.$ = null;
break;
case 192:this.$ = $$[$0];
break;
case 193:this.$ = null;
break;
case 194:return this.$
}
},
table: [{1:[2,56],3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:4,18:[1,35],19:7,20:[1,36],24:[1,37],26:[1,38],32:[1,8],34:[1,15],35:[1,14],40:[1,27],44:[2,56],45:[1,6],46:[1,10],47:3,48:5,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],98:2,99:[1,39],106:1},{1:[3]},{1:[2,194]},{1:[2,155],28:[2,155],44:[1,41]},{1:[2,156],28:[2,156],44:[1,42]},{1:[2,57],23:[2,57],28:[2,57],44:[2,57]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:7,20:[1,36],23:[2,56],24:[1,37],26:[1,38],32:[1,8],34:[1,15],35:[1,14],40:[1,27],44:[2,56],46:[1,10],47:43,48:5,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,60],17:44,23:[2,60],28:[2,60],36:[1,46],44:[2,60],45:[1,6],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:61,16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],33:[2,46],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,63],23:[2,63],28:[2,63],44:[2,63]},{1:[2,64],23:[2,64],28:[2,64],44:[2,64]},{3:66,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{3:67,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{1:[2,75],9:[1,74],11:[1,75],14:[2,75],15:[1,76],22:[2,75],23:[2,75],25:[2,75],27:[2,75],28:[2,75],29:[2,75],33:[2,75],35:[1,70],36:[2,75],37:[2,75],38:[2,75],43:[2,75],44:[2,75],45:[2,75],53:[1,73],54:[2,75],55:[1,68],56:[1,69],57:[2,75],58:[2,75],60:[2,75],61:[2,75],62:[2,75],63:[2,75],64:[2,75],65:[2,75],66:[2,75],67:[2,75],68:[2,75],69:[2,75],70:[2,75],71:[1,71],76:[2,75],79:[2,75],93:[1,72],99:[2,75],101:[2,75],105:[2,75]},{3:77,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:79,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,80],52:12,56:[1,78],58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:82,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,56:[1,81],58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:84,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,56:[1,83],58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{11:[1,85]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:86,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:87,45:[1,6]},{17:88,45:[1,6]},{1:[2,110],3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],14:[2,110],16:[1,34],18:[1,35],19:89,20:[1,36],22:[2,110],23:[2,110],24:[1,37],25:[2,110],26:[1,38],27:[2,110],28:[2,110],29:[2,110],32:[1,65],33:[2,110],34:[1,15],35:[1,14],36:[2,110],37:[2,110],38:[2,110],40:[1,27],43:[2,110],44:[2,110],45:[1,90],52:12,54:[2,110],57:[2,110],58:[1,16],59:[1,17],60:[2,110],61:[2,110],62:[2,110],63:[2,110],64:[2,110],65:[2,110],66:[2,110],67:[2,110],68:[2,110],69:[2,110],70:[2,110],73:[1,18],74:[1,19],76:[2,110],77:20,78:[1,21],79:[2,110],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[2,110],101:[2,110],105:[2,110]},{1:[2,111],4:[1,91],14:[2,111],22:[2,111],23:[2,111],25:[2,111],27:[2,111],28:[2,111],29:[2,111],33:[2,111],36:[2,111],37:[2,111],38:[2,111],43:[2,111],44:[2,111],45:[2,111],54:[2,111],57:[2,111],58:[2,111],60:[2,111],61:[2,111],62:[2,111],63:[2,111],64:[2,111],65:[2,111],66:[2,111],67:[2,111],68:[2,111],69:[2,111],70:[2,111],76:[2,111],79:[2,111],99:[2,111],101:[2,111],105:[2,111]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:94,18:[1,35],19:95,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,6],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],83:92,84:93,87:[1,25],90:[1,26],94:[1,28],99:[1,39],101:[1,96]},{17:97,45:[1,6]},{3:98,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38],45:[2,191],91:99,93:[1,100],105:[2,191]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:102,18:[1,35],19:101,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,6],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{45:[1,103]},{1:[2,1],9:[2,1],11:[2,1],14:[2,1],15:[2,1],22:[2,1],23:[2,1],25:[2,1],27:[2,1],28:[2,1],29:[2,1],33:[2,1],35:[2,1],36:[2,1],37:[2,1],38:[2,1],43:[2,1],44:[2,1],45:[2,1],53:[2,1],54:[2,1],55:[2,1],56:[2,1],57:[2,1],58:[2,1],60:[2,1],61:[2,1],62:[2,1],63:[2,1],64:[2,1],65:[2,1],66:[2,1],67:[2,1],68:[2,1],69:[2,1],70:[2,1],71:[2,1],76:[2,1],79:[2,1],93:[2,1],99:[2,1],101:[2,1],102:[2,1],105:[2,1]},{1:[2,2],9:[2,2],11:[2,2],14:[2,2],15:[2,2],22:[2,2],23:[2,2],25:[2,2],27:[2,2],28:[2,2],29:[2,2],33:[2,2],35:[2,2],36:[2,2],37:[2,2],38:[2,2],43:[2,2],44:[2,2],45:[2,2],53:[2,2],54:[2,2],55:[2,2],56:[2,2],57:[2,2],58:[2,2],60:[2,2],61:[2,2],62:[2,2],63:[2,2],64:[2,2],65:[2,2],66:[2,2],67:[2,2],68:[2,2],69:[2,2],70:[2,2],71:[2,2],76:[2,2],79:[2,2],93:[2,2],99:[2,2],100:[2,2],101:[2,2],102:[2,2],105:[2,2]},{1:[2,3],9:[2,3],11:[2,3],14:[2,3],15:[2,3],22:[2,3],23:[2,3],25:[2,3],27:[2,3],28:[2,3],29:[2,3],33:[2,3],35:[2,3],36:[2,3],37:[2,3],38:[2,3],43:[2,3],44:[2,3],45:[2,3],53:[2,3],54:[2,3],55:[2,3],56:[2,3],57:[2,3],58:[2,3],60:[2,3],61:[2,3],62:[2,3],63:[2,3],64:[2,3],65:[2,3],66:[2,3],67:[2,3],68:[2,3],69:[2,3],70:[2,3],71:[2,3],76:[2,3],79:[2,3],93:[2,3],99:[2,3],100:[2,3],101:[2,3],102:[2,3],105:[2,3]},{1:[2,4],9:[2,4],11:[2,4],14:[2,4],15:[2,4],22:[2,4],23:[2,4],25:[2,4],27:[2,4],28:[2,4],29:[2,4],33:[2,4],35:[2,4],36:[2,4],37:[2,4],38:[2,4],43:[2,4],44:[2,4],45:[2,4],53:[2,4],54:[2,4],55:[2,4],56:[2,4],57:[2,4],58:[2,4],60:[2,4],61:[2,4],62:[2,4],63:[2,4],64:[2,4],65:[2,4],66:[2,4],67:[2,4],68:[2,4],69:[2,4],70:[2,4],71:[2,4],76:[2,4],79:[2,4],93:[2,4],99:[2,4],100:[2,4],101:[2,4],102:[2,4],105:[2,4]},{1:[2,5],9:[2,5],11:[2,5],14:[2,5],15:[2,5],22:[2,5],23:[2,5],25:[2,5],27:[2,5],28:[2,5],29:[2,5],33:[2,5],35:[2,5],36:[2,5],37:[2,5],38:[2,5],43:[2,5],44:[2,5],45:[2,5],53:[2,5],54:[2,5],55:[2,5],56:[2,5],57:[2,5],58:[2,5],60:[2,5],61:[2,5],62:[2,5],63:[2,5],64:[2,5],65:[2,5],66:[2,5],67:[2,5],68:[2,5],69:[2,5],70:[2,5],71:[2,5],76:[2,5],79:[2,5],93:[2,5],99:[2,5],100:[2,5],101:[2,5],102:[2,5],105:[2,5]},{11:[1,104]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:105,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:108,16:[1,34],18:[1,35],19:106,20:[1,36],22:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],37:[1,107],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,109],24:[1,121],25:[2,149],26:[1,124],39:110,41:118,43:[2,149],44:[2,149],45:[1,112],46:[1,116],50:[1,117],58:[1,115],95:114,96:111},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:4,18:[1,35],19:126,20:[1,36],24:[1,37],26:[1,38],27:[1,125],28:[2,56],29:[1,127],30:[1,128],31:[1,129],32:[1,130],34:[1,131],35:[1,132],36:[1,133],40:[1,27],44:[2,56],45:[1,6],46:[1,10],47:3,48:5,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],98:134,99:[1,39]},{3:135,4:[1,136],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38],103:[1,137],104:[1,138]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:139,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,59],3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:7,20:[1,36],23:[2,59],24:[1,37],26:[1,38],28:[2,59],32:[1,8],34:[1,15],35:[1,14],40:[1,27],44:[2,59],46:[1,10],48:140,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,56],3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:7,20:[1,36],24:[1,37],26:[1,38],28:[2,56],32:[1,8],34:[1,15],35:[1,14],40:[1,27],44:[2,56],46:[1,10],47:141,48:5,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{23:[1,142],44:[1,41]},{1:[2,61],23:[2,61],28:[2,61],44:[2,61]},{11:[1,143],17:144,45:[1,6]},{3:145,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:146,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,147],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:148,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:149,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:150,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:151,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:152,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:153,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:154,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:155,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:156,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:157,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:158,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:159,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:160,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:161,33:[2,54],43:[1,162],44:[2,54],45:[2,54]},{14:[2,47],22:[2,47],23:[2,47],33:[2,47],43:[2,47],44:[2,47],45:[2,47]},{14:[2,51],22:[2,51],23:[2,51],33:[2,51],36:[1,46],43:[2,51],44:[2,51],45:[2,51],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],14:[2,53],16:[1,34],18:[1,35],19:163,20:[1,36],22:[2,53],23:[2,53],24:[1,37],26:[1,38],32:[1,65],33:[2,53],34:[1,15],35:[1,14],40:[1,27],43:[2,53],44:[2,53],45:[2,53],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:164,16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],33:[2,46],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,65],9:[1,74],11:[1,75],15:[1,76],23:[2,65],28:[2,65],44:[2,65]},{1:[2,69],9:[1,74],11:[1,75],14:[2,69],15:[1,76],22:[2,69],23:[2,69],25:[2,69],27:[2,69],28:[2,69],29:[2,69],33:[2,69],36:[2,69],37:[2,69],38:[2,69],43:[2,69],44:[2,69],45:[2,69],53:[1,165],54:[2,69],57:[2,69],58:[2,69],60:[2,69],61:[2,69],62:[2,69],63:[2,69],64:[2,69],65:[2,69],66:[2,69],67:[2,69],68:[2,69],69:[2,69],70:[2,69],76:[2,69],79:[2,69],99:[2,69],101:[2,69],105:[2,69]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:167,18:[1,35],19:166,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,6],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:168,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,169],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,81],14:[2,81],22:[2,81],23:[2,81],25:[2,81],27:[2,81],28:[2,81],29:[2,81],33:[2,81],36:[2,81],37:[2,81],38:[2,81],43:[2,81],44:[2,81],45:[2,81],54:[2,81],57:[2,81],58:[2,81],60:[2,81],61:[2,81],62:[2,81],63:[2,81],64:[2,81],65:[2,81],66:[2,81],67:[2,81],68:[2,81],69:[2,81],70:[2,81],76:[2,81],79:[2,81],99:[2,81],101:[2,81],105:[2,81]},{1:[2,101],14:[2,101],22:[2,101],23:[2,101],25:[2,101],27:[2,101],28:[2,101],29:[2,101],33:[2,101],36:[2,101],37:[2,101],38:[2,101],43:[2,101],44:[2,101],45:[2,101],54:[2,101],57:[2,101],58:[2,101],60:[2,101],61:[2,101],62:[2,101],63:[2,101],64:[2,101],65:[2,101],66:[2,101],67:[2,101],68:[2,101],69:[2,101],70:[2,101],76:[2,101],79:[2,101],99:[2,101],101:[2,101],105:[2,101]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:170,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{4:[2,67],7:[2,67],8:[2,67],16:[2,67],18:[2,67],20:[2,67],24:[2,67],26:[2,67]},{4:[1,122],5:119,6:172,7:[1,123],10:171,20:[1,173],24:[1,174],26:[1,124],41:118},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:175,14:[2,46],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,9],9:[2,9],11:[2,9],14:[2,9],15:[2,9],22:[2,9],23:[2,9],25:[2,9],27:[2,9],28:[2,9],29:[2,9],33:[2,9],35:[2,9],36:[2,9],37:[2,9],38:[2,9],43:[2,9],44:[2,9],45:[2,9],53:[2,9],54:[2,9],55:[2,9],56:[2,9],57:[2,9],58:[2,9],60:[2,9],61:[2,9],62:[2,9],63:[2,9],64:[2,9],65:[2,9],66:[2,9],67:[2,9],68:[2,9],69:[2,9],70:[2,9],71:[2,9],76:[2,9],79:[2,9],93:[2,9],99:[2,9],100:[2,9],101:[2,9],102:[2,9],105:[2,9]},{1:[2,80],9:[1,74],11:[1,75],14:[2,80],15:[1,76],22:[2,80],23:[2,80],25:[2,80],27:[2,80],28:[2,80],29:[2,80],33:[2,80],36:[2,80],37:[2,80],38:[2,80],43:[2,80],44:[2,80],45:[2,80],54:[2,80],57:[2,80],58:[2,80],60:[2,80],61:[2,80],62:[2,80],63:[2,80],64:[2,80],65:[2,80],66:[2,80],67:[2,80],68:[2,80],69:[2,80],70:[2,80],76:[2,80],79:[2,80],99:[2,80],101:[2,80],105:[2,80]},{3:176,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{1:[2,85],14:[2,85],22:[2,85],23:[2,85],25:[2,85],27:[2,85],28:[2,85],29:[2,85],33:[2,85],36:[1,46],37:[2,85],38:[2,85],43:[2,85],44:[2,85],45:[2,85],54:[2,85],57:[2,85],58:[2,85],60:[2,85],61:[2,85],62:[2,85],63:[1,52],64:[2,85],65:[2,85],66:[2,85],67:[1,56],68:[2,85],69:[2,85],70:[2,85],76:[2,85],79:[2,85],99:[2,85],101:[2,85],105:[2,85]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:177,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:178,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{1:[2,86],14:[2,86],22:[2,86],23:[2,86],25:[2,86],27:[2,86],28:[2,86],29:[2,86],33:[2,86],36:[1,46],37:[2,86],38:[2,86],43:[2,86],44:[2,86],45:[2,86],54:[2,86],57:[2,86],58:[2,86],60:[2,86],61:[2,86],62:[2,86],63:[1,52],64:[2,86],65:[2,86],66:[2,86],67:[1,56],68:[2,86],69:[2,86],70:[2,86],76:[2,86],79:[2,86],99:[2,86],101:[2,86],105:[2,86]},{3:179,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{1:[2,87],14:[2,87],22:[2,87],23:[2,87],25:[2,87],27:[2,87],28:[2,87],29:[2,87],33:[2,87],36:[1,46],37:[2,87],38:[2,87],43:[2,87],44:[2,87],45:[2,87],54:[2,87],57:[2,87],58:[2,87],60:[2,87],61:[2,87],62:[2,87],63:[1,52],64:[2,87],65:[2,87],66:[2,87],67:[1,56],68:[2,87],69:[2,87],70:[2,87],76:[2,87],79:[2,87],99:[2,87],101:[2,87],105:[2,87]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:180,14:[2,46],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:181,36:[1,46],45:[1,6],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,158],14:[2,158],22:[2,158],23:[2,158],25:[2,158],27:[2,158],28:[2,158],29:[2,158],33:[2,158],36:[2,158],37:[2,158],38:[2,158],43:[2,158],44:[2,158],45:[2,158],54:[2,158],57:[2,158],58:[2,158],60:[2,158],61:[2,158],62:[2,158],63:[2,158],64:[2,158],65:[2,158],66:[2,158],67:[2,158],68:[2,158],69:[2,158],70:[2,158],75:182,76:[2,158],79:[2,158],86:[1,183],99:[2,158],101:[2,158],105:[2,158]},{79:[1,184]},{1:[2,108],14:[2,108],22:[2,108],23:[2,108],25:[2,108],27:[2,108],28:[2,108],29:[2,108],33:[2,108],36:[1,46],37:[2,108],38:[2,108],43:[2,108],44:[2,108],45:[2,108],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[2,108],76:[2,108],79:[2,108],99:[2,108],101:[2,108],105:[2,108]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:185,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,112],14:[2,112],22:[2,112],23:[2,112],25:[2,112],27:[2,112],28:[2,112],29:[2,112],33:[2,112],36:[2,112],37:[2,112],38:[2,112],43:[2,112],44:[2,112],45:[2,112],54:[2,112],57:[2,112],58:[2,112],60:[2,112],61:[2,112],62:[2,112],63:[2,112],64:[2,112],65:[2,112],66:[2,112],67:[2,112],68:[2,112],69:[2,112],70:[2,112],76:[2,112],79:[2,112],99:[2,112],101:[2,112],105:[2,112]},{43:[1,187],84:186,101:[1,96]},{1:[2,116],14:[2,116],22:[2,116],23:[2,116],25:[2,116],27:[2,116],28:[2,116],29:[2,116],33:[2,116],36:[2,116],37:[2,116],38:[2,116],43:[2,116],44:[2,116],45:[2,116],54:[2,116],57:[2,116],58:[2,116],60:[2,116],61:[2,116],62:[2,116],63:[2,116],64:[2,116],65:[2,116],66:[2,116],67:[2,116],68:[2,116],69:[2,116],70:[2,116],76:[2,116],79:[2,116],85:[1,188],86:[1,189],99:[2,116],101:[1,190],105:[2,116]},{1:[2,119],14:[2,119],22:[2,119],23:[2,119],25:[2,119],27:[2,119],28:[2,119],29:[2,119],33:[2,119],36:[2,119],37:[2,119],38:[2,119],43:[2,119],44:[2,119],45:[2,119],54:[2,119],57:[2,119],58:[2,119],60:[2,119],61:[2,119],62:[2,119],63:[2,119],64:[2,119],65:[2,119],66:[2,119],67:[2,119],68:[2,119],69:[2,119],70:[2,119],76:[2,119],79:[2,119],99:[2,119],101:[2,119],105:[2,119]},{36:[1,46],43:[2,132],45:[2,132],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],101:[2,132]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:95,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],83:191,87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,120],14:[2,120],22:[2,120],23:[2,120],25:[2,120],27:[2,120],28:[2,120],29:[2,120],33:[2,120],36:[2,120],37:[2,120],38:[2,120],43:[2,120],44:[2,120],45:[2,120],54:[2,120],57:[2,120],58:[2,120],60:[2,120],61:[2,120],62:[2,120],63:[2,120],64:[2,120],65:[2,120],66:[2,120],67:[2,120],68:[2,120],69:[2,120],70:[2,120],76:[2,120],79:[2,120],88:[1,192],89:[1,193],99:[2,120],101:[2,120],105:[2,120]},{9:[1,74],11:[1,75],15:[1,76],45:[2,191],91:194,93:[1,100],105:[2,191]},{45:[2,193],92:195,105:[1,196]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:197,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,129],14:[2,129],22:[2,129],23:[2,129],25:[2,129],27:[2,129],28:[2,129],29:[2,129],33:[2,129],36:[1,46],37:[2,129],38:[2,129],43:[2,129],44:[2,129],45:[2,129],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[2,129],76:[2,129],79:[2,129],99:[2,129],101:[2,129],105:[2,129]},{1:[2,130],14:[2,130],22:[2,130],23:[2,130],25:[2,130],27:[2,130],28:[2,130],29:[2,130],33:[2,130],36:[2,130],37:[2,130],38:[2,130],43:[2,130],44:[2,130],45:[2,130],54:[2,130],57:[2,130],58:[2,130],60:[2,130],61:[2,130],62:[2,130],63:[2,130],64:[2,130],65:[2,130],66:[2,130],67:[2,130],68:[2,130],69:[2,130],70:[2,130],76:[2,130],79:[2,130],99:[2,130],101:[2,130],105:[2,130]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:198,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:199,14:[2,46],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:200,36:[1,46],45:[1,6],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{21:201,22:[2,51],36:[1,46],37:[1,202],43:[2,51],44:[2,51],45:[2,51],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],77:203,79:[1,40],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:204,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:205,22:[2,54],43:[1,162],44:[2,54],45:[2,54]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:206,16:[1,34],18:[1,35],19:63,20:[1,36],22:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:207,25:[2,54],43:[1,208],44:[2,54]},{23:[2,150],25:[2,150],43:[2,150],44:[2,150]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,210],23:[2,149],24:[1,121],26:[1,124],39:209,41:118,43:[2,149],44:[2,149],45:[1,112],46:[1,116],50:[1,117],58:[1,115],95:114,96:111},{9:[1,212],23:[2,134],25:[2,134],43:[2,134],44:[2,134],56:[2,134],61:[2,134],97:[1,211]},{23:[2,142],25:[2,142],43:[2,142],44:[2,142],56:[1,214],61:[1,213]},{4:[1,122],5:119,7:[1,123],8:[1,216],10:215,26:[1,124],41:118},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:217,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{23:[2,148],25:[2,148],43:[2,148],44:[2,148]},{1:[2,42],9:[2,42],11:[2,42],14:[2,42],15:[2,42],22:[2,42],23:[2,42],25:[2,42],27:[2,42],28:[2,42],29:[2,42],33:[2,42],35:[2,42],36:[2,42],37:[2,42],38:[2,42],43:[2,42],44:[2,42],45:[2,42],53:[2,42],54:[2,42],55:[2,42],56:[2,42],57:[2,42],58:[2,42],60:[2,42],61:[2,42],62:[2,42],63:[2,42],64:[2,42],65:[2,42],66:[2,42],67:[2,42],68:[2,42],69:[2,42],70:[2,42],71:[2,42],76:[2,42],79:[2,42],93:[2,42],97:[2,42],99:[2,42],100:[2,42],101:[2,42],102:[2,42],105:[2,42]},{1:[2,43],9:[2,43],11:[2,43],14:[2,43],15:[2,43],22:[2,43],23:[2,43],25:[2,43],27:[2,43],28:[2,43],29:[2,43],33:[2,43],35:[2,43],36:[2,43],37:[2,43],38:[2,43],43:[2,43],44:[2,43],45:[2,43],53:[2,43],54:[2,43],55:[2,43],56:[2,43],57:[2,43],58:[2,43],60:[2,43],61:[2,43],62:[2,43],63:[2,43],64:[2,43],65:[2,43],66:[2,43],67:[2,43],68:[2,43],69:[2,43],70:[2,43],71:[2,43],76:[2,43],79:[2,43],93:[2,43],97:[2,43],99:[2,43],100:[2,43],101:[2,43],102:[2,43],105:[2,43]},{9:[1,218],23:[2,135],25:[2,135],43:[2,135],44:[2,135],56:[2,135],61:[2,135]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,210],24:[1,121],25:[2,149],26:[1,124],39:219,41:118,43:[2,149],44:[2,149],45:[1,112],46:[1,116],50:[1,117],58:[1,115],95:114,96:111},{1:[2,44],9:[2,44],11:[2,44],14:[2,44],15:[2,44],22:[2,44],23:[2,44],25:[2,44],27:[2,44],28:[2,44],29:[2,44],33:[2,44],35:[2,44],36:[2,44],37:[2,44],38:[2,44],43:[2,44],44:[2,44],45:[2,44],53:[2,44],54:[2,44],55:[2,44],56:[2,44],57:[2,44],58:[2,44],60:[2,44],61:[2,44],62:[2,44],63:[2,44],64:[2,44],65:[2,44],66:[2,44],67:[2,44],68:[2,44],69:[2,44],70:[2,44],71:[2,44],76:[2,44],79:[2,44],93:[2,44],97:[2,44],99:[2,44],100:[2,44],101:[2,44],102:[2,44],105:[2,44]},{1:[2,45],9:[2,45],11:[2,45],14:[2,45],15:[2,45],22:[2,45],23:[2,45],25:[2,45],27:[2,45],28:[2,45],29:[2,45],33:[2,45],35:[2,45],36:[2,45],37:[2,45],38:[2,45],43:[2,45],44:[2,45],45:[2,45],53:[2,45],54:[2,45],55:[2,45],56:[2,45],57:[2,45],58:[2,45],60:[2,45],61:[2,45],62:[2,45],63:[2,45],64:[2,45],65:[2,45],66:[2,45],67:[2,45],68:[2,45],69:[2,45],70:[2,45],71:[2,45],76:[2,45],79:[2,45],93:[2,45],97:[2,45],99:[2,45],100:[2,45],101:[2,45],102:[2,45],105:[2,45]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:4,18:[1,35],19:7,20:[1,36],24:[1,37],26:[1,38],28:[2,56],32:[1,8],34:[1,15],35:[1,14],40:[1,27],44:[2,56],45:[1,6],46:[1,10],47:3,48:5,50:[1,9],51:[1,11],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],98:134,99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:221,20:[1,36],24:[1,37],26:[1,38],28:[1,220],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:44,27:[1,222],28:[2,60],29:[1,223],36:[1,224],44:[2,60],45:[1,6],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:226,20:[1,36],24:[1,37],26:[1,38],28:[1,225],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{11:[1,228],28:[1,227]},{28:[1,229]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:230,16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],33:[2,46],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:79,20:[1,36],24:[1,37],26:[1,38],28:[1,231],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,80],52:12,56:[1,78],58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:77,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38],28:[1,232]},{3:233,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{28:[1,234]},{9:[1,74],11:[1,75],15:[1,76],100:[1,235]},{9:[2,1],11:[2,1],15:[2,1],43:[1,237],100:[2,1],102:[1,236],104:[1,238]},{4:[1,239]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:240,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,180],23:[2,180],25:[2,180],36:[1,46],43:[1,242],44:[2,180],45:[2,180],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,180],99:[2,180],101:[1,241]},{1:[2,58],23:[2,58],28:[2,58],44:[2,58]},{1:[2,157],28:[2,157],44:[1,41]},{1:[2,66],9:[2,66],11:[2,66],14:[2,66],15:[2,66],22:[2,66],23:[2,66],25:[2,66],27:[2,66],28:[2,66],29:[2,66],33:[2,66],35:[2,66],36:[2,66],37:[2,66],38:[2,66],43:[2,66],44:[2,66],45:[2,66],53:[2,66],54:[2,66],55:[2,66],56:[2,66],57:[2,66],58:[2,66],60:[2,66],61:[2,66],62:[2,66],63:[2,66],64:[2,66],65:[2,66],66:[2,66],67:[2,66],68:[2,66],69:[2,66],70:[2,66],71:[2,66],76:[2,66],79:[2,66],85:[2,66],86:[2,66],88:[2,66],89:[2,66],93:[2,66],99:[2,66],100:[2,66],101:[2,66],102:[2,66],105:[2,66]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:243,14:[2,46],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,71],14:[2,71],22:[2,71],23:[2,71],25:[2,71],27:[2,71],28:[2,71],29:[2,71],33:[2,71],36:[2,71],37:[2,71],38:[2,71],43:[2,71],44:[2,71],45:[2,71],54:[2,71],57:[2,71],58:[2,71],60:[2,71],61:[2,71],62:[2,71],63:[2,71],64:[2,71],65:[2,71],66:[2,71],67:[2,71],68:[2,71],69:[2,71],70:[2,71],76:[2,71],79:[2,71],99:[2,71],101:[2,71],105:[2,71]},{9:[1,74],11:[1,75],15:[1,76],36:[1,244]},{1:[2,78],14:[2,78],22:[2,78],23:[2,78],25:[2,78],27:[2,78],28:[2,78],29:[2,78],33:[2,78],36:[1,46],37:[2,78],38:[2,78],43:[2,78],44:[2,78],45:[2,78],54:[2,78],57:[2,78],58:[1,48],60:[2,78],61:[2,78],62:[1,51],63:[1,52],64:[2,78],65:[2,78],66:[2,78],67:[1,56],68:[2,78],69:[2,78],70:[2,78],76:[2,78],79:[2,78],99:[2,78],101:[2,78],105:[2,78]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:245,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,89],14:[2,89],22:[2,89],23:[2,89],25:[2,89],27:[2,89],28:[2,89],29:[2,89],33:[2,89],36:[1,46],37:[2,89],38:[2,89],43:[2,89],44:[2,89],45:[2,89],54:[2,89],57:[2,89],58:[2,89],60:[2,89],61:[2,89],62:[1,51],63:[1,52],64:[2,89],65:[2,89],66:[2,89],67:[1,56],68:[2,89],69:[2,89],70:[2,89],76:[2,89],79:[2,89],99:[2,89],101:[2,89],105:[2,89]},{1:[2,90],14:[2,90],22:[2,90],23:[2,90],25:[2,90],27:[2,90],28:[2,90],29:[2,90],33:[2,90],36:[1,46],37:[2,90],38:[2,90],43:[2,90],44:[2,90],45:[2,90],54:[2,90],57:[1,47],58:[1,48],60:[1,49],61:[2,90],62:[1,51],63:[1,52],64:[1,53],65:[2,90],66:[1,55],67:[1,56],68:[1,57],69:[2,90],70:[2,90],76:[2,90],79:[2,90],99:[2,90],101:[2,90],105:[2,90]},{1:[2,91],14:[2,91],22:[2,91],23:[2,91],25:[2,91],27:[2,91],28:[2,91],29:[2,91],33:[2,91],36:[1,46],37:[2,91],38:[2,91],43:[2,91],44:[2,91],45:[2,91],54:[2,91],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[2,91],70:[2,91],76:[2,91],79:[2,91],99:[2,91],101:[2,91],105:[2,91]},{1:[2,92],14:[2,92],22:[2,92],23:[2,92],25:[2,92],27:[2,92],28:[2,92],29:[2,92],33:[2,92],36:[1,46],37:[2,92],38:[2,92],43:[2,92],44:[2,92],45:[2,92],54:[2,92],57:[2,92],58:[2,92],60:[2,92],61:[2,92],62:[2,92],63:[1,52],64:[2,92],65:[2,92],66:[2,92],67:[1,56],68:[2,92],69:[2,92],70:[2,92],76:[2,92],79:[2,92],99:[2,92],101:[2,92],105:[2,92]},{1:[2,93],14:[2,93],22:[2,93],23:[2,93],25:[2,93],27:[2,93],28:[2,93],29:[2,93],33:[2,93],36:[1,46],37:[2,93],38:[2,93],43:[2,93],44:[2,93],45:[2,93],54:[2,93],57:[2,93],58:[2,93],60:[2,93],61:[2,93],62:[2,93],63:[1,52],64:[2,93],65:[2,93],66:[2,93],67:[1,56],68:[2,93],69:[2,93],70:[2,93],76:[2,93],79:[2,93],99:[2,93],101:[2,93],105:[2,93]},{1:[2,94],14:[2,94],22:[2,94],23:[2,94],25:[2,94],27:[2,94],28:[2,94],29:[2,94],33:[2,94],36:[1,46],37:[2,94],38:[2,94],43:[2,94],44:[2,94],45:[2,94],54:[2,94],57:[2,94],58:[1,48],60:[2,94],61:[2,94],62:[1,51],63:[1,52],64:[2,94],65:[2,94],66:[2,94],67:[1,56],68:[2,94],69:[2,94],70:[2,94],76:[2,94],79:[2,94],99:[2,94],101:[2,94],105:[2,94]},{1:[2,95],14:[2,95],22:[2,95],23:[2,95],25:[2,95],27:[2,95],28:[2,95],29:[2,95],33:[2,95],36:[1,46],37:[2,95],38:[2,95],43:[2,95],44:[2,95],45:[2,95],54:[2,95],57:[1,47],58:[1,48],60:[1,49],61:[2,95],62:[1,51],63:[1,52],64:[1,53],65:[2,95],66:[1,55],67:[1,56],68:[1,57],69:[2,95],70:[2,95],76:[2,95],79:[2,95],99:[2,95],101:[2,95],105:[2,95]},{1:[2,96],14:[2,96],22:[2,96],23:[2,96],25:[2,96],27:[2,96],28:[2,96],29:[2,96],33:[2,96],36:[1,46],37:[2,96],38:[2,96],43:[2,96],44:[2,96],45:[2,96],54:[2,96],57:[1,47],58:[1,48],60:[2,96],61:[2,96],62:[1,51],63:[1,52],64:[1,53],65:[2,96],66:[1,55],67:[1,56],68:[2,96],69:[2,96],70:[2,96],76:[2,96],79:[2,96],99:[2,96],101:[2,96],105:[2,96]},{1:[2,97],14:[2,97],22:[2,97],23:[2,97],25:[2,97],27:[2,97],28:[2,97],29:[2,97],33:[2,97],36:[1,46],37:[2,97],38:[2,97],43:[2,97],44:[2,97],45:[2,97],54:[2,97],57:[2,97],58:[2,97],60:[2,97],61:[2,97],62:[2,97],63:[2,97],64:[2,97],65:[2,97],66:[2,97],67:[1,56],68:[2,97],69:[2,97],70:[2,97],76:[2,97],79:[2,97],99:[2,97],101:[2,97],105:[2,97]},{1:[2,98],14:[2,98],22:[2,98],23:[2,98],25:[2,98],27:[2,98],28:[2,98],29:[2,98],33:[2,98],36:[1,46],37:[2,98],38:[2,98],43:[2,98],44:[2,98],45:[2,98],54:[2,98],57:[1,47],58:[1,48],60:[2,98],61:[2,98],62:[1,51],63:[1,52],64:[1,53],65:[2,98],66:[1,55],67:[1,56],68:[2,98],69:[2,98],70:[2,98],76:[2,98],79:[2,98],99:[2,98],101:[2,98],105:[2,98]},{1:[2,99],14:[2,99],22:[2,99],23:[2,99],25:[2,99],27:[2,99],28:[2,99],29:[2,99],33:[2,99],36:[1,46],37:[2,99],38:[2,99],43:[2,99],44:[2,99],45:[2,99],54:[2,99],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[2,99],70:[2,99],76:[2,99],79:[2,99],99:[2,99],101:[2,99],105:[2,99]},{1:[2,100],14:[2,100],22:[2,100],23:[2,100],25:[2,100],27:[2,100],28:[2,100],29:[2,100],33:[2,100],36:[1,46],37:[2,100],38:[2,100],43:[2,100],44:[2,100],45:[2,100],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[2,100],79:[2,100],99:[2,100],101:[2,100],105:[2,100]},{1:[2,105],14:[2,105],22:[2,105],23:[2,105],25:[2,105],27:[2,105],28:[2,105],29:[2,105],33:[2,105],36:[1,46],37:[2,105],38:[2,105],43:[2,105],44:[2,105],45:[2,105],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[2,105],79:[2,105],99:[2,105],101:[2,105],105:[2,105]},{33:[1,246],44:[1,247],45:[1,248]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],14:[2,55],16:[1,34],18:[1,35],19:63,20:[1,36],22:[2,55],23:[2,55],24:[1,37],26:[1,38],32:[1,65],33:[2,55],34:[1,15],35:[1,14],40:[1,27],42:249,44:[2,55],45:[2,55],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{14:[2,52],22:[2,52],23:[2,52],33:[2,52],36:[1,46],43:[2,52],44:[2,52],45:[2,52],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{13:250,33:[2,54],43:[1,162],44:[2,54],45:[2,54]},{4:[2,68],7:[2,68],8:[2,68],16:[2,68],18:[2,68],20:[2,68],24:[2,68],26:[2,68]},{1:[2,72],14:[2,72],22:[2,72],23:[2,72],25:[2,72],27:[2,72],28:[2,72],29:[2,72],33:[2,72],36:[1,46],37:[2,72],38:[2,72],43:[2,72],44:[2,72],45:[2,72],54:[2,72],57:[2,72],58:[1,48],60:[2,72],61:[2,72],62:[1,51],63:[1,52],64:[2,72],65:[2,72],66:[2,72],67:[1,56],68:[2,72],69:[2,72],70:[2,72],76:[2,72],79:[2,72],99:[2,72],101:[2,72],105:[2,72]},{1:[2,73],14:[2,73],22:[2,73],23:[2,73],25:[2,73],27:[2,73],28:[2,73],29:[2,73],33:[2,73],36:[2,73],37:[2,73],38:[2,73],43:[2,73],44:[2,73],45:[2,73],54:[2,73],57:[2,73],58:[2,73],60:[2,73],61:[2,73],62:[2,73],63:[2,73],64:[2,73],65:[2,73],66:[2,73],67:[2,73],68:[2,73],69:[2,73],70:[2,73],76:[2,73],79:[2,73],99:[2,73],101:[2,73],105:[2,73]},{1:[2,76],14:[2,76],22:[2,76],23:[2,76],25:[2,76],27:[2,76],28:[2,76],29:[2,76],33:[2,76],36:[1,46],37:[2,76],38:[2,76],43:[2,76],44:[2,76],45:[2,76],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[2,76],76:[2,76],79:[2,76],99:[2,76],101:[2,76],105:[2,76]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:251,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,128],14:[2,128],22:[2,128],23:[2,128],25:[2,128],27:[2,128],28:[2,128],29:[2,128],33:[2,128],36:[1,46],37:[2,128],38:[2,128],43:[2,128],44:[2,128],45:[2,128],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[2,128],76:[2,128],79:[2,128],99:[2,128],101:[2,128],105:[2,128]},{1:[2,6],9:[2,6],11:[2,6],14:[2,6],15:[2,6],22:[2,6],23:[2,6],25:[2,6],27:[2,6],28:[2,6],29:[2,6],33:[2,6],35:[2,6],36:[2,6],37:[2,6],38:[2,6],43:[2,6],44:[2,6],45:[2,6],53:[2,6],54:[2,6],55:[2,6],56:[2,6],57:[2,6],58:[2,6],60:[2,6],61:[2,6],62:[2,6],63:[2,6],64:[2,6],65:[2,6],66:[2,6],67:[2,6],68:[2,6],69:[2,6],70:[2,6],71:[2,6],76:[2,6],79:[2,6],93:[2,6],99:[2,6],100:[2,6],101:[2,6],102:[2,6],105:[2,6]},{1:[2,7],9:[2,7],11:[2,7],14:[2,7],15:[2,7],22:[2,7],23:[2,7],25:[2,7],27:[2,7],28:[2,7],29:[2,7],33:[2,7],35:[2,7],36:[2,7],37:[2,7],38:[2,7],43:[2,7],44:[2,7],45:[2,7],53:[2,7],54:[2,7],55:[2,7],56:[2,7],57:[2,7],58:[2,7],60:[2,7],61:[2,7],62:[2,7],63:[2,7],64:[2,7],65:[2,7],66:[2,7],67:[2,7],68:[2,7],69:[2,7],70:[2,7],71:[2,7],76:[2,7],79:[2,7],93:[2,7],99:[2,7],100:[2,7],101:[2,7],102:[2,7],105:[2,7]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:108,16:[1,34],18:[1,35],19:252,20:[1,36],22:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],37:[1,253],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,210],24:[1,121],25:[2,149],26:[1,124],39:110,41:118,43:[2,149],44:[2,149],45:[1,112],46:[1,116],50:[1,117],58:[1,115],95:114,96:111},{13:254,14:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,82],9:[1,74],11:[1,75],14:[2,82],15:[1,76],22:[2,82],23:[2,82],25:[2,82],27:[2,82],28:[2,82],29:[2,82],33:[2,82],36:[2,82],37:[2,82],38:[2,82],43:[2,82],44:[2,82],45:[2,82],54:[2,82],57:[2,82],58:[2,82],60:[2,82],61:[2,82],62:[2,82],63:[2,82],64:[2,82],65:[2,82],66:[2,82],67:[2,82],68:[2,82],69:[2,82],70:[2,82],76:[2,82],79:[2,82],99:[2,82],101:[2,82],105:[2,82]},{13:255,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,83],9:[1,74],11:[1,75],14:[2,83],15:[1,76],22:[2,83],23:[2,83],25:[2,83],27:[2,83],28:[2,83],29:[2,83],33:[2,83],36:[2,83],37:[2,83],38:[2,83],43:[2,83],44:[2,83],45:[2,83],54:[2,83],57:[2,83],58:[2,83],60:[2,83],61:[2,83],62:[2,83],63:[2,83],64:[2,83],65:[2,83],66:[2,83],67:[2,83],68:[2,83],69:[2,83],70:[2,83],76:[2,83],79:[2,83],99:[2,83],101:[2,83],105:[2,83]},{1:[2,84],9:[1,74],11:[1,75],14:[2,84],15:[1,76],22:[2,84],23:[2,84],25:[2,84],27:[2,84],28:[2,84],29:[2,84],33:[2,84],36:[2,84],37:[2,84],38:[2,84],43:[2,84],44:[2,84],45:[2,84],54:[2,84],57:[2,84],58:[2,84],60:[2,84],61:[2,84],62:[2,84],63:[2,84],64:[2,84],65:[2,84],66:[2,84],67:[2,84],68:[2,84],69:[2,84],70:[2,84],76:[2,84],79:[2,84],99:[2,84],101:[2,84],105:[2,84]},{13:256,14:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,158],14:[2,158],22:[2,158],23:[2,158],25:[2,158],27:[2,158],28:[2,158],29:[2,158],33:[2,158],36:[2,158],37:[2,158],38:[2,158],43:[2,158],44:[2,158],45:[2,158],54:[2,158],57:[2,158],58:[2,158],60:[2,158],61:[2,158],62:[2,158],63:[2,158],64:[2,158],65:[2,158],66:[2,158],67:[2,158],68:[2,158],69:[2,158],70:[2,158],75:257,76:[2,158],79:[2,158],86:[1,183],99:[2,158],101:[2,158],105:[2,158]},{1:[2,106],14:[2,106],22:[2,106],23:[2,106],25:[2,106],27:[2,106],28:[2,106],29:[2,106],33:[2,106],36:[2,106],37:[2,106],38:[2,106],43:[2,106],44:[2,106],45:[2,106],54:[2,106],57:[2,106],58:[2,106],60:[2,106],61:[2,106],62:[2,106],63:[2,106],64:[2,106],65:[2,106],66:[2,106],67:[2,106],68:[2,106],69:[2,106],70:[2,106],76:[2,106],79:[2,106],99:[2,106],101:[2,106],105:[2,106]},{17:258,45:[1,6],74:[1,259]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:260,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:261,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,113],14:[2,113],22:[2,113],23:[2,113],25:[2,113],27:[2,113],28:[2,113],29:[2,113],33:[2,113],36:[2,113],37:[2,113],38:[2,113],43:[2,113],44:[2,113],45:[2,113],54:[2,113],57:[2,113],58:[2,113],60:[2,113],61:[2,113],62:[2,113],63:[2,113],64:[2,113],65:[2,113],66:[2,113],67:[2,113],68:[2,113],69:[2,113],70:[2,113],76:[2,113],79:[2,113],85:[1,262],86:[1,263],99:[2,113],101:[1,190],105:[2,113]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:264,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:265,45:[1,6]},{17:266,45:[1,6]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:95,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],83:267,87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:268,43:[1,187],45:[1,6]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],17:269,18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:270,45:[1,6],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:271,45:[1,6]},{45:[2,193],92:272,105:[1,196]},{17:273,45:[1,6]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:95,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],83:274,87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{36:[1,46],45:[2,190],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],105:[2,190]},{13:275,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{13:276,14:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,11],9:[2,11],11:[2,11],14:[2,11],15:[2,11],22:[2,11],23:[2,11],25:[2,11],27:[2,11],28:[2,11],29:[2,11],33:[2,11],35:[2,11],36:[2,11],37:[2,11],38:[2,11],43:[2,11],44:[2,11],45:[2,11],53:[2,11],54:[2,11],55:[2,11],56:[2,11],57:[2,11],58:[2,11],60:[2,11],61:[2,11],62:[2,11],63:[2,11],64:[2,11],65:[2,11],66:[2,11],67:[2,11],68:[2,11],69:[2,11],70:[2,11],71:[2,11],76:[2,11],79:[2,11],93:[2,11],99:[2,11],100:[2,11],101:[2,11],102:[2,11],105:[2,11]},{22:[1,277],23:[1,278],44:[1,280],45:[1,281],77:279,79:[1,40],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:282,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,184],23:[2,184],25:[2,184],44:[2,184],45:[2,184],79:[2,184],99:[2,184]},{22:[1,283],36:[1,46],38:[1,284],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{22:[1,285],44:[1,247],45:[1,248]},{13:286,22:[2,54],43:[1,162],44:[2,54],45:[2,54]},{25:[1,287],44:[1,288]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,210],23:[2,55],24:[1,121],25:[2,55],26:[1,124],41:118,44:[2,55],46:[1,116],50:[1,117],58:[1,115],95:114,96:289},{13:290,23:[2,54],43:[1,208],44:[2,54]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:291,16:[1,34],18:[1,35],19:63,20:[1,36],22:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:292,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],45:[1,293],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{4:[1,122],7:[1,123],41:294},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:295,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:296,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{23:[2,145],25:[2,145],43:[2,145],44:[2,145]},{23:[2,146],25:[2,146],43:[2,146],44:[2,146]},{23:[2,147],25:[2,147],36:[1,46],43:[2,147],44:[2,147],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{4:[1,122],7:[1,123],41:297},{13:298,25:[2,54],43:[1,208],44:[2,54]},{1:[2,15],9:[2,15],11:[2,15],14:[2,15],15:[2,15],22:[2,15],23:[2,15],25:[2,15],27:[2,15],28:[2,15],29:[2,15],33:[2,15],35:[2,15],36:[2,15],37:[2,15],38:[2,15],43:[2,15],44:[2,15],45:[2,15],53:[2,15],54:[2,15],55:[2,15],56:[2,15],57:[2,15],58:[2,15],60:[2,15],61:[2,15],62:[2,15],63:[2,15],64:[2,15],65:[2,15],66:[2,15],67:[2,15],68:[2,15],69:[2,15],70:[2,15],71:[2,15],76:[2,15],79:[2,15],93:[2,15],99:[2,15],100:[2,15],101:[2,15],102:[2,15],105:[2,15]},{28:[1,299],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{28:[1,300]},{28:[1,301]},{3:302,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{1:[2,18],9:[2,18],11:[2,18],14:[2,18],15:[2,18],22:[2,18],23:[2,18],25:[2,18],27:[2,18],28:[2,18],29:[2,18],33:[2,18],35:[2,18],36:[2,18],37:[2,18],38:[2,18],43:[2,18],44:[2,18],45:[2,18],53:[2,18],54:[2,18],55:[2,18],56:[2,18],57:[2,18],58:[2,18],60:[2,18],61:[2,18],62:[2,18],63:[2,18],64:[2,18],65:[2,18],66:[2,18],67:[2,18],68:[2,18],69:[2,18],70:[2,18],71:[2,18],76:[2,18],79:[2,18],93:[2,18],99:[2,18],100:[2,18],101:[2,18],102:[2,18],105:[2,18]},{28:[1,303],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,21],9:[2,21],11:[2,21],14:[2,21],15:[2,21],22:[2,21],23:[2,21],25:[2,21],27:[2,21],28:[2,21],29:[2,21],33:[2,21],35:[2,21],36:[2,21],37:[2,21],38:[2,21],43:[2,21],44:[2,21],45:[2,21],53:[2,21],54:[2,21],55:[2,21],56:[2,21],57:[2,21],58:[2,21],60:[2,21],61:[2,21],62:[2,21],63:[2,21],64:[2,21],65:[2,21],66:[2,21],67:[2,21],68:[2,21],69:[2,21],70:[2,21],71:[2,21],76:[2,21],79:[2,21],93:[2,21],99:[2,21],100:[2,21],101:[2,21],102:[2,21],105:[2,21]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:304,14:[2,46],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,23],9:[2,23],11:[2,23],14:[2,23],15:[2,23],22:[2,23],23:[2,23],25:[2,23],27:[2,23],28:[2,23],29:[2,23],33:[2,23],35:[2,23],36:[2,23],37:[2,23],38:[2,23],43:[2,23],44:[2,23],45:[2,23],53:[2,23],54:[2,23],55:[2,23],56:[2,23],57:[2,23],58:[2,23],60:[2,23],61:[2,23],62:[2,23],63:[2,23],64:[2,23],65:[2,23],66:[2,23],67:[2,23],68:[2,23],69:[2,23],70:[2,23],71:[2,23],76:[2,23],79:[2,23],93:[2,23],99:[2,23],100:[2,23],101:[2,23],102:[2,23],105:[2,23]},{13:305,33:[2,54],43:[1,162],44:[2,54],45:[2,54]},{1:[2,25],9:[2,25],11:[2,25],14:[2,25],15:[2,25],22:[2,25],23:[2,25],25:[2,25],27:[2,25],28:[2,25],29:[2,25],33:[2,25],35:[2,25],36:[2,25],37:[2,25],38:[2,25],43:[2,25],44:[2,25],45:[2,25],53:[2,25],54:[2,25],55:[2,25],56:[2,25],57:[2,25],58:[2,25],60:[2,25],61:[2,25],62:[2,25],63:[2,25],64:[2,25],65:[2,25],66:[2,25],67:[2,25],68:[2,25],69:[2,25],70:[2,25],71:[2,25],76:[2,25],79:[2,25],93:[2,25],99:[2,25],100:[2,25],101:[2,25],102:[2,25],105:[2,25]},{1:[2,26],9:[2,26],11:[2,26],14:[2,26],15:[2,26],22:[2,26],23:[2,26],25:[2,26],27:[2,26],28:[2,26],29:[2,26],33:[2,26],35:[2,26],36:[2,26],37:[2,26],38:[2,26],43:[2,26],44:[2,26],45:[2,26],53:[2,26],54:[2,26],55:[2,26],56:[2,26],57:[2,26],58:[2,26],60:[2,26],61:[2,26],62:[2,26],63:[2,26],64:[2,26],65:[2,26],66:[2,26],67:[2,26],68:[2,26],69:[2,26],70:[2,26],71:[2,26],76:[2,26],79:[2,26],93:[2,26],99:[2,26],100:[2,26],101:[2,26],102:[2,26],105:[2,26]},{9:[1,74],11:[1,75],15:[1,76],36:[1,306]},{1:[2,154],9:[2,154],11:[2,154],14:[2,154],15:[2,154],22:[2,154],23:[2,154],25:[2,154],27:[2,154],28:[2,154],29:[2,154],33:[2,154],35:[2,154],36:[2,154],37:[2,154],38:[2,154],43:[2,154],44:[2,154],45:[2,154],53:[2,154],54:[2,154],55:[2,154],56:[2,154],57:[2,154],58:[2,154],60:[2,154],61:[2,154],62:[2,154],63:[2,154],64:[2,154],65:[2,154],66:[2,154],67:[2,154],68:[2,154],69:[2,154],70:[2,154],71:[2,154],76:[2,154],79:[2,154],93:[2,154],97:[2,154],99:[2,154],100:[2,154],101:[2,154],102:[2,154],105:[2,154]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:307,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:308,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:309,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:310,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{43:[1,312],102:[1,311]},{36:[1,46],37:[1,313],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:314,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:315,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:316,14:[2,54],43:[1,162],44:[2,54],45:[2,54]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:317,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{13:318,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{49:[1,319],72:[1,320]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:63,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:321,46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:322,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{14:[2,48],22:[2,48],23:[2,48],33:[2,48],43:[2,48],44:[2,48],45:[2,48]},{33:[1,323],44:[1,247],45:[1,248]},{13:324,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{22:[2,51],36:[1,46],37:[1,325],43:[2,51],44:[2,51],45:[2,51],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:326,20:[1,36],22:[1,327],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{14:[1,328],44:[1,247],45:[1,248]},{23:[1,329],44:[1,247],45:[1,248]},{14:[1,330],44:[1,247],45:[1,248]},{1:[2,104],14:[2,104],22:[2,104],23:[2,104],25:[2,104],27:[2,104],28:[2,104],29:[2,104],33:[2,104],36:[2,104],37:[2,104],38:[2,104],43:[2,104],44:[2,104],45:[2,104],54:[2,104],57:[2,104],58:[2,104],60:[2,104],61:[2,104],62:[2,104],63:[2,104],64:[2,104],65:[2,104],66:[2,104],67:[2,104],68:[2,104],69:[2,104],70:[2,104],76:[2,104],79:[2,104],99:[2,104],101:[2,104],105:[2,104]},{1:[2,159],14:[2,159],22:[2,159],23:[2,159],25:[2,159],27:[2,159],28:[2,159],29:[2,159],33:[2,159],36:[2,159],37:[2,159],38:[2,159],43:[2,159],44:[2,159],45:[2,159],54:[2,159],57:[2,159],58:[2,159],60:[2,159],61:[2,159],62:[2,159],63:[2,159],64:[2,159],65:[2,159],66:[2,159],67:[2,159],68:[2,159],69:[2,159],70:[2,159],76:[2,159],79:[2,159],99:[2,159],101:[2,159],105:[2,159]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:331,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,107],14:[2,107],22:[2,107],23:[2,107],25:[2,107],27:[2,107],28:[2,107],29:[2,107],33:[2,107],36:[1,46],37:[2,107],38:[2,107],43:[2,107],44:[2,107],45:[2,107],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[2,107],79:[2,107],99:[2,107],101:[2,107],105:[2,107]},{23:[1,332],44:[1,247],45:[1,248]},{17:333,45:[1,6]},{17:334,45:[1,6]},{36:[1,46],43:[2,133],45:[2,133],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],101:[2,133]},{1:[2,117],14:[2,117],22:[2,117],23:[2,117],25:[2,117],27:[2,117],28:[2,117],29:[2,117],33:[2,117],36:[2,117],37:[2,117],38:[2,117],43:[2,117],44:[2,117],45:[2,117],54:[2,117],57:[2,117],58:[2,117],60:[2,117],61:[2,117],62:[2,117],63:[2,117],64:[2,117],65:[2,117],66:[2,117],67:[2,117],68:[2,117],69:[2,117],70:[2,117],76:[2,117],79:[2,117],99:[2,117],101:[2,117],105:[2,117]},{1:[2,118],14:[2,118],22:[2,118],23:[2,118],25:[2,118],27:[2,118],28:[2,118],29:[2,118],33:[2,118],36:[2,118],37:[2,118],38:[2,118],43:[2,118],44:[2,118],45:[2,118],54:[2,118],57:[2,118],58:[2,118],60:[2,118],61:[2,118],62:[2,118],63:[2,118],64:[2,118],65:[2,118],66:[2,118],67:[2,118],68:[2,118],69:[2,118],70:[2,118],76:[2,118],79:[2,118],99:[2,118],101:[2,118],105:[2,118]},{17:335,43:[1,187],45:[1,6]},{1:[2,188],14:[2,188],22:[2,188],23:[2,188],25:[2,188],27:[2,188],28:[2,188],29:[2,188],33:[2,188],36:[2,188],37:[2,188],38:[2,188],43:[2,188],44:[2,188],45:[2,188],54:[2,188],57:[2,188],58:[2,188],60:[2,188],61:[2,188],62:[2,188],63:[2,188],64:[2,188],65:[2,188],66:[2,188],67:[2,188],68:[2,188],69:[2,188],70:[2,188],76:[2,188],79:[2,188],85:[2,188],86:[2,188],99:[2,188],101:[2,188],105:[2,188]},{1:[2,121],14:[2,121],22:[2,121],23:[2,121],25:[2,121],27:[2,121],28:[2,121],29:[2,121],33:[2,121],36:[2,121],37:[2,121],38:[2,121],43:[2,121],44:[2,121],45:[2,121],54:[2,121],57:[2,121],58:[2,121],60:[2,121],61:[2,121],62:[2,121],63:[2,121],64:[2,121],65:[2,121],66:[2,121],67:[2,121],68:[2,121],69:[2,121],70:[2,121],76:[2,121],79:[2,121],89:[1,336],99:[2,121],101:[2,121],105:[2,121]},{17:337,45:[1,6]},{1:[2,125],14:[2,125],22:[2,125],23:[2,125],25:[2,125],27:[2,125],28:[2,125],29:[2,125],33:[2,125],36:[2,125],37:[2,125],38:[2,125],43:[2,125],44:[2,125],45:[2,125],54:[2,125],57:[2,125],58:[2,125],60:[2,125],61:[2,125],62:[2,125],63:[2,125],64:[2,125],65:[2,125],66:[2,125],67:[2,125],68:[2,125],69:[2,125],70:[2,125],76:[2,125],79:[2,125],99:[2,125],101:[2,125],105:[2,125]},{17:338,45:[1,6]},{1:[2,127],14:[2,127],22:[2,127],23:[2,127],25:[2,127],27:[2,127],28:[2,127],29:[2,127],33:[2,127],36:[2,127],37:[2,127],38:[2,127],43:[2,127],44:[2,127],45:[2,127],54:[2,127],57:[2,127],58:[2,127],60:[2,127],61:[2,127],62:[2,127],63:[2,127],64:[2,127],65:[2,127],66:[2,127],67:[2,127],68:[2,127],69:[2,127],70:[2,127],76:[2,127],79:[2,127],99:[2,127],101:[2,127],105:[2,127]},{43:[1,187],45:[2,192]},{23:[1,339],44:[1,247],45:[1,248]},{14:[1,340],44:[1,247],45:[1,248]},{1:[2,12],9:[2,12],11:[2,12],14:[2,12],15:[2,12],22:[2,12],23:[2,12],25:[2,12],27:[2,12],28:[2,12],29:[2,12],33:[2,12],35:[2,12],36:[2,12],37:[2,12],38:[2,12],43:[2,12],44:[2,12],45:[2,12],53:[2,12],54:[2,12],55:[2,12],56:[2,12],57:[2,12],58:[2,12],60:[2,12],61:[2,12],62:[2,12],63:[2,12],64:[2,12],65:[2,12],66:[2,12],67:[2,12],68:[2,12],69:[2,12],70:[2,12],71:[2,12],76:[2,12],79:[2,12],93:[2,12],99:[2,12],100:[2,12],101:[2,12],102:[2,12],105:[2,12]},{22:[1,341]},{22:[2,185],23:[2,185],25:[2,185],44:[2,185],45:[2,185],79:[2,185],99:[2,185]},{77:342,79:[1,40],99:[1,39]},{77:343,79:[1,40],99:[1,39]},{22:[1,344],36:[1,46],38:[1,345],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,32],9:[2,32],11:[2,32],14:[2,32],15:[2,32],22:[2,32],23:[2,32],25:[2,32],27:[2,32],28:[2,32],29:[2,32],33:[2,32],35:[2,32],36:[2,32],37:[2,32],38:[2,32],43:[2,32],44:[2,32],45:[2,32],53:[2,32],54:[2,32],55:[2,32],56:[2,32],57:[2,32],58:[2,32],60:[2,32],61:[2,32],62:[2,32],63:[2,32],64:[2,32],65:[2,32],66:[2,32],67:[2,32],68:[2,32],69:[2,32],70:[2,32],71:[2,32],76:[2,32],79:[2,32],93:[2,32],99:[2,32],100:[2,32],101:[2,32],102:[2,32],105:[2,32]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:346,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,38],9:[2,38],11:[2,38],14:[2,38],15:[2,38],22:[2,38],23:[2,38],25:[2,38],27:[2,38],28:[2,38],29:[2,38],33:[2,38],35:[2,38],36:[2,38],37:[2,38],38:[2,38],40:[1,347],43:[2,38],44:[2,38],45:[2,38],53:[2,38],54:[2,38],55:[2,38],56:[2,38],57:[2,38],58:[2,38],60:[2,38],61:[2,38],62:[2,38],63:[2,38],64:[2,38],65:[2,38],66:[2,38],67:[2,38],68:[2,38],69:[2,38],70:[2,38],71:[2,38],76:[2,38],79:[2,38],93:[2,38],99:[2,38],100:[2,38],101:[2,38],102:[2,38],105:[2,38]},{22:[1,348],44:[1,247],45:[1,248]},{1:[2,39],9:[2,39],11:[2,39],14:[2,39],15:[2,39],22:[2,39],23:[2,39],25:[2,39],27:[2,39],28:[2,39],29:[2,39],33:[2,39],35:[2,39],36:[2,39],37:[2,39],38:[2,39],40:[1,349],43:[2,39],44:[2,39],45:[2,39],53:[2,39],54:[2,39],55:[2,39],56:[2,39],57:[2,39],58:[2,39],60:[2,39],61:[2,39],62:[2,39],63:[2,39],64:[2,39],65:[2,39],66:[2,39],67:[2,39],68:[2,39],69:[2,39],70:[2,39],71:[2,39],76:[2,39],79:[2,39],93:[2,39],99:[2,39],100:[2,39],101:[2,39],102:[2,39],105:[2,39]},{4:[1,122],5:119,7:[1,123],8:[1,120],10:113,20:[1,210],24:[1,121],26:[1,124],41:118,46:[1,116],50:[1,117],58:[1,115],95:114,96:350},{23:[2,151],25:[2,151],43:[2,151],44:[2,151]},{23:[1,351],44:[1,288]},{13:352,22:[2,54],43:[1,162],44:[2,54],45:[2,54]},{23:[2,140],25:[2,140],36:[1,46],43:[2,140],44:[2,140],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],12:353,16:[1,34],18:[1,35],19:63,20:[1,36],23:[2,46],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],42:62,43:[2,46],44:[2,46],45:[2,46],46:[1,64],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{23:[2,136],25:[2,136],43:[2,136],44:[2,136],56:[2,136],61:[2,136]},{23:[2,143],25:[2,143],36:[1,46],43:[2,143],44:[2,143],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{23:[2,144],25:[2,144],36:[1,46],43:[2,144],44:[2,144],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{23:[2,137],25:[2,137],43:[2,137],44:[2,137],56:[2,137],61:[2,137]},{25:[1,354],44:[1,288]},{1:[2,16],9:[2,16],11:[2,16],14:[2,16],15:[2,16],22:[2,16],23:[2,16],25:[2,16],27:[2,16],28:[2,16],29:[2,16],33:[2,16],35:[2,16],36:[2,16],37:[2,16],38:[2,16],43:[2,16],44:[2,16],45:[2,16],53:[2,16],54:[2,16],55:[2,16],56:[2,16],57:[2,16],58:[2,16],60:[2,16],61:[2,16],62:[2,16],63:[2,16],64:[2,16],65:[2,16],66:[2,16],67:[2,16],68:[2,16],69:[2,16],70:[2,16],71:[2,16],76:[2,16],79:[2,16],93:[2,16],99:[2,16],100:[2,16],101:[2,16],102:[2,16],105:[2,16]},{1:[2,17],9:[2,17],11:[2,17],14:[2,17],15:[2,17],22:[2,17],23:[2,17],25:[2,17],27:[2,17],28:[2,17],29:[2,17],33:[2,17],35:[2,17],36:[2,17],37:[2,17],38:[2,17],43:[2,17],44:[2,17],45:[2,17],53:[2,17],54:[2,17],55:[2,17],56:[2,17],57:[2,17],58:[2,17],60:[2,17],61:[2,17],62:[2,17],63:[2,17],64:[2,17],65:[2,17],66:[2,17],67:[2,17],68:[2,17],69:[2,17],70:[2,17],71:[2,17],76:[2,17],79:[2,17],93:[2,17],99:[2,17],100:[2,17],101:[2,17],102:[2,17],105:[2,17]},{1:[2,20],9:[2,20],11:[2,20],14:[2,20],15:[2,20],22:[2,20],23:[2,20],25:[2,20],27:[2,20],28:[2,20],29:[2,20],33:[2,20],35:[2,20],36:[2,20],37:[2,20],38:[2,20],43:[2,20],44:[2,20],45:[2,20],53:[2,20],54:[2,20],55:[2,20],56:[2,20],57:[2,20],58:[2,20],60:[2,20],61:[2,20],62:[2,20],63:[2,20],64:[2,20],65:[2,20],66:[2,20],67:[2,20],68:[2,20],69:[2,20],70:[2,20],71:[2,20],76:[2,20],79:[2,20],93:[2,20],99:[2,20],100:[2,20],101:[2,20],102:[2,20],105:[2,20]},{9:[1,74],11:[1,75],15:[1,76],36:[1,355]},{1:[2,19],9:[2,19],11:[2,19],14:[2,19],15:[2,19],22:[2,19],23:[2,19],25:[2,19],27:[2,19],28:[2,19],29:[2,19],33:[2,19],35:[2,19],36:[2,19],37:[2,19],38:[2,19],43:[2,19],44:[2,19],45:[2,19],53:[2,19],54:[2,19],55:[2,19],56:[2,19],57:[2,19],58:[2,19],60:[2,19],61:[2,19],62:[2,19],63:[2,19],64:[2,19],65:[2,19],66:[2,19],67:[2,19],68:[2,19],69:[2,19],70:[2,19],71:[2,19],76:[2,19],79:[2,19],93:[2,19],99:[2,19],100:[2,19],101:[2,19],102:[2,19],105:[2,19]},{13:356,14:[2,54],43:[1,162],44:[2,54],45:[2,54]},{33:[1,357],44:[1,247],45:[1,248]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:359,20:[1,36],24:[1,37],26:[1,38],28:[1,358],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,161],23:[2,161],25:[2,161],36:[1,46],38:[1,361],44:[2,161],45:[2,161],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,161],99:[2,161],101:[1,360]},{22:[2,165],23:[2,165],25:[2,165],36:[1,46],44:[2,165],45:[2,165],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,165],99:[2,165],101:[1,362]},{9:[1,74],11:[1,75],15:[1,76],102:[1,363]},{36:[1,46],37:[1,364],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:365,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:366,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],20:[1,36],24:[1,37],26:[1,38]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:367,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,181],23:[2,181],25:[2,181],36:[1,46],44:[2,181],45:[2,181],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,181],99:[2,181]},{22:[2,182],23:[2,182],25:[2,182],36:[1,46],44:[2,182],45:[2,182],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,182],99:[2,182],101:[1,368]},{14:[1,369],44:[1,247],45:[1,248]},{1:[2,74],14:[2,74],22:[2,74],23:[2,74],25:[2,74],27:[2,74],28:[2,74],29:[2,74],33:[2,74],36:[2,74],37:[2,74],38:[2,74],43:[2,74],44:[2,74],45:[2,74],54:[2,74],57:[2,74],58:[2,74],60:[2,74],61:[2,74],62:[2,74],63:[2,74],64:[2,74],65:[2,74],66:[2,74],67:[2,74],68:[2,74],69:[2,74],70:[2,74],76:[2,74],79:[2,74],99:[2,74],101:[2,74],105:[2,74]},{23:[1,370],44:[1,247],45:[1,248]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:371,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{17:372,45:[1,6]},{14:[2,49],22:[2,49],23:[2,49],33:[2,49],43:[2,49],44:[2,49],45:[2,49]},{13:373,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{72:[1,320]},{23:[1,374],44:[1,247],45:[1,248]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:375,20:[1,36],22:[1,376],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[1,377],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,37],9:[2,37],11:[2,37],14:[2,37],15:[2,37],22:[2,37],23:[2,37],25:[2,37],27:[2,37],28:[2,37],29:[2,37],33:[2,37],35:[2,37],36:[2,37],37:[2,37],38:[2,37],43:[2,37],44:[2,37],45:[2,37],53:[2,37],54:[2,37],55:[2,37],56:[2,37],57:[2,37],58:[2,37],60:[2,37],61:[2,37],62:[2,37],63:[2,37],64:[2,37],65:[2,37],66:[2,37],67:[2,37],68:[2,37],69:[2,37],70:[2,37],71:[2,37],76:[2,37],79:[2,37],93:[2,37],99:[2,37],100:[2,37],101:[2,37],102:[2,37],105:[2,37]},{1:[2,8],9:[2,8],11:[2,8],14:[2,8],15:[2,8],22:[2,8],23:[2,8],25:[2,8],27:[2,8],28:[2,8],29:[2,8],33:[2,8],35:[2,8],36:[2,8],37:[2,8],38:[2,8],43:[2,8],44:[2,8],45:[2,8],53:[2,8],54:[2,8],55:[2,8],56:[2,8],57:[2,8],58:[2,8],60:[2,8],61:[2,8],62:[2,8],63:[2,8],64:[2,8],65:[2,8],66:[2,8],67:[2,8],68:[2,8],69:[2,8],70:[2,8],71:[2,8],76:[2,8],79:[2,8],93:[2,8],99:[2,8],100:[2,8],101:[2,8],102:[2,8],105:[2,8]},{1:[2,88],14:[2,88],22:[2,88],23:[2,88],25:[2,88],27:[2,88],28:[2,88],29:[2,88],33:[2,88],36:[2,88],37:[2,88],38:[2,88],43:[2,88],44:[2,88],45:[2,88],54:[2,88],57:[2,88],58:[2,88],60:[2,88],61:[2,88],62:[2,88],63:[2,88],64:[2,88],65:[2,88],66:[2,88],67:[2,88],68:[2,88],69:[2,88],70:[2,88],76:[2,88],79:[2,88],99:[2,88],101:[2,88],105:[2,88]},{17:378,45:[1,6]},{17:379,36:[1,46],45:[1,6],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,109],14:[2,109],22:[2,109],23:[2,109],25:[2,109],27:[2,109],28:[2,109],29:[2,109],33:[2,109],36:[2,109],37:[2,109],38:[2,109],43:[2,109],44:[2,109],45:[2,109],54:[2,109],57:[2,109],58:[2,109],60:[2,109],61:[2,109],62:[2,109],63:[2,109],64:[2,109],65:[2,109],66:[2,109],67:[2,109],68:[2,109],69:[2,109],70:[2,109],76:[2,109],79:[2,109],99:[2,109],101:[2,109],105:[2,109]},{1:[2,114],14:[2,114],22:[2,114],23:[2,114],25:[2,114],27:[2,114],28:[2,114],29:[2,114],33:[2,114],36:[2,114],37:[2,114],38:[2,114],43:[2,114],44:[2,114],45:[2,114],54:[2,114],57:[2,114],58:[2,114],60:[2,114],61:[2,114],62:[2,114],63:[2,114],64:[2,114],65:[2,114],66:[2,114],67:[2,114],68:[2,114],69:[2,114],70:[2,114],76:[2,114],79:[2,114],99:[2,114],101:[2,114],105:[2,114]},{1:[2,115],14:[2,115],22:[2,115],23:[2,115],25:[2,115],27:[2,115],28:[2,115],29:[2,115],33:[2,115],36:[2,115],37:[2,115],38:[2,115],43:[2,115],44:[2,115],45:[2,115],54:[2,115],57:[2,115],58:[2,115],60:[2,115],61:[2,115],62:[2,115],63:[2,115],64:[2,115],65:[2,115],66:[2,115],67:[2,115],68:[2,115],69:[2,115],70:[2,115],76:[2,115],79:[2,115],99:[2,115],101:[2,115],105:[2,115]},{1:[2,189],14:[2,189],22:[2,189],23:[2,189],25:[2,189],27:[2,189],28:[2,189],29:[2,189],33:[2,189],36:[2,189],37:[2,189],38:[2,189],43:[2,189],44:[2,189],45:[2,189],54:[2,189],57:[2,189],58:[2,189],60:[2,189],61:[2,189],62:[2,189],63:[2,189],64:[2,189],65:[2,189],66:[2,189],67:[2,189],68:[2,189],69:[2,189],70:[2,189],76:[2,189],79:[2,189],85:[2,189],86:[2,189],99:[2,189],101:[2,189],105:[2,189]},{17:380,45:[1,6]},{1:[2,123],14:[2,123],22:[2,123],23:[2,123],25:[2,123],27:[2,123],28:[2,123],29:[2,123],33:[2,123],36:[2,123],37:[2,123],38:[2,123],43:[2,123],44:[2,123],45:[2,123],54:[2,123],57:[2,123],58:[2,123],60:[2,123],61:[2,123],62:[2,123],63:[2,123],64:[2,123],65:[2,123],66:[2,123],67:[2,123],68:[2,123],69:[2,123],70:[2,123],76:[2,123],79:[2,123],89:[1,381],99:[2,123],101:[2,123],105:[2,123]},{1:[2,126],14:[2,126],22:[2,126],23:[2,126],25:[2,126],27:[2,126],28:[2,126],29:[2,126],33:[2,126],36:[2,126],37:[2,126],38:[2,126],43:[2,126],44:[2,126],45:[2,126],54:[2,126],57:[2,126],58:[2,126],60:[2,126],61:[2,126],62:[2,126],63:[2,126],64:[2,126],65:[2,126],66:[2,126],67:[2,126],68:[2,126],69:[2,126],70:[2,126],76:[2,126],79:[2,126],99:[2,126],101:[2,126],105:[2,126]},{1:[2,131],14:[2,131],22:[2,131],23:[2,131],25:[2,131],27:[2,131],28:[2,131],29:[2,131],33:[2,131],36:[2,131],37:[2,131],38:[2,131],43:[2,131],44:[2,131],45:[2,131],54:[2,131],57:[2,131],58:[2,131],60:[2,131],61:[2,131],62:[2,131],63:[2,131],64:[2,131],65:[2,131],66:[2,131],67:[2,131],68:[2,131],69:[2,131],70:[2,131],76:[2,131],79:[2,131],99:[2,131],101:[2,131],105:[2,131]},{17:382,45:[1,6]},{1:[2,13],9:[2,13],11:[2,13],14:[2,13],15:[2,13],22:[2,13],23:[2,13],25:[2,13],27:[2,13],28:[2,13],29:[2,13],33:[2,13],35:[2,13],36:[2,13],37:[2,13],38:[2,13],43:[2,13],44:[2,13],45:[2,13],53:[2,13],54:[2,13],55:[2,13],56:[2,13],57:[2,13],58:[2,13],60:[2,13],61:[2,13],62:[2,13],63:[2,13],64:[2,13],65:[2,13],66:[2,13],67:[2,13],68:[2,13],69:[2,13],70:[2,13],71:[2,13],76:[2,13],79:[2,13],93:[2,13],99:[2,13],100:[2,13],101:[2,13],102:[2,13],105:[2,13]},{22:[2,186],23:[2,186],25:[2,186],44:[2,186],45:[2,186],79:[2,186],99:[2,186]},{22:[2,187],23:[2,187],25:[2,187],44:[2,187],45:[2,187],79:[2,187],99:[2,187]},{1:[2,30],9:[2,30],11:[2,30],14:[2,30],15:[2,30],22:[2,30],23:[2,30],25:[2,30],27:[2,30],28:[2,30],29:[2,30],33:[2,30],35:[2,30],36:[2,30],37:[2,30],38:[2,30],43:[2,30],44:[2,30],45:[2,30],53:[2,30],54:[2,30],55:[2,30],56:[2,30],57:[2,30],58:[2,30],60:[2,30],61:[2,30],62:[2,30],63:[2,30],64:[2,30],65:[2,30],66:[2,30],67:[2,30],68:[2,30],69:[2,30],70:[2,30],71:[2,30],76:[2,30],79:[2,30],93:[2,30],99:[2,30],100:[2,30],101:[2,30],102:[2,30],105:[2,30]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:383,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[1,384],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,40],9:[2,40],11:[2,40],14:[2,40],15:[2,40],22:[2,40],23:[2,40],25:[2,40],27:[2,40],28:[2,40],29:[2,40],33:[2,40],35:[2,40],36:[2,40],37:[2,40],38:[2,40],43:[2,40],44:[2,40],45:[2,40],53:[2,40],54:[2,40],55:[2,40],56:[2,40],57:[2,40],58:[2,40],60:[2,40],61:[2,40],62:[2,40],63:[2,40],64:[2,40],65:[2,40],66:[2,40],67:[2,40],68:[2,40],69:[2,40],70:[2,40],71:[2,40],76:[2,40],79:[2,40],93:[2,40],99:[2,40],100:[2,40],101:[2,40],102:[2,40],105:[2,40]},{21:385,40:[1,386],77:203,79:[1,40],99:[1,39]},{1:[2,41],9:[2,41],11:[2,41],14:[2,41],15:[2,41],22:[2,41],23:[2,41],25:[2,41],27:[2,41],28:[2,41],29:[2,41],33:[2,41],35:[2,41],36:[2,41],37:[2,41],38:[2,41],43:[2,41],44:[2,41],45:[2,41],53:[2,41],54:[2,41],55:[2,41],56:[2,41],57:[2,41],58:[2,41],60:[2,41],61:[2,41],62:[2,41],63:[2,41],64:[2,41],65:[2,41],66:[2,41],67:[2,41],68:[2,41],69:[2,41],70:[2,41],71:[2,41],76:[2,41],79:[2,41],93:[2,41],99:[2,41],100:[2,41],101:[2,41],102:[2,41],105:[2,41]},{23:[2,152],25:[2,152],43:[2,152],44:[2,152]},{23:[2,153],25:[2,153],43:[2,153],44:[2,153]},{22:[1,387],44:[1,247],45:[1,248]},{13:388,23:[2,54],43:[1,162],44:[2,54],45:[2,54]},{40:[1,389]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:317,20:[1,36],24:[1,37],26:[1,38],28:[1,390],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{14:[1,391],44:[1,247],45:[1,248]},{31:[1,392],49:[1,319],72:[1,320]},{1:[2,27],9:[2,27],11:[2,27],14:[2,27],15:[2,27],22:[2,27],23:[2,27],25:[2,27],27:[2,27],28:[2,27],29:[2,27],33:[2,27],35:[2,27],36:[2,27],37:[2,27],38:[2,27],43:[2,27],44:[2,27],45:[2,27],53:[2,27],54:[2,27],55:[2,27],56:[2,27],57:[2,27],58:[2,27],60:[2,27],61:[2,27],62:[2,27],63:[2,27],64:[2,27],65:[2,27],66:[2,27],67:[2,27],68:[2,27],69:[2,27],70:[2,27],71:[2,27],76:[2,27],79:[2,27],93:[2,27],99:[2,27],100:[2,27],101:[2,27],102:[2,27],105:[2,27]},{28:[1,393],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:394,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:395,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:396,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:397,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:398,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,169],23:[2,169],25:[2,169],36:[1,46],44:[2,169],45:[2,169],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,169],99:[2,169],101:[1,399]},{9:[1,74],11:[1,75],15:[1,76],102:[1,400]},{22:[2,174],23:[2,174],25:[2,174],36:[1,46],44:[2,174],45:[2,174],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,174],99:[2,174],101:[1,401]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:402,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{1:[2,70],14:[2,70],22:[2,70],23:[2,70],25:[2,70],27:[2,70],28:[2,70],29:[2,70],33:[2,70],36:[2,70],37:[2,70],38:[2,70],43:[2,70],44:[2,70],45:[2,70],54:[2,70],57:[2,70],58:[2,70],60:[2,70],61:[2,70],62:[2,70],63:[2,70],64:[2,70],65:[2,70],66:[2,70],67:[2,70],68:[2,70],69:[2,70],70:[2,70],76:[2,70],79:[2,70],99:[2,70],101:[2,70],105:[2,70]},{1:[2,79],14:[2,79],22:[2,79],23:[2,79],25:[2,79],27:[2,79],28:[2,79],29:[2,79],33:[2,79],36:[2,79],37:[2,79],38:[2,79],43:[2,79],44:[2,79],45:[2,79],54:[2,79],57:[2,79],58:[2,79],60:[2,79],61:[2,79],62:[2,79],63:[2,79],64:[2,79],65:[2,79],66:[2,79],67:[2,79],68:[2,79],69:[2,79],70:[2,79],76:[2,79],79:[2,79],99:[2,79],101:[2,79],105:[2,79]},{1:[2,62],23:[2,62],28:[2,62],36:[1,46],44:[2,62],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,102],14:[2,102],22:[2,102],23:[2,102],25:[2,102],27:[2,102],28:[2,102],29:[2,102],33:[2,102],36:[2,102],37:[2,102],38:[2,102],43:[2,102],44:[2,102],45:[2,102],54:[2,102],57:[2,102],58:[2,102],60:[2,102],61:[2,102],62:[2,102],63:[2,102],64:[2,102],65:[2,102],66:[2,102],67:[2,102],68:[2,102],69:[2,102],70:[2,102],76:[2,102],79:[2,102],99:[2,102],101:[2,102],105:[2,102]},{23:[1,403],44:[1,247],45:[1,248]},{1:[2,77],14:[2,77],22:[2,77],23:[2,77],25:[2,77],27:[2,77],28:[2,77],29:[2,77],33:[2,77],36:[2,77],37:[2,77],38:[2,77],43:[2,77],44:[2,77],45:[2,77],54:[2,77],57:[2,77],58:[2,77],60:[2,77],61:[2,77],62:[2,77],63:[2,77],64:[2,77],65:[2,77],66:[2,77],67:[2,77],68:[2,77],69:[2,77],70:[2,77],76:[2,77],79:[2,77],99:[2,77],101:[2,77],105:[2,77]},{22:[1,404],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,35],9:[2,35],11:[2,35],14:[2,35],15:[2,35],22:[2,35],23:[2,35],25:[2,35],27:[2,35],28:[2,35],29:[2,35],33:[2,35],35:[2,35],36:[2,35],37:[2,35],38:[2,35],43:[2,35],44:[2,35],45:[2,35],53:[2,35],54:[2,35],55:[2,35],56:[2,35],57:[2,35],58:[2,35],60:[2,35],61:[2,35],62:[2,35],63:[2,35],64:[2,35],65:[2,35],66:[2,35],67:[2,35],68:[2,35],69:[2,35],70:[2,35],71:[2,35],76:[2,35],79:[2,35],93:[2,35],99:[2,35],100:[2,35],101:[2,35],102:[2,35],105:[2,35]},{1:[2,36],9:[2,36],11:[2,36],14:[2,36],15:[2,36],22:[2,36],23:[2,36],25:[2,36],27:[2,36],28:[2,36],29:[2,36],33:[2,36],35:[2,36],36:[2,36],37:[2,36],38:[2,36],43:[2,36],44:[2,36],45:[2,36],53:[2,36],54:[2,36],55:[2,36],56:[2,36],57:[2,36],58:[2,36],60:[2,36],61:[2,36],62:[2,36],63:[2,36],64:[2,36],65:[2,36],66:[2,36],67:[2,36],68:[2,36],69:[2,36],70:[2,36],71:[2,36],76:[2,36],79:[2,36],93:[2,36],99:[2,36],100:[2,36],101:[2,36],102:[2,36],105:[2,36]},{1:[2,103],14:[2,103],22:[2,103],23:[2,103],25:[2,103],27:[2,103],28:[2,103],29:[2,103],33:[2,103],36:[2,103],37:[2,103],38:[2,103],43:[2,103],44:[2,103],45:[2,103],54:[2,103],57:[2,103],58:[2,103],60:[2,103],61:[2,103],62:[2,103],63:[2,103],64:[2,103],65:[2,103],66:[2,103],67:[2,103],68:[2,103],69:[2,103],70:[2,103],76:[2,103],79:[2,103],99:[2,103],101:[2,103],105:[2,103]},{1:[2,158],14:[2,158],22:[2,158],23:[2,158],25:[2,158],27:[2,158],28:[2,158],29:[2,158],33:[2,158],36:[2,158],37:[2,158],38:[2,158],43:[2,158],44:[2,158],45:[2,158],54:[2,158],57:[2,158],58:[2,158],60:[2,158],61:[2,158],62:[2,158],63:[2,158],64:[2,158],65:[2,158],66:[2,158],67:[2,158],68:[2,158],69:[2,158],70:[2,158],75:405,76:[2,158],79:[2,158],86:[1,183],99:[2,158],101:[2,158],105:[2,158]},{1:[2,122],14:[2,122],22:[2,122],23:[2,122],25:[2,122],27:[2,122],28:[2,122],29:[2,122],33:[2,122],36:[2,122],37:[2,122],38:[2,122],43:[2,122],44:[2,122],45:[2,122],54:[2,122],57:[2,122],58:[2,122],60:[2,122],61:[2,122],62:[2,122],63:[2,122],64:[2,122],65:[2,122],66:[2,122],67:[2,122],68:[2,122],69:[2,122],70:[2,122],76:[2,122],79:[2,122],99:[2,122],101:[2,122],105:[2,122]},{17:406,45:[1,6]},{1:[2,10],9:[2,10],11:[2,10],14:[2,10],15:[2,10],22:[2,10],23:[2,10],25:[2,10],27:[2,10],28:[2,10],29:[2,10],33:[2,10],35:[2,10],36:[2,10],37:[2,10],38:[2,10],43:[2,10],44:[2,10],45:[2,10],53:[2,10],54:[2,10],55:[2,10],56:[2,10],57:[2,10],58:[2,10],60:[2,10],61:[2,10],62:[2,10],63:[2,10],64:[2,10],65:[2,10],66:[2,10],67:[2,10],68:[2,10],69:[2,10],70:[2,10],71:[2,10],76:[2,10],79:[2,10],93:[2,10],99:[2,10],100:[2,10],101:[2,10],102:[2,10],105:[2,10]},{22:[1,407],36:[1,46],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60]},{1:[2,33],9:[2,33],11:[2,33],14:[2,33],15:[2,33],22:[2,33],23:[2,33],25:[2,33],27:[2,33],28:[2,33],29:[2,33],33:[2,33],35:[2,33],36:[2,33],37:[2,33],38:[2,33],43:[2,33],44:[2,33],45:[2,33],53:[2,33],54:[2,33],55:[2,33],56:[2,33],57:[2,33],58:[2,33],60:[2,33],61:[2,33],62:[2,33],63:[2,33],64:[2,33],65:[2,33],66:[2,33],67:[2,33],68:[2,33],69:[2,33],70:[2,33],71:[2,33],76:[2,33],79:[2,33],93:[2,33],99:[2,33],100:[2,33],101:[2,33],102:[2,33],105:[2,33]},{25:[1,408],44:[1,280],45:[1,281],77:279,79:[1,40],99:[1,39]},{23:[2,139],25:[2,139],43:[2,139],44:[2,139],56:[2,139],61:[2,139]},{40:[1,386]},{23:[1,409],44:[1,247],45:[1,248]},{23:[2,138],25:[2,138],43:[2,138],44:[2,138],56:[2,138],61:[2,138]},{1:[2,28],9:[2,28],11:[2,28],14:[2,28],15:[2,28],22:[2,28],23:[2,28],25:[2,28],27:[2,28],28:[2,28],29:[2,28],33:[2,28],35:[2,28],36:[2,28],37:[2,28],38:[2,28],43:[2,28],44:[2,28],45:[2,28],53:[2,28],54:[2,28],55:[2,28],56:[2,28],57:[2,28],58:[2,28],60:[2,28],61:[2,28],62:[2,28],63:[2,28],64:[2,28],65:[2,28],66:[2,28],67:[2,28],68:[2,28],69:[2,28],70:[2,28],71:[2,28],76:[2,28],79:[2,28],93:[2,28],99:[2,28],100:[2,28],101:[2,28],102:[2,28],105:[2,28]},{28:[1,410]},{28:[1,411]},{1:[2,29],9:[2,29],11:[2,29],14:[2,29],15:[2,29],22:[2,29],23:[2,29],25:[2,29],27:[2,29],28:[2,29],29:[2,29],33:[2,29],35:[2,29],36:[2,29],37:[2,29],38:[2,29],43:[2,29],44:[2,29],45:[2,29],53:[2,29],54:[2,29],55:[2,29],56:[2,29],57:[2,29],58:[2,29],60:[2,29],61:[2,29],62:[2,29],63:[2,29],64:[2,29],65:[2,29],66:[2,29],67:[2,29],68:[2,29],69:[2,29],70:[2,29],71:[2,29],76:[2,29],79:[2,29],93:[2,29],99:[2,29],100:[2,29],101:[2,29],102:[2,29],105:[2,29]},{22:[2,162],23:[2,162],25:[2,162],36:[1,46],44:[2,162],45:[2,162],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,162],99:[2,162]},{22:[2,163],23:[2,163],25:[2,163],36:[1,46],44:[2,163],45:[2,163],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,163],99:[2,163],101:[1,412]},{22:[2,166],23:[2,166],25:[2,166],36:[1,46],44:[2,166],45:[2,166],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,166],99:[2,166]},{22:[2,167],23:[2,167],25:[2,167],36:[1,46],44:[2,167],45:[2,167],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,167],99:[2,167],101:[1,413]},{22:[2,173],23:[2,173],25:[2,173],36:[1,46],38:[1,415],44:[2,173],45:[2,173],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,173],99:[2,173],101:[1,414]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:416,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:417,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:418,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,183],23:[2,183],25:[2,183],36:[1,46],44:[2,183],45:[2,183],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,183],99:[2,183]},{14:[2,50],22:[2,50],23:[2,50],33:[2,50],43:[2,50],44:[2,50],45:[2,50]},{1:[2,34],9:[2,34],11:[2,34],14:[2,34],15:[2,34],22:[2,34],23:[2,34],25:[2,34],27:[2,34],28:[2,34],29:[2,34],33:[2,34],35:[2,34],36:[2,34],37:[2,34],38:[2,34],43:[2,34],44:[2,34],45:[2,34],53:[2,34],54:[2,34],55:[2,34],56:[2,34],57:[2,34],58:[2,34],60:[2,34],61:[2,34],62:[2,34],63:[2,34],64:[2,34],65:[2,34],66:[2,34],67:[2,34],68:[2,34],69:[2,34],70:[2,34],71:[2,34],76:[2,34],79:[2,34],93:[2,34],99:[2,34],100:[2,34],101:[2,34],102:[2,34],105:[2,34]},{1:[2,160],14:[2,160],22:[2,160],23:[2,160],25:[2,160],27:[2,160],28:[2,160],29:[2,160],33:[2,160],36:[2,160],37:[2,160],38:[2,160],43:[2,160],44:[2,160],45:[2,160],54:[2,160],57:[2,160],58:[2,160],60:[2,160],61:[2,160],62:[2,160],63:[2,160],64:[2,160],65:[2,160],66:[2,160],67:[2,160],68:[2,160],69:[2,160],70:[2,160],76:[2,160],79:[2,160],99:[2,160],101:[2,160],105:[2,160]},{1:[2,124],14:[2,124],22:[2,124],23:[2,124],25:[2,124],27:[2,124],28:[2,124],29:[2,124],33:[2,124],36:[2,124],37:[2,124],38:[2,124],43:[2,124],44:[2,124],45:[2,124],54:[2,124],57:[2,124],58:[2,124],60:[2,124],61:[2,124],62:[2,124],63:[2,124],64:[2,124],65:[2,124],66:[2,124],67:[2,124],68:[2,124],69:[2,124],70:[2,124],76:[2,124],79:[2,124],99:[2,124],101:[2,124],105:[2,124]},{1:[2,31],9:[2,31],11:[2,31],14:[2,31],15:[2,31],22:[2,31],23:[2,31],25:[2,31],27:[2,31],28:[2,31],29:[2,31],33:[2,31],35:[2,31],36:[2,31],37:[2,31],38:[2,31],43:[2,31],44:[2,31],45:[2,31],53:[2,31],54:[2,31],55:[2,31],56:[2,31],57:[2,31],58:[2,31],60:[2,31],61:[2,31],62:[2,31],63:[2,31],64:[2,31],65:[2,31],66:[2,31],67:[2,31],68:[2,31],69:[2,31],70:[2,31],71:[2,31],76:[2,31],79:[2,31],93:[2,31],99:[2,31],100:[2,31],101:[2,31],102:[2,31],105:[2,31]},{1:[2,14],9:[2,14],11:[2,14],14:[2,14],15:[2,14],22:[2,14],23:[2,14],25:[2,14],27:[2,14],28:[2,14],29:[2,14],33:[2,14],35:[2,14],36:[2,14],37:[2,14],38:[2,14],43:[2,14],44:[2,14],45:[2,14],53:[2,14],54:[2,14],55:[2,14],56:[2,14],57:[2,14],58:[2,14],60:[2,14],61:[2,14],62:[2,14],63:[2,14],64:[2,14],65:[2,14],66:[2,14],67:[2,14],68:[2,14],69:[2,14],70:[2,14],71:[2,14],76:[2,14],79:[2,14],93:[2,14],99:[2,14],100:[2,14],101:[2,14],102:[2,14],105:[2,14]},{23:[2,141],25:[2,141],43:[2,141],44:[2,141]},{1:[2,22],9:[2,22],11:[2,22],14:[2,22],15:[2,22],22:[2,22],23:[2,22],25:[2,22],27:[2,22],28:[2,22],29:[2,22],33:[2,22],35:[2,22],36:[2,22],37:[2,22],38:[2,22],43:[2,22],44:[2,22],45:[2,22],53:[2,22],54:[2,22],55:[2,22],56:[2,22],57:[2,22],58:[2,22],60:[2,22],61:[2,22],62:[2,22],63:[2,22],64:[2,22],65:[2,22],66:[2,22],67:[2,22],68:[2,22],69:[2,22],70:[2,22],71:[2,22],76:[2,22],79:[2,22],93:[2,22],99:[2,22],100:[2,22],101:[2,22],102:[2,22],105:[2,22]},{1:[2,24],9:[2,24],11:[2,24],14:[2,24],15:[2,24],22:[2,24],23:[2,24],25:[2,24],27:[2,24],28:[2,24],29:[2,24],33:[2,24],35:[2,24],36:[2,24],37:[2,24],38:[2,24],43:[2,24],44:[2,24],45:[2,24],53:[2,24],54:[2,24],55:[2,24],56:[2,24],57:[2,24],58:[2,24],60:[2,24],61:[2,24],62:[2,24],63:[2,24],64:[2,24],65:[2,24],66:[2,24],67:[2,24],68:[2,24],69:[2,24],70:[2,24],71:[2,24],76:[2,24],79:[2,24],93:[2,24],99:[2,24],100:[2,24],101:[2,24],102:[2,24],105:[2,24]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:419,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:420,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:421,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:422,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,170],23:[2,170],25:[2,170],36:[1,46],44:[2,170],45:[2,170],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,170],99:[2,170]},{22:[2,171],23:[2,171],25:[2,171],36:[1,46],44:[2,171],45:[2,171],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,171],99:[2,171],101:[1,423]},{22:[2,176],23:[2,176],25:[2,176],36:[1,46],44:[2,176],45:[2,176],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,176],99:[2,176]},{22:[2,164],23:[2,164],25:[2,164],36:[1,46],44:[2,164],45:[2,164],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,164],99:[2,164]},{22:[2,168],23:[2,168],25:[2,168],36:[1,46],44:[2,168],45:[2,168],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,168],99:[2,168]},{22:[2,175],23:[2,175],25:[2,175],36:[1,46],38:[1,424],44:[2,175],45:[2,175],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,175],99:[2,175]},{22:[2,177],23:[2,177],25:[2,177],36:[1,46],44:[2,177],45:[2,177],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,177],99:[2,177],101:[1,425]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:426,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:427,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{3:13,4:[1,29],5:30,6:31,7:[1,32],8:[1,33],16:[1,34],18:[1,35],19:428,20:[1,36],24:[1,37],26:[1,38],32:[1,65],34:[1,15],35:[1,14],40:[1,27],52:12,58:[1,16],59:[1,17],73:[1,18],74:[1,19],77:20,78:[1,21],79:[1,40],80:[1,22],81:[1,23],82:[1,24],87:[1,25],90:[1,26],94:[1,28],99:[1,39]},{22:[2,172],23:[2,172],25:[2,172],36:[1,46],44:[2,172],45:[2,172],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,172],99:[2,172]},{22:[2,179],23:[2,179],25:[2,179],36:[1,46],44:[2,179],45:[2,179],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,179],99:[2,179]},{22:[2,178],23:[2,178],25:[2,178],36:[1,46],44:[2,178],45:[2,178],54:[1,45],57:[1,47],58:[1,48],60:[1,49],61:[1,50],62:[1,51],63:[1,52],64:[1,53],65:[1,54],66:[1,55],67:[1,56],68:[1,57],69:[1,58],70:[1,59],76:[1,60],79:[2,178],99:[2,178]}],
defaultActions: {2:[2,194]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    //this.reductionCount = this.shiftCount = 0;

    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;

    if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

    function popStack (n) {
        stack.length = stack.length - 2*n;
        vstack.length = vstack.length - n;
    }

    function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    };

    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length-1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol == null)
                symbol = lex();
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        if (typeof action === 'undefined' || !action.length || !action[0]) {

            if (!recovering) {
                // Report error
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                    expected.push("'"+this.terminals_[p]+"'");
                }
                var errStr = '';
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+'\nExpecting '+expected.join(', ');
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr,
                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, expected: expected});
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                }

                // discard current lookahead and grab another
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                symbol = lex();
            }

            // try to recover from error
            while (1) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    break;
                }
                if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                }
                popStack(1);
                state = stack[stack.length-1];
            }
            
            preErrorSymbol = symbol; // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {

            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    if (recovering > 0)
                        recovering--;
                } else { // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2: // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack);

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3: // accept
                return true;
        }

    }

    return true;
}};

});

require.define("/node_modules/LiveScript/lib/ast.js",function(require,module,exports,__dirname,__filename,process,global){var Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, DECLS, ref$, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, SIMPLENUM, slice$ = [].slice, toString$ = {}.toString;
(Node = function(){
  throw Error('unimplemented');
}).prototype = {
  compile: function(options, level){
    var o, node, code, that, i$, len$, tmp;
    o = import$({}, options);
    if (level != null) {
      o.level = level;
    }
    node = this.unfoldSoak(o) || this;
    if (o.level && node.isStatement()) {
      return node.compileClosure(o);
    }
    code = (node.tab = o.indent, node).compileNode(o);
    if (that = node.temps) {
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        tmp = that[i$];
        o.scope.free(tmp);
      }
    }
    return code;
  },
  compileClosure: function(o){
    var that, fun, call, hasArgs, hasThis;
    if (that = this.getJump()) {
      that.carp('inconvertible statement');
    }
    fun = Fun([], Block(this));
    call = Call();
    this.traverseChildren(function(it){
      switch (it.value) {
      case 'this':
        hasThis = true;
        break;
      case 'arguments':
        hasArgs = it.value = 'args$';
      }
    });
    if (hasThis) {
      call.args.push(Literal('this'));
      call.method = '.call';
    }
    if (hasArgs) {
      call.args.push(Literal('arguments'));
      fun.params.push(Var('args$'));
    }
    return Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true).compile(o);
  },
  compileBlock: function(o, node){
    var that;
    if (that = node != null ? node.compile(o, LEVEL_TOP) : void 8) {
      return "{\n" + that + "\n" + this.tab + "}";
    } else {
      return '{}';
    }
  },
  cache: function(o, once, level){
    var ref$, sub, ref;
    if (!this.isComplex()) {
      return [ref$ = level != null ? this.compile(o, level) : this, ref$];
    }
    sub = Assign(ref = Var(o.scope.temporary()), this);
    if (level != null) {
      sub = sub.compile(o, level);
      if (once) {
        o.scope.free(ref.value);
      }
      return [sub, ref.value];
    }
    if (once) {
      return [sub, (ref.temp = true, ref)];
    } else {
      return [sub, ref, [ref.value]];
    }
  },
  compileLoopReference: function(o, name, ret){
    var ref$, asn, tmp;
    if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) == '+' || ref$ == '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {
      return [ref$ = this.compile(o), ref$];
    }
    asn = Assign(Var(tmp = o.scope.temporary(name)), this);
    ret || (asn['void'] = true);
    return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
  },
  eachChild: function(fn){
    var i$, ref$, len$, name, child, j$, len1$, i, node, that;
    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
      name = ref$[i$];
      if (child = this[name]) {
        if ('length' in child) {
          for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
            i = j$;
            node = child[j$];
            if (that = fn(node, name, i)) {
              return that;
            }
          }
        } else {
          if ((that = fn(child, name)) != null) {
            return that;
          }
        }
      }
    }
  },
  traverseChildren: function(fn, xscope){
    var this$ = this;
    return this.eachChild(function(node, name, index){
      var ref$;
      return (ref$ = fn(node, this$, name, index)) != null
        ? ref$
        : node.traverseChildren(fn, xscope);
    });
  },
  anaphorize: function(){
    var base, name, ref$;
    this.children = this.aTargets;
    if (this.eachChild(hasThat)) {
      if ((base = this)[name = this.aSource] instanceof Existence) {
        base = base[name];
        name = 'it';
      }
      if (base[name].value !== 'that') {
        base[name] = Assign(Var('that'), base[name]);
      }
    }
    function hasThat(it){
      var that;
      return it.value === 'that' || ((that = it.aSource)
        ? (that = it[that]) ? hasThat(that) : void 8
        : it.eachChild(hasThat));
    }
    delete this.children;
    return ref$ = this[this.aSource], ref$.cond = true, ref$;
  },
  carp: function(msg, type){
    type == null && (type = SyntaxError);
    throw type(msg + " on line " + (this.line || this.traverseChildren(function(it){
      return it.line;
    })));
  },
  delegate: function(names, fn){
    var i$, len$, name;
    for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
      name = names[i$];
      (fn$.call(this, name));
    }
    function fn$(name){
      this[name] = function(it){
        return fn.call(this, name, it);
      };
    }
  },
  children: [],
  terminator: ';',
  isComplex: YES,
  isStatement: NO,
  isAssignable: NO,
  isCallable: NO,
  isEmpty: NO,
  isArray: NO,
  isString: NO,
  isRegex: NO,
  isMatcher: function(){
    return this.isString() || this.isRegex();
  },
  assigns: NO,
  ripName: VOID,
  unfoldSoak: VOID,
  unfoldAssign: VOID,
  unparen: THIS,
  unwrap: THIS,
  maybeKey: THIS,
  expandSlice: THIS,
  varName: String,
  getAccessors: VOID,
  getCall: VOID,
  getDefault: VOID,
  getJump: VOID,
  invert: function(){
    return Unary('!', this, true);
  },
  invertCheck: function(it){
    if (it.inverted) {
      this.invert();
    }
    return this;
  },
  addElse: function($else){
    this['else'] = $else;
    return this;
  },
  makeReturn: function(arref){
    if (arref) {
      return Call.make(JS(arref + '.push'), [this]);
    } else {
      return Return(this);
    }
  },
  makeObjReturn: function(arref){
    var base, items;
    if (arref) {
      base = this.lines[0];
      if (this.lines[0] instanceof If) {
        base = base.then.lines[0];
      }
      items = base.items;
      if (items[0] == null || items[1] == null) {
        this.carp('must specify both key and value for object comprehension');
      }
      return Assign(Chain(Var(arref)).add(Index(items[0], '.', true)), items[1]);
    } else {
      return Return(this);
    }
  },
  show: String,
  toString: function(idt){
    var tree, that;
    idt || (idt = '');
    tree = '\n' + idt + this.constructor.displayName;
    if (that = this.show()) {
      tree += ' ' + that;
    }
    this.eachChild(function(it){
      tree += it.toString(idt + TAB);
    });
    return tree;
  },
  stringify: function(space){
    return JSON.stringify(this, null, space);
  },
  toJSON: function(){
    return import$({
      type: this.constructor.displayName
    }, this);
  }
};
exports.parse = function(json){
  return exports.fromJSON(JSON.parse(json));
};
exports.fromJSON = (function(){
  function fromJSON(it){
    var that, node, key, val, i$, len$, v, results$ = [];
    if (!(it && typeof it === 'object')) {
      return it;
    }
    if (that = it.type) {
      node = clone$(exports[that].prototype);
      for (key in it) {
        val = it[key];
        node[key] = fromJSON(val);
      }
      return node;
    }
    if (it.length != null) {
      for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
        v = it[i$];
        results$.push(fromJSON(v));
      }
      return results$;
    } else {
      return it;
    }
  }
  return fromJSON;
}());
Negatable = {
  show: function(){
    return this.negated && '!';
  },
  invert: function(){
    this.negated = !this.negated;
    return this;
  }
};
exports.Block = Block = (function(superclass){
  var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;
  function Block(body){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    body || (body = []);
    if ('length' in body) {
      this$.lines = body;
    } else {
      this$.lines = [];
      this$.add(body);
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['lines'];
  prototype.toJSON = function(){
    delete this.back;
    return superclass.prototype.toJSON.call(this);
  };
  prototype.add = function(it){
    var that, ref$;
    it = it.unparen();
    switch (false) {
    case !(that = this.back):
      that.add(it);
      break;
    case !(that = it.lines):
      (ref$ = this.lines).push.apply(ref$, that);
      break;
    default:
      this.lines.push(it);
      if (that = it.back, delete it.back, that) {
        this.back = that;
      }
    }
    return this;
  };
  prototype.prepend = function(){
    var ref$;
    (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
    return this;
  };
  prototype.pipe = function(target, type){
    var args;
    args = type === '|>' ? this.lines.pop() : target;
    if (toString$.call(args).slice(8, -1) !== 'Array') {
      args = [args];
    }
    switch (type) {
    case '|>':
      this.lines.push(Call.make(target, args, {
        pipe: true
      }));
      break;
    case '<|':
      this.lines.push(Call.make(this.lines.pop(), args));
    }
    return this;
  };
  prototype.unwrap = function(){
    if (this.lines.length === 1) {
      return this.lines[0];
    } else {
      return this;
    }
  };
  prototype.chomp = function(){
    var lines, i, that;
    lines = this.lines;
    i = lines.length;
    while (that = lines[--i]) {
      if (!that.comment) {
        break;
      }
    }
    lines.length = i + 1;
    return this;
  };
  prototype.neck = function(){
    var pos, i$, ref$, len$, x;
    pos = 0;
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (!(x.comment || x instanceof Literal)) {
        break;
      }
      ++pos;
    }
    return pos;
  };
  prototype.isComplex = function(){
    var ref$;
    return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
  };
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
    var ref$, ref1$;
    return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
  });
  prototype.getJump = function(it){
    var i$, ref$, len$, node, that;
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (that = node.getJump(it)) {
        return that;
      }
    }
  };
  prototype.makeReturn = function(it){
    var that, ref$, key$, ref1$;
    if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = ref$[key$].makeReturn(it) : void 8) {
      if (that instanceof Return && !that.it) {
        --this.lines.length;
      }
    }
    return this;
  };
  prototype.compile = function(o, level){
    var tab, codes, res$, i$, ref$, len$, node, code;
    level == null && (level = o.level);
    if (level) {
      return this.compileExpressions(o, level);
    }
    o.block = this;
    tab = o.indent;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      node = ref$[i$];
      node = node.unfoldSoak(o) || node;
      if (!(code = (node.front = true, node).compile(o, level))) {
        continue;
      }
      node.isStatement() || (code += node.terminator);
      res$.push(tab + code);
    }
    codes = res$;
    return codes.join('\n');
  };
  prototype.compileRoot = function(options){
    var o, saveTo, bare, ref$, prefix, code;
    o = (import$({
      level: LEVEL_TOP,
      scope: this.scope = Scope.root = new Scope
    }, options));
    if (saveTo = o.saveScope, delete o.saveScope, saveTo) {
      o.scope = saveTo.savedScope || (saveTo.savedScope = o.scope);
    }
    delete o.filename;
    o.indent = (bare = o.bare, delete o.bare, bare) ? '' : TAB;
    if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
      prefix = this.lines.shift().code + '\n';
    }
    if ((ref$ = o.eval, delete o.eval, ref$) && this.chomp().lines.length) {
      if (bare) {
        this.lines.push(Parens(this.lines.pop()));
      } else {
        this.makeReturn();
      }
    }
    code = this.compileWithDeclarations(o);
    bare || (code = "(function(){\n" + code + "\n}).call(this);\n");
    return [prefix] + code;
  };
  prototype.compileWithDeclarations = function(o){
    var pre, i, rest, post, that;
    o.level = LEVEL_TOP;
    pre = '';
    if (i = this.neck()) {
      rest = this.lines.splice(i, 9e9);
      pre = this.compile(o);
      this.lines = rest;
    }
    if (!(post = this.compile(o))) {
      return pre;
    }
    return (pre && pre + "\n") + ((that = this.scope) ? that.emit(post, o.indent) : post);
  };
  prototype.compileExpressions = function(o, level){
    var lines, i, that, code, last, i$, len$, node;
    lines = this.lines;
    i = -1;
    while (that = lines[++i]) {
      if (that.comment) {
        lines.splice(i--, 1);
      }
    }
    if (!lines.length) {
      lines.push(Literal('void'));
    }
    lines[0].front = this.front;
    lines[lines.length - 1]['void'] = this['void'];
    if (!lines[1]) {
      return lines[0].compile(o, level);
    }
    code = '';
    last = lines.pop();
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      node = lines[i$];
      code += (node['void'] = true, node).compile(o, LEVEL_PAREN) + ', ';
    }
    code += last.compile(o, LEVEL_PAREN);
    if (level < LEVEL_LIST) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  return Block;
}(Node));
Atom = (function(superclass){
  var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;
  prototype.show = function(){
    return this.value;
  };
  prototype.isComplex = NO;
  function Atom(){
    Atom.superclass.apply(this, arguments);
  }
  return Atom;
}(Node));
exports.Literal = Literal = (function(superclass){
  var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;
  function Literal(value){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.value = value;
    if (value.js) {
      return JS(value + "", true);
    }
    if (value === 'super') {
      return new Super;
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.isEmpty = function(){
    var ref$;
    return (ref$ = this.value) == 'void' || ref$ == 'null';
  };
  prototype.isCallable = function(){
    var ref$;
    return (ref$ = this.value) == 'this' || ref$ == 'eval' || ref$ == '..';
  };
  prototype.isString = function(){
    return 0 <= '\'"'.indexOf((this.value + "").charAt());
  };
  prototype.isRegex = function(){
    return (this.value + "").charAt() === '/';
  };
  prototype.isComplex = function(){
    return this.isRegex() || this.value === 'debugger';
  };
  prototype.isWhat = function(){
    switch (false) {
    case !this.isEmpty():
      return 'empty';
    case !this.isCallable():
      return 'callable';
    case !this.isString():
      return 'string';
    case !this.isRegex():
      return 'regex';
    case !this.isComplex():
      return 'complex';
    }
  };
  prototype.varName = function(){
    if (/^\w+$/.test(this.value)) {
      return '$' + this.value;
    } else {
      return '';
    }
  };
  prototype.compile = function(o, level){
    var val, ref$;
    level == null && (level = o.level);
    switch (val = this.value + "") {
    case 'this':
      return ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val;
    case 'undefined':
      val = 'void';
      // fallthrough
    case 'void':
      if (!level) {
        return '';
      }
      val += ' 8';
      // fallthrough
    case 'null':
      if (level === LEVEL_CALL) {
        this.carp('invalid use of ' + this.value);
      }
      break;
    case 'on':
    case 'yes':
      val = 'true';
      break;
    case 'off':
    case 'no':
      val = 'false';
      break;
    case '*':
      this.carp('stray star');
      break;
    case '..':
      if (!(val = o.ref)) {
        this.carp('stray reference');
      }
      this.cascadee || (val.erred = true);
      break;
    case 'debugger':
      if (level) {
        return "(function(){\n" + TAB + o.indent + "debugger;\n" + o.indent + "}())";
      }
    }
    return val;
  };
  return Literal;
}(Atom));
exports.Var = Var = (function(superclass){
  var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;
  function Var(value){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.value = value;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.isAssignable = prototype.isCallable = YES;
  prototype.assigns = function(it){
    return it === this.value;
  };
  prototype.maybeKey = function(){
    var ref$;
    return ref$ = Key(this.value), ref$.line = this.line, ref$;
  };
  prototype.varName = prototype.show;
  prototype.compile = function(o){
    if (this.temp) {
      return o.scope.free(this.value);
    } else {
      return this.value;
    }
  };
  return Var;
}(Atom));
exports.Key = Key = (function(superclass){
  var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;
  function Key(name, reserved){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.reserved = reserved || name.reserved;
    this$.name = '' + name;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.isComplex = NO;
  prototype.assigns = function(it){
    return it === this.name;
  };
  prototype.varName = function(){
    var name;
    name = this.name;
    if (this.reserved || (name == 'arguments' || name == 'eval')) {
      return "$" + name;
    } else {
      return name;
    }
  };
  prototype.compile = prototype.show = function(){
    if (this.reserved) {
      return "'" + this.name + "'";
    } else {
      return this.name;
    }
  };
  return Key;
}(Node));
exports.Index = Index = (function(superclass){
  var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;
  function Index(key, symbol, init){
    var k, this$ = this instanceof ctor$ ? this : new ctor$;
    symbol || (symbol = '.');
    if (init && key instanceof Arr) {
      switch (key.items.length) {
      case 1:
        if (!((k = key.items[0]) instanceof Splat)) {
          key = Parens(k);
        }
      }
    }
    switch (symbol) {
    case '[]':
      this$.vivify = Arr;
      break;
    case '{}':
      this$.vivify = Obj;
      break;
    default:
      if ('=' === symbol.slice(-1)) {
        this$.assign = symbol.slice(1);
      }
    }
    this$.key = key;
    this$.symbol = symbol;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['key'];
  prototype.show = function(){
    return [this.soak ? '?' : void 8] + this.symbol;
  };
  prototype.isComplex = function(){
    return this.key.isComplex();
  };
  prototype.varName = function(){
    var ref$;
    return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();
  };
  prototype.compile = function(o){
    var code;
    code = this.key.compile(o, LEVEL_PAREN);
    if (this.key instanceof Key && '\'' !== code.charAt(0)) {
      return "." + code;
    } else {
      return "[" + code + "]";
    }
  };
  return Index;
}(Node));
exports.Slice = Slice = (function(superclass){
  var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;
  function Slice(arg$){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
    this$.from == null && (this$.from = Literal(0));
    if (this$.to && this$.type === 'to') {
      this$.to = Binary('+', this$.to, Literal('1'));
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['target', 'from', 'to'];
  prototype.show = function(){
    return this.type;
  };
  prototype.compileNode = function(o){
    var args;
    if (this.to && this.type === 'to') {
      this.to = Binary('||', this.to, Literal('9e9'));
    }
    args = [this.target, this.from];
    if (this.to) {
      args.push(this.to);
    }
    return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
  };
  return Slice;
}(Node));
exports.Chain = Chain = (function(superclass){
  var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;
  function Chain(head, tails){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    if (!tails && head instanceof Chain) {
      return head;
    }
    this$.head = head;
    this$.tails = tails || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['head', 'tails'];
  prototype.add = function(it){
    var ref$, bi, that, logics, call, f;
    if (this.head instanceof Existence) {
      ref$ = Chain(this.head.it), this.head = ref$.head, this.tails = ref$.tails;
      it.soak = true;
    }
    this.tails.push(it);
    bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial
      ? this.head.it
      : this.head instanceof Binary && !this.head.partial ? this.head : void 8;
    if (this.head instanceof Super) {
      if (!this.head.called && it instanceof Call && !it.method) {
        it.method = '.call';
        it.args.unshift(Literal('this'));
        this.head.called = true;
      } else if (!this.tails[1] && ((ref$ = it.key) != null ? ref$.name : void 8) === 'prototype') {
        this.head.sproto = true;
      }
    } else if (that = it.vivify, delete it.vivify, that) {
      this.head = Assign(Chain(this.head, this.tails.splice(0, 9e9)), that(), '=', '||');
    } else if (it instanceof Call && this.tails.length === 1 && bi && in$(bi.op, logics = ['&&', '||', 'xor'])) {
      call = it;
      f = function(x, key){
        var y;
        y = x[key];
        if (y instanceof Binary && in$(y.op, logics)) {
          f(y, 'first');
          return f(y, 'second');
        } else {
          return x[key] = Chain(y).autoCompare(call.args);
        }
      };
      f(bi, 'first');
      f(bi, 'second');
      return bi;
    }
    return this;
  };
  prototype.autoCompare = function(target){
    var test;
    test = this.head;
    switch (false) {
    case !(test instanceof Literal):
      return Binary('===', test, target[0]);
    case !(test instanceof Arr || test instanceof Obj):
      return Binary('====', test, target[0]);
    case !(test instanceof Var && test.value === '_'):
      return Literal('true');
    default:
      return this.add(Call(target)) || [];
    }
  };
  prototype.flipIt = function(){
    this.flip = true;
    return this;
  };
  prototype.unwrap = function(){
    if (this.tails.length) {
      return this;
    } else {
      return this.head;
    }
  };
  prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){
    return !this.tails.length && this.head[it](arg);
  });
  prototype.isComplex = function(){
    return this.tails.length || this.head.isComplex();
  };
  prototype.isCallable = function(){
    var that, ref$;
    if (that = (ref$ = this.tails)[ref$.length - 1]) {
      return !((ref$ = that.key) != null && ref$.items);
    } else {
      return this.head.isCallable();
    }
  };
  prototype.isArray = function(){
    var that, ref$;
    if (that = (ref$ = this.tails)[ref$.length - 1]) {
      return that.key instanceof Arr;
    } else {
      return this.head.isArray();
    }
  };
  prototype.isRegex = function(){
    return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;
  };
  prototype.isAssignable = function(){
    var tail, ref$, i$, len$;
    if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
      return this.head.isAssignable();
    }
    if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
      return false;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      tail = ref$[i$];
      if (tail.assign) {
        return false;
      }
    }
    return true;
  };
  prototype.isSimpleAccess = function(){
    return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();
  };
  prototype.makeReturn = function(it){
    if (this.tails.length) {
      return superclass.prototype.makeReturn.apply(this, arguments);
    } else {
      return this.head.makeReturn(it);
    }
  };
  prototype.getCall = function(){
    var tail, ref$;
    return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;
  };
  prototype.varName = function(){
    var ref$, ref1$;
    return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
  };
  prototype.cacheReference = function(o){
    var name, ref$, base, ref, bref, nref;
    name = (ref$ = this.tails)[ref$.length - 1];
    if (name instanceof Call) {
      return this.cache(o, true);
    }
    if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {
      return [this, this];
    }
    base = Chain(this.head, this.tails.slice(0, -1));
    if (base.isComplex()) {
      ref = o.scope.temporary();
      base = Chain(Assign(Var(ref), base));
      bref = (ref$ = Var(ref), ref$.temp = true, ref$);
    }
    if (!name) {
      return [base, bref];
    }
    if (name.isComplex()) {
      ref = o.scope.temporary('key');
      name = Index(Assign(Var(ref), name.key));
      nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
    }
    return [base.add(name), Chain(bref || base.head, [nref || name])];
  };
  prototype.compileNode = function(o){
    var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, idt, func, base, news, ref$;
    if (this.flip) {
      util('flip');
      util('curry');
    }
    head = this.head, tails = this.tails;
    head.front = this.front;
    head.newed = this.newed;
    if (!tails.length) {
      return head.compile(o);
    }
    if (that = this.unfoldAssign(o)) {
      return that.compile(o);
    }
    for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
      t = tails[i$];
      if (t.partialized) {
        hasPartial = true;
        break;
      }
    }
    if (hasPartial) {
      util('slice');
      pre = [];
      rest = [];
      for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
        t = tails[i$];
        broken = broken || t.partialized != null;
        if (broken) {
          rest.push(t);
        } else {
          pre.push(t);
        }
      }
      if (rest != null) {
        partial = rest[0], post = slice$.call(rest, 1);
      }
      this.tails = pre;
      return Chain(Chain(Var(util('partialize'))).add(Call([this, Arr(partial.args), Arr(partial.partialized)])), post).compile(o);
    }
    if (tails[0] instanceof Call && !head.isCallable()) {
      this.carp('invalid callee');
    }
    this.expandSlice(o);
    this.expandBind(o);
    this.expandSplat(o);
    this.expandStar(o);
    if (this.splattedNewArgs) {
      idt = o.indent + TAB;
      func = Chain(this.head, tails.slice(0, -1));
      return "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(" + func.compile(o) + ", " + this.splattedNewArgs + ", function(){})";
    }
    if (!this.tails.length) {
      return this.head.compile(o);
    }
    base = this.head.compile(o, LEVEL_CALL);
    news = rest = '';
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      t = ref$[i$];
      if (t['new']) {
        news += 'new ';
      }
      rest += t.compile(o);
    }
    if ('.' === rest.charAt(0) && SIMPLENUM.test(base)) {
      base += ' ';
    }
    return news + base + rest;
  };
  prototype.unfoldSoak = function(o){
    var that, ref$, i$, len$, i, node, ref1$, bust, test;
    if (that = this.head.unfoldSoak(o)) {
      (ref$ = that.then.tails).push.apply(ref$, this.tails);
      return that;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      i = i$;
      node = ref$[i$];
      if (ref1$ = node.soak, delete node.soak, ref1$) {
        bust = Chain(this.head, this.tails.splice(0, i));
        if (node.assign && !bust.isAssignable()) {
          node.carp('invalid accessign');
        }
        test = node instanceof Call
          ? (ref1$ = bust.cacheReference(o), test = ref1$[0], this.head = ref1$[1], JS("typeof " + test.compile(o, LEVEL_OP) + " === 'function'"))
          : (i && node.assign
            ? (ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1], this.head = bust.head, (ref1$ = this.tails).unshift.apply(ref1$, bust.tails))
            : (ref1$ = bust.unwrap().cache(o, true), test = ref1$[0], this.head = ref1$[1]), Existence(test));
        return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
      }
    }
  };
  prototype.unfoldAssign = function(o){
    var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
    if (that = this.head.unfoldAssign(o)) {
      (ref$ = that.right.tails).push.apply(ref$, this.tails);
      return that;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      i = i$;
      index = ref$[i$];
      if (op = index.assign) {
        index.assign = '';
        left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
        if (left instanceof Arr) {
          lefts = left.items;
          rites = (this.head = Arr()).items;
          for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {
            i = j$;
            node = lefts[j$];
            ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
          }
        } else {
          ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
        }
        if (op === '=') {
          op = ':=';
        }
        return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
      }
    }
  };
  prototype.expandSplat = function(o){
    var tails, i, call, args, ctx, ref$;
    tails = this.tails;
    i = -1;
    while (call = tails[++i]) {
      if (!(args = call.args)) {
        continue;
      }
      ctx = call.method === '.call' && (args = args.concat()).shift();
      if (!(args = Splat.compileArray(o, args, true))) {
        continue;
      }
      if (call['new']) {
        this.splattedNewArgs = args;
      } else {
        if (!ctx && tails[i - 1] instanceof Index) {
          ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
          i = 0;
        }
        call.method = '.apply';
        call.args = [ctx || Literal('null'), JS(args)];
      }
    }
  };
  prototype.expandBind = function(o){
    var tails, i, that, obj, key, call;
    tails = this.tails;
    i = -1;
    while (that = tails[++i]) {
      if (that.symbol !== '.~') {
        continue;
      }
      that.symbol = '';
      obj = Chain(this.head, tails.splice(0, i)).unwrap();
      key = tails.shift().key;
      call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
      this.head = this.newed ? Parens(call, true) : call;
      i = -1;
    }
  };
  prototype.expandStar = function(o){
    var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
    tails = this.tails;
    i = -1;
    while (that = tails[++i]) {
      if (that.args || that.stars || that.key instanceof Key) {
        continue;
      }
      stars = that.stars = [];
      that.eachChild(seek);
      if (!stars.length) {
        continue;
      }
      ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
      value = Chain(ref, [Index(Key('length'))]).compile(o);
      for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {
        star = stars[i$];
        star.value = value;
        star.isAssignable = YES;
      }
      this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
      if (temps) {
        o.scope.free(temps[0]);
      }
      i = -1;
    }
    function seek(it){
      if (it.value === '*') {
        stars.push(it);
      } else if (!(it instanceof Index)) {
        it.eachChild(seek);
      }
    }
  };
  prototype.expandSlice = function(o, assign){
    var tails, i, tail, ref$, x;
    tails = this.tails;
    i = -1;
    while (tail = tails[++i]) {
      if ((ref$ = tail.key) != null && ref$.items) {
        if (tails[i + 1] instanceof Call) {
          tail.carp('calling a slice');
        }
        x = tails.splice(0, i + 1);
        x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
        this.head = (x.front = this.front, x);
        i = -1;
      }
    }
    return this;
  };
  return Chain;
}(Node));
exports.Call = Call = (function(superclass){
  var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
  function Call(args){
    var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
    args || (args = []);
    if (args.length === 1 && (splat = args[0]) instanceof Splat) {
      if (splat.filler) {
        this$.method = '.call';
        args[0] = Literal('this');
        args[1] = Splat(Literal('arguments'));
      } else if (splat.it instanceof Arr) {
        args = splat.it.items;
      }
    } else {
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        i = i$;
        a = args[i$];
        if (a.value === '_') {
          args[i] = Chain(Literal('void'));
          args[i].placeholder = true;
          ((ref$ = this$.partialized) != null
            ? ref$
            : this$.partialized = []).push(Chain(Literal(i)));
        }
      }
    }
    this$.args = args;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['args'];
  prototype.show = function(){
    return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
  };
  prototype.compile = function(o){
    var code, i$, ref$, len$, i, a;
    code = (this.method || '') + '(' + (this.pipe ? "\n" + o.indent : '');
    for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
      i = i$;
      a = ref$[i$];
      code += (i ? ', ' : '') + a.compile(o, LEVEL_LIST);
    }
    return code + ')';
  };
  Call.make = function(callee, args, opts){
    var call;
    call = Call(args);
    if (opts) {
      import$(call, opts);
    }
    return Chain(callee).add(call);
  };
  Call.block = function(fun, args, method){
    var ref$, ref1$;
    return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
  };
  Call.back = function(params, node, bound, curried){
    var fun, ref$, args, index, i$, len$, a;
    fun = Fun(params, void 8, bound, curried);
    if (fun['void'] = node.op === '!') {
      node = node.it;
    }
    if (node instanceof Label) {
      fun.name = node.label;
      fun.labeled = true;
      node = node.it;
    }
    if (!fun['void'] && (fun['void'] = node.op === '!')) {
      node = node.it;
    }
    if ((ref$ = node.getCall()) != null) {
      ref$.partialized = null;
    }
    args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
    index = 0;
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (a.placeholder) {
        break;
      }
      ++index;
    }
    return node.back = (args[index] = fun).body, node;
  };
  Call['let'] = function(args, body){
    var params, res$, i$, len$, i, a, that, gotThis;
    res$ = [];
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      i = i$;
      a = args[i$];
      if (that = a.op === '=' && !a.logic && a.right) {
        args[i] = that;
        if (i === 0 && (gotThis = a.left.value === 'this')) {
          continue;
        }
        res$.push(a.left);
      } else {
        res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
      }
    }
    params = res$;
    gotThis || args.unshift(Literal('this'));
    return this.block(Fun(params, body), args, '.call');
  };
  Call.where = function(args, body){
    var lines, res$, i$, len$, a, params, i;
    res$ = [];
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (a.op === '=' && !a.logic) {
        res$.push(a);
      }
    }
    lines = res$;
    res$ = [];
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.op === '=' && !a.logic) {
        args[i] = Literal('void');
        res$.push(a.left);
      } else {
        res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
      }
    }
    params = res$;
    args.unshift(Literal('this'));
    return this.block(Fun(params, Block(lines.concat(body.lines))), args, '.call');
  };
  return Call;
}(Node));
List = (function(superclass){
  var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;
  prototype.children = ['items'];
  prototype.show = function(){
    return this.name;
  };
  prototype.named = function(name){
    this.name = name;
    return this;
  };
  prototype.isEmpty = function(){
    return !this.items.length;
  };
  prototype.assigns = function(it){
    var i$, ref$, len$, node;
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.assigns(it)) {
        return true;
      }
    }
  };
  List.compile = function(o, items, deepEq){
    var indent, level, code, i, that, target;
    switch (items.length) {
    case 0:
      return '';
    case 1:
      return items[0].compile(o, LEVEL_LIST);
    }
    indent = o.indent, level = o.level;
    o.indent = indent + TAB;
    o.level = LEVEL_LIST;
    code = items[i = 0].compile(o);
    while (that = items[++i]) {
      code += ', ';
      target = that;
      if (deepEq) {
        if (target instanceof Var && target.value === '_') {
          target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
        } else if (target instanceof Obj || target instanceof Arr) {
          target.deepEq = true;
        }
      }
      code += target.compile(o);
    }
    if (~code.indexOf('\n')) {
      code = "\n" + o.indent + code + "\n" + indent;
    }
    o.indent = indent;
    o.level = level;
    return code;
  };
  function List(){
    List.superclass.apply(this, arguments);
  }
  return List;
}(Node));
exports.Obj = Obj = (function(superclass){
  var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;
  function Obj(items){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.items = items || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.asObj = THIS;
  prototype.toSlice = function(o, base, symbol, assign){
    var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
    items = this.items;
    if (items.length > 1) {
      ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
    } else {
      ref = base;
    }
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      node = items[i$];
      if (node.comment) {
        continue;
      }
      if (node instanceof Prop || node instanceof Splat) {
        node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
      } else {
        if (logic = node.getDefault()) {
          node = node.first;
        }
        if (node instanceof Parens) {
          ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
          if (assign) {
            ref$ = [node, key], key = ref$[0], node = ref$[1];
          }
          key = Parens(key);
        } else {
          key = node;
        }
        val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
        if (logic) {
          val = (logic.first = val, logic);
        }
        items[i] = Prop(key, val);
      }
      base = ref;
    }
    chain || this.carp('empty slice');
    if (temps) {
      (chain.head = Var(temps[0])).temp = true;
    }
    return this;
  };
  prototype.compileNode = function(o){
    var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
    items = this.items;
    if (!items.length) {
      return this.front ? '({})' : '{}';
    }
    code = '';
    idt = '\n' + (o.indent += TAB);
    dic = {};
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      node = items[i$];
      if (node.comment) {
        code += idt + node.compile(o);
        continue;
      }
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Splat || (node.key || node) instanceof Parens) {
        rest = items.slice(i);
        break;
      }
      if (logic) {
        if (node instanceof Prop) {
          node.val = (logic.first = node.val, logic);
        } else {
          node = Prop(node, (logic.first = node, logic));
        }
      }
      if (this.deepEq && node instanceof Prop) {
        if (node.val instanceof Var && node.val.value === '_') {
          node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
        } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
          node.val.deepEq = true;
        }
      }
      if (multi) {
        code += ',';
      } else {
        multi = true;
      }
      code += idt + (node instanceof Prop
        ? (key = node.key, val = node.val, node.accessor
          ? node.compileAccessor(o, key = key.compile(o))
          : (val.ripName(key), (key = key.compile(o)) + ": " + val.compile(o, LEVEL_LIST)))
        : (key = node.compile(o)) + ": " + key);
      ID.test(key) || (key = Function("return " + key)());
      if (!(dic[key + "."] ^= 1)) {
        node.carp("duplicate property \"" + key + "\"");
      }
    }
    code = "{" + (code && code + '\n' + this.tab) + "}";
    rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
    if (this.front && '{' === code.charAt()) {
      return "(" + code + ")";
    } else {
      return code;
    }
  };
  return Obj;
}(List));
exports.Prop = Prop = (function(superclass){
  var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;
  function Prop(key, val){
    var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
    this$.key = key;
    this$.val = val;
    if (key.value === '...') {
      return Splat(this$.val);
    }
    if (that = val.getAccessors()) {
      this$.val = that;
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        fun = that[i$];
        fun.x = (fun['void'] = fun.params.length) ? 's' : 'g';
      }
      this$['accessor'] = 'accessor';
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['key', 'val'];
  prototype.show = function(){
    return this.accessor;
  };
  prototype.assigns = function(it){
    var ref$;
    return typeof (ref$ = this.val).assigns === 'function' ? ref$.assigns(it) : void 8;
  };
  prototype.compileAccessor = function(o, key){
    var funs, fun;
    funs = this.val;
    if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {
      funs[0].carp('invalid accessor parameter');
    }
    return (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = funs).length; i$ < len$; ++i$) {
        fun = ref$[i$];
        fun.accessor = true;
        results$.push(fun.x + "et " + key + fun.compile(o, LEVEL_LIST).slice(8));
      }
      return results$;
    }()).join(',\n' + o.indent);
  };
  prototype.compileDescriptor = function(o){
    var obj, i$, ref$, len$, fun;
    obj = Obj();
    for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {
      fun = ref$[i$];
      obj.items.push(Prop(Key(fun.x + 'et'), fun));
    }
    obj.items.push(Prop(Key('configurable'), Literal(true)));
    obj.items.push(Prop(Key('enumerable'), Literal(true)));
    return obj.compile(o);
  };
  return Prop;
}(Node));
exports.Arr = Arr = (function(superclass){
  var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;
  function Arr(items){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.items = items || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.isArray = YES;
  prototype.asObj = function(){
    var i, item;
    return Obj((function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
        i = i$;
        item = ref$[i$];
        results$.push(Prop(Literal(i), item));
      }
      return results$;
    }.call(this)));
  };
  prototype.toSlice = function(o, base, symbol){
    var items, ref$, ref, i$, len$, i, item, splat, chain;
    items = this.items;
    if (items.length > 1) {
      ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
    } else {
      ref = base;
    }
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      item = items[i$];
      if (splat = item instanceof Splat) {
        item = item.it;
      }
      if (item.isEmpty()) {
        continue;
      }
      chain = Chain(base, [Index(item, symbol)]);
      items[i] = splat ? Splat(chain) : chain;
      base = ref;
    }
    chain || this.carp('empty slice');
    return this;
  };
  prototype.compile = function(o){
    var items, code;
    items = this.items;
    if (!items.length) {
      return '[]';
    }
    if (code = Splat.compileArray(o, items)) {
      return this.newed ? "(" + code + ")" : code;
    }
    return "[" + List.compile(o, items, this.deepEq) + "]";
  };
  Arr.maybe = function(nodes){
    if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {
      return nodes[0];
    }
    return constructor(nodes);
  };
  Arr.wrap = function(it){
    return constructor([Splat((it.isArray = YES, it))]);
  };
  return Arr;
}(List));
exports.Unary = Unary = (function(superclass){
  var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;
  function Unary(op, it, flag){
    var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
    if (it != null) {
      if (that = !flag && it.unaries) {
        that.push(op);
        return it;
      }
      switch (op) {
      case '!':
        if (flag) {
          break;
        }
        if (it instanceof Fun && !it['void']) {
          return it['void'] = true, it;
        }
        return it.invert();
      case '++':
      case '--':
        if (flag) {
          this$.post = true;
        }
        break;
      case 'new':
        if (it instanceof Existence && !it.negated) {
          it = Chain(it).add(Call());
        }
        it.newed = true;
        for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (node instanceof Call && !node['new']) {
            if (node.method === '.call') {
              node.args.shift();
            }
            node['new'] = 'new';
            node.method = '';
            return it;
          }
        }
        break;
      case '~':
        if (it instanceof Fun && it.statement && !it.bound) {
          return it.bound = 'this$', it;
        }
      }
    }
    this$.op = op;
    this$.it = it;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['it'];
  prototype.show = function(){
    return [this.post ? '@' : void 8] + this.op;
  };
  prototype.isCallable = function(){
    var ref$;
    return ((ref$ = this.op) == 'do' || ref$ == 'new' || ref$ == 'delete') || this.it == null;
  };
  prototype.isArray = function(){
    return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();
  };
  prototype.isString = function(){
    var ref$;
    return (ref$ = this.op) == 'typeof' || ref$ == 'classof';
  };
  prototype.invert = function(){
    var ref$;
    if (this.op === '!' && ((ref$ = this.it.op) == '!' || ref$ == '<' || ref$ == '>' || ref$ == '<=' || ref$ == '>=' || ref$ == 'of' || ref$ == 'instanceof')) {
      return this.it;
    }
    return constructor('!', this, true);
  };
  prototype.unfoldSoak = function(o){
    var ref$;
    return ((ref$ = this.op) == '++' || ref$ == '--' || ref$ == 'delete') && this.it != null && If.unfoldSoak(o, this, 'it');
  };
  prototype.getAccessors = function(){
    var items;
    if (this.op !== '~') {
      return;
    }
    if (this.it instanceof Fun) {
      return [this.it];
    }
    if (this.it instanceof Arr) {
      items = this.it.items;
      if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {
        return items;
      }
    }
  };
  function crement(it){
    return {
      '++': 'in',
      '--': 'de'
    }[it] + 'crement';
  }
  prototype.compileNode = function(o){
    var that, op, it, x, code;
    if (this.it == null) {
      return this.compileAsFunc(o);
    }
    if (that = this.compileSpread(o)) {
      return that;
    }
    op = this.op, it = this.it;
    switch (op) {
    case '!':
      it.cond = true;
      break;
    case 'new':
      it.isCallable() || it.carp('invalid constructor');
      break;
    case 'do':
      if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {
        return it.compile(o) + " " + Unary('do', Var(it.name)).compile(o);
      }
      x = Parens(it instanceof Existence && !it.negated
        ? Chain(it).add(Call())
        : Call.make(it));
      return (x.front = this.front, x.newed = this.newed, x).compile(o);
    case 'delete':
      if (it instanceof Var || !it.isAssignable()) {
        this.carp('invalid delete');
      }
      if (o.level && !this['void']) {
        return this.compilePluck(o);
      }
      break;
    case '++':
    case '--':
      it.isAssignable() || this.carp('invalid ' + crement(op));
      if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {
        this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
      }
      if (this.post) {
        it.front = this.front;
      }
      break;
    case '^^':
      return util('clone') + "(" + it.compile(o, LEVEL_LIST) + ")";
    case 'jsdelete':
      return "delete " + it.compile(o, LEVEL_LIST);
    case 'classof':
      return util('toString') + ".call(" + it.compile(o, LEVEL_LIST) + ").slice(8, -1)";
    }
    code = it.compile(o, LEVEL_OP + PREC.unary);
    if (!code) {
      console.log(it);
      console.log(it.prototype);
    }
    if (this.post) {
      code += op;
    } else {
      if ((op == 'new' || op == 'typeof' || op == 'delete') || (op == '+' || op == '-') && op === code.charAt()) {
        op += ' ';
      }
      code = op + code;
    }
    if (o.level < LEVEL_CALL) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  prototype.compileSpread = function(o){
    var it, ops, them, i$, len$, i, node, sp, j$, op, lat, ref$;
    it = this.it;
    ops = [this];
    for (; it instanceof constructor; it = it.it) {
      ops.push(it);
    }
    if (!((it = it.expandSlice(o).unwrap()) instanceof Arr && (them = it.items).length)) {
      return '';
    }
    for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {
      i = i$;
      node = them[i$];
      if (sp = node instanceof Splat) {
        node = node.it;
      }
      for (j$ = ops.length - 1; j$ >= 0; --j$) {
        op = ops[j$];
        node = constructor(op.op, node, op.post);
      }
      them[i] = sp ? lat = Splat(node) : node;
    }
    if (!lat && (this['void'] || !o.level)) {
      it = (ref$ = Block(them), ref$.front = this.front, ref$['void'] = true, ref$);
    }
    return it.compile(o, LEVEL_PAREN);
  };
  prototype.compilePluck = function(o){
    var ref$, get, del, code, ref;
    ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
    code = this.assigned
      ? ''
      : (ref = o.scope.temporary()) + " = ";
    code += get.compile(o, LEVEL_LIST) + ", delete " + del.compile(o, LEVEL_LIST);
    if (this.assigned) {
      return code;
    }
    code += ", " + o.scope.free(ref);
    if (o.level < LEVEL_LIST) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  prototype.compileAsFunc = function(o){
    if (this.op === '!') {
      return util('not');
    } else {
      return "(" + Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o) + ")";
    }
  };
  return Unary;
}(Node));
exports.Binary = Binary = (function(superclass){
  var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;
  function Binary(op, first, second, destructuring){
    var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
    if (destructuring) {
      logic = op.logic;
      if (toString$.call(destructuring).slice(8, -1) === 'String') {
        logic = destructuring;
      }
      op = (function(){
        switch (false) {
        case !(that = logic):
          return that;
        case op !== '=':
          return '?';
        default:
          return '=';
        }
      }());
    }
    this$.partial = first == null || second == null;
    if (!this$.partial) {
      if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) != '=' && ref$ != '<' && ref$ != '>' && ref$ != '!')) {
        return Assign(first.unwrap(), second, op);
      }
      switch (op) {
      case 'in':
        return new In(first, second);
      case 'with':
        return new Import(Unary('^^', first), second, false);
      case '<<<':
      case '<<<<':
        return Import(first, second, op === '<<<<');
      case '<|':
        return Block(first).pipe(second, op);
      case '|>':
        return Block(second).pipe(first, '<|');
      }
    }
    this$.op = op;
    this$.first = first;
    this$.second = second;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['first', 'second'];
  prototype.show = function(){
    return this.op;
  };
  prototype.isCallable = function(){
    var ref$;
    return this.partial || ((ref$ = this.op) == '&&' || ref$ == '||' || ref$ == '?' || ref$ == '!?' || ref$ == '<<' || ref$ == '>>') && this.first.isCallable() && this.second.isCallable();
  };
  prototype.isArray = function(){
    switch (this.op) {
    case '*':
      return this.first.isArray();
    case '/':
      return this.second.isMatcher();
    }
  };
  prototype.isString = function(){
    switch (this.op) {
    case '+':
    case '*':
      return this.first.isString() || this.second.isString();
    case '-':
      return this.second.isMatcher();
    }
  };
  COMPARER = /^(?:[!=]=|[<>])=?$/;
  INVERSIONS = {
    '===': '!==',
    '!==': '===',
    '==': '!=',
    '!=': '=='
  };
  prototype.invert = function(){
    var that;
    if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {
      this.op = that;
      return this;
    }
    return Unary('!', Parens(this), true);
  };
  prototype.invertIt = function(){
    this.inverted = true;
    return this;
  };
  prototype.getDefault = function(){
    switch (this.op) {
    case '?':
    case '||':
    case '&&':
    case '!?':
      return this;
    }
  };
  prototype.xorChildren = function(test){
    var ref$, ref1$, first;
    if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) && (ref$ || ref1$))) {
      return false;
    }
    return first
      ? [this.first, this.second]
      : [this.second, this.first];
  };
  prototype.compileNode = function(o){
    var top, rite, items, that, ref$, code, level;
    if (this.partial) {
      return this.compilePartial(o);
    }
    switch (this.op) {
    case '?':
    case '!?':
      return this.compileExistence(o);
    case '*':
      if (this.second.isString()) {
        return this.compileJoin(o);
      }
      if (this.first.isString() || this.first.isArray()) {
        return this.compileRepeat(o);
      }
      break;
    case '-':
      if (this.second.isMatcher()) {
        return this.compileRemove(o);
      }
      break;
    case '/':
      if (this.second.isMatcher()) {
        return this.compileSplit(o);
      }
      break;
    case '**':
    case '^':
      return this.compilePow(o);
    case '<?':
    case '>?':
      return this.compileMinMax(o);
    case '<<':
    case '>>':
      return this.compileCompose(o);
    case '+++':
      return this.compileConcat(o);
    case '%':
      return this.compileMod(o);
    case 'xor':
      return this.compileXor(o);
    case '&&':
    case '||':
      if (top = this['void'] || !o.level) {
        this.second['void'] = true;
      }
      if (top || this.cond) {
        this.first.cond = true;
        this.second.cond = true;
      }
      break;
    case 'instanceof':
      rite = this.second.expandSlice(o).unwrap(), items = rite.items;
      if (rite instanceof Arr) {
        if (items[1]) {
          return this.compileAnyInstanceOf(o, items);
        }
        this.second = items[0] || rite;
      }
      this.second.isCallable() || this.second.carp('invalid instanceof operand');
      break;
    case '====':
    case '!===':
      this.op = this.op.slice(0, 3);
      // fallthrough
    case '<==':
    case '>==':
    case '<<=':
    case '>>=':
      return this.compileDeepEq(o);
    default:
      if (COMPARER.test(this.op)) {
        if (that = ((ref$ = this.op) == '===' || ref$ == '!==') && this.xorChildren(function(it){
          return it.isRegex();
        })) {
          return this.compileRegexEquals(o, that);
        }
        if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {
          if (typeof console != 'undefined' && console !== null) {
            console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + " == " + this.second.value);
          }
        }
      }
      if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {
        return this.compileChain(o);
      }
    }
    this.first.front = this.front;
    code = this.first.compile(o, level = LEVEL_OP + PREC[this.op]) + " " + this.mapOp(this.op) + " " + this.second.compile(o, level);
    if (o.level <= level) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  prototype.mapOp = function(op){
    var that;
    switch (false) {
    case !(that = op.match(/\.([&\|\^]|<<|>>>?)\./)):
      return that[1];
    case op !== 'of':
      return 'in';
    default:
      return op;
    }
  };
  prototype.compileChain = function(o){
    var code, level, ref$, sub;
    code = this.first.compile(o, level = LEVEL_OP + PREC[this.op]);
    ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
    code += " " + this.op + " " + sub.compile(o, level) + " && " + this.second.compile(o, LEVEL_OP);
    if (o.level <= LEVEL_OP) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  prototype.compileExistence = function(o){
    var x, ref$;
    if (this.op === '!?') {
      x = (ref$ = If(Existence(this.first), this.second), ref$.cond = this.cond, ref$['void'] = this['void'] || !o.level, ref$);
      return x.compileExpression(o);
    }
    if (this['void'] || !o.level) {
      x = Binary('&&', Existence(this.first, true), this.second);
      return (x['void'] = true, x).compileNode(o);
    }
    x = this.first.cache(o, true);
    return If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o);
  };
  prototype.compileAnyInstanceOf = function(o, items){
    var ref$, sub, ref, test, i$, len$, item;
    ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
    test = Binary('instanceof', sub, items.shift());
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      item = items[i$];
      test = Binary('||', test, Binary('instanceof', ref, item));
    }
    return Parens(test).compile(o);
  };
  prototype.compileMinMax = function(o){
    var lefts, rites, x;
    lefts = this.first.cache(o, true);
    rites = this.second.cache(o, true);
    x = Binary(this.op.charAt(), lefts[0], rites[0]);
    return If(x, lefts[1]).addElse(rites[1]).compileExpression(o);
  };
  prototype.compileMethod = function(o, klass, method, arg){
    var args;
    args = [this.second].concat(arg || []);
    if (this.first["is" + klass]()) {
      return Chain(this.first, [Index(Key(method)), Call(args)]).compile(o);
    } else {
      args.unshift(this.first);
      return Call.make(JS(util(method) + '.call'), args).compile(o);
    }
  };
  prototype.compileJoin = function(it){
    return this.compileMethod(it, 'Array', 'join');
  };
  prototype.compileRemove = function(it){
    return this.compileMethod(it, 'String', 'replace', JS("''"));
  };
  prototype.compileSplit = function(it){
    return this.compileMethod(it, 'String', 'split');
  };
  prototype.compileRepeat = function(o){
    var x, n, items, arr, that, refs, i$, len$, i, item, ref$, q;
    x = this.first, n = this.second;
    items = (x = x.expandSlice(o).unwrap()).items;
    arr = x.isArray() && 'Array';
    if (that = items && Splat.compileArray(o, items)) {
      x = JS(that);
      items = null;
    }
    if (arr && !items || !(n instanceof Literal && n.value < 0x20)) {
      return Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o);
    }
    n = +n.value;
    if (1 <= n && n < 2) {
      return x.compile(o);
    }
    if (items) {
      if (n < 1) {
        return Block(items).add(JS('[]')).compile(o);
      }
      refs = [];
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
        i = i$;
        item = items[i$];
        ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
      }
      items.push((ref$ = JS(), ref$.compile = function(){
        return (repeatString$(", " + List.compile(o, refs), n - 1)).slice(2);
      }, ref$));
      return x.compile(o);
    } else if (x instanceof Literal) {
      return (q = (x = x.compile(o)).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q;
    } else {
      if (n < 1) {
        return Block(x.it).add(JS("''")).compile(o);
      }
      x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
      if (o.level < LEVEL_OP + PREC['+']) {
        return x;
      } else {
        return "(" + x + ")";
      }
    }
  };
  prototype.compilePow = function(o){
    return Call.make(JS('Math.pow'), [this.first, this.second]).compile(o);
  };
  prototype.compileConcat = function(o){
    var f;
    f = function(x){
      switch (false) {
      case !(x instanceof Binary && x.op === '+++'):
        return f(x.first).concat(f(x.second));
      default:
        return [x];
      }
    };
    return Chain(this.first).add(Index(Key('concat'), '.', true)).add(Call(f(this.second))).compile(o);
  };
  prototype.compileCompose = function(o){
    var f, args;
    f = function(x){
      var ref$;
      switch (false) {
      case !(x instanceof Binary && ((ref$ = x.op) == '<<' || ref$ == '>>')):
        return f(x.first).concat(f(x.second));
      default:
        return [x];
      }
    };
    args = [this.first].concat(f(this.second));
    if (this.op === '>>') {
      args = args.reverse();
    }
    return Chain(Var(util('compose'))).add(Call([Arr(args)])).compile(o);
  };
  prototype.compileMod = function(o){
    var ref, code;
    ref = o.scope.temporary();
    code = "((" + this.first.compile(o) + ") % (" + ref + " = " + this.second.compile(o) + ") + " + ref + ") % " + ref;
    o.scope.free(ref);
    return code;
  };
  prototype.compilePartial = function(o){
    var vit, x, y;
    vit = Var('it');
    switch (false) {
    case !(this.first == null && this.second == null):
      x = Var('x$');
      y = Var('y$');
      return Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o);
    case this.first == null:
      return "(" + Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this))).compile(o) + ")";
    default:
      return "(" + Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this))).compile(o) + ")";
    }
  };
  prototype.compileRegexEquals = function(o, arg$){
    var regex, target;
    regex = arg$[0], target = arg$[1];
    if (this.op === '===') {
      return Chain(regex).add(Index(Key('exec'))).add(Call([target])).compile(o);
    } else {
      return Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o);
    }
  };
  prototype.compileDeepEq = function(o){
    var ref$, negate, i$, len$, x, r;
    if ((ref$ = this.op) == '>==' || ref$ == '>>=') {
      ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
      this.op = this.op === '>==' ? '<==' : '<<=';
    }
    if (this.op === '!==') {
      this.op = '===';
      negate = true;
    }
    for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x instanceof Obj || x instanceof Arr) {
        x.deepEq = true;
      }
    }
    r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
    return (negate ? Unary('!', r) : r).compile(o);
  };
  prototype.compileXor = function(o){
    var left, right;
    left = Chain(this.first).cacheReference(o);
    right = Chain(this.second).cacheReference(o);
    return Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o);
  };
  return Binary;
}(Node));
exports.Assign = Assign = (function(superclass){
  var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;
  function Assign(left, rite, op, logic, defParam){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.left = left;
    this$.op = op || '=';
    this$.logic = logic || this$.op.logic;
    this$.defParam = defParam;
    this$.op += '';
    this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['left', 'right'];
  prototype.show = function(){
    return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
  };
  prototype.assigns = function(it){
    return this.left.assigns(it);
  };
  prototype.delegate(['isCallable', 'isRegex'], function(it){
    var ref$;
    return ((ref$ = this.op) == '=' || ref$ == ':=') && this.right[it]();
  });
  prototype.isArray = function(){
    switch (this.op) {
    case '=':
    case ':=':
      return this.right.isArray();
    case '/=':
      return this.right.isMatcher();
    }
  };
  prototype.isString = function(){
    switch (this.op) {
    case '=':
    case ':=':
    case '+=':
    case '*=':
      return this.right.isString();
    case '-=':
      return this.right.isMatcher();
    }
  };
  prototype.unfoldSoak = function(o){
    var that, ref$, rite, temps;
    if (this.left instanceof Existence) {
      if (that = (ref$ = this.left = this.left.it).name, delete ref$.name, that) {
        rite = this.right;
        rite = Assign(this.right = Var(that), rite);
      } else {
        ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
      }
      return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
    }
    return If.unfoldSoak(o, this, 'left');
  };
  prototype.unfoldAssign = function(){
    return this.access && this;
  };
  prototype.compileNode = function(o){
    var left, ref$, i$, len$, op, right, reft, sign, name, lvar, del, that, protoSplit, dotSplit, code, empty, res;
    if (this.left instanceof Slice && this.op === '=') {
      return this.compileSplice(o);
    }
    left = this.left.expandSlice(o, true).unwrap();
    if (!this.right) {
      left.isAssignable() || left.carp('invalid unary assign');
      ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
      for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {
        op = ref$[i$];
        this.right = Unary(op, this.right);
      }
    }
    if (left.isEmpty()) {
      return (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o);
    }
    if (left.getDefault()) {
      this.right = Binary(left.op, this.right, left.second);
      left = left.first;
    }
    if (left.items) {
      return this.compileDestructuring(o, left);
    }
    left.isAssignable() || left.carp('invalid assign');
    if (this.logic) {
      return this.compileConditional(o, left);
    }
    op = this.op, right = this.right;
    if (op == '<?=' || op == '>?=') {
      return this.compileMinMax(o, left, right);
    }
    if ((op == '**=' || op == '^=' || op == '%=') || op === '*=' && right.isString() || (op == '-=' || op == '/=') && right.isMatcher()) {
      ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
      right = Binary(op.slice(0, -1), reft, right);
      op = ':=';
    }
    if (op == '.&.=' || op == '.|.=' || op == '.^.=' || op == '.<<.=' || op == '.>>.=' || op == '.>>>.=') {
      op = op.slice(1, -2) + '=';
    }
    (right = right.unparen()).ripName(left = left.unwrap());
    sign = op.replace(':', '');
    name = (left.front = true, left).compile(o, LEVEL_LIST);
    if (lvar = left instanceof Var) {
      del = right.op === 'delete';
      if (op === '=') {
        o.scope.declare(name, left, this['const'] || !this.defParam && o['const'] && '$' !== name.slice(-1));
      } else if (that = o.scope.checkReadOnly(name)) {
        left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
      }
    }
    if (left instanceof Chain && right instanceof Fun) {
      protoSplit = name.split('.prototype.');
      dotSplit = name.split('.');
      if (protoSplit.length > 1) {
        right.inClass = protoSplit[0];
      } else if (dotSplit.length > 1) {
        right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
      }
    }
    code = !o.level && right instanceof While && !right['else'] && (lvar || left.isSimpleAccess())
      ? (empty = right.objComp ? '{}' : '[]', (res = o.scope.temporary('res')) + " = " + empty + ";\n" + this.tab + right.makeReturn(res).compile(o) + "\n" + this.tab + name + " " + sign + " " + o.scope.free(res))
      : (name + " " + sign + " ") + (right.assigned = true, right).compile(o, LEVEL_LIST);
    if (that = o.level) {
      if (del) {
        code += ", " + name;
      }
      if (that > (del ? LEVEL_PAREN : LEVEL_LIST)) {
        code = "(" + code + ")";
      }
    }
    return code;
  };
  prototype.compileConditional = function(o, left){
    var ref$, lefts, morph;
    if (left instanceof Var && ((ref$ = this.logic) == '?' || ref$ == '!?') && this.op === '=') {
      o.scope.declare(left.value, left);
    }
    lefts = Chain(left).cacheReference(o);
    o.level += LEVEL_OP < o.level;
    morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
    return (morph['void'] = this['void'], morph).compileNode(o);
  };
  prototype.compileMinMax = function(o, left, right){
    var lefts, rites, test, put, ref$;
    lefts = Chain(left).cacheReference(o);
    rites = right.cache(o, true);
    test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
    put = Assign(lefts[1], rites[1], ':=');
    if (this['void'] || !o.level) {
      return Parens(Binary('||', test, put)).compile(o);
    }
    ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
    return If(test, left).addElse(put).compileExpression(o);
  };
  prototype.compileDestructuring = function(o, left){
    var items, len, ret, rite, that, cache, rref, list, code;
    items = left.items, len = items.length;
    ret = o.level && !this['void'];
    rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
    if (that = left.name) {
      cache = that + " = " + rite;
      o.scope.declare(rite = that, left);
    } else if ((ret || len > 1) && (!ID.test(rite) || left.assigns(rite))) {
      cache = (rref = o.scope.temporary()) + " = " + rite;
      rite = rref;
    }
    list = this["rend" + left.constructor.displayName](o, items, rite);
    if (rref) {
      o.scope.free(rref);
    }
    if (cache) {
      list.unshift(cache);
    }
    if (ret || !list.length) {
      list.push(rite);
    }
    code = list.join(', ');
    if (list.length < 2 || o.level < LEVEL_LIST) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  prototype.compileSplice = function(o){
    var ref$, fromExpNode, fromExp, rightNode, right, toExp;
    ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
    ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
    toExp = Binary('-', this.left.to, fromExp);
    return Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST);
  };
  prototype.rendArr = function(o, nodes, rite){
    var i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, ref$, results$ = [];
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      i = i$;
      node = nodes[i$];
      if (node.isEmpty()) {
        continue;
      }
      if (node instanceof Splat) {
        len && node.carp('multiple splat in an assignment');
        skip = (node = node.it).isEmpty();
        if (i + 1 === (len = nodes.length)) {
          if (skip) {
            break;
          }
          val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
        } else {
          val = ivar = rite + ".length - " + (len - i - 1);
          if (skip && i + 2 === len) {
            continue;
          }
          start = i + 1;
          this.temps = [ivar = o.scope.temporary('i')];
          val = skip
            ? (node = Var(ivar), Var(val))
            : Arr.wrap(JS(i + " < (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
        }
      } else {
        (inc = ivar) && start < i && (inc += " + " + (i - start));
        val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
      }
      if (node instanceof Assign) {
        node = Binary(node.op, node.left, node.right, node.logic || true);
      }
      results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
    }
    return results$;
  };
  prototype.rendObj = function(o, nodes, rite){
    var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      node = nodes[i$];
      if (splat = node instanceof Splat) {
        node = node.it;
      }
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
      } else if (node instanceof Prop) {
        node = (key = node.key, node).val;
      } else {
        key = node;
      }
      if (node instanceof Key) {
        node = Var(node.name);
      }
      if (logic) {
        node = (logic.first = node, logic);
      }
      val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
      if (splat) {
        val = Import(Obj(), val);
      }
      results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
    }
    return results$;
  };
  return Assign;
}(Node));
exports.Import = Import = (function(superclass){
  var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;
  function Import(left, right, all){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.left = left;
    this$.right = right;
    this$.all = all && 'All';
    if (!all && left instanceof Obj && right.items) {
      return Obj(left.items.concat(right.asObj().items));
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['left', 'right'];
  prototype.show = function(){
    return this.all;
  };
  prototype.delegate(['isCallable', 'isArray'], function(it){
    return this.left[it]();
  });
  prototype.unfoldSoak = function(o){
    var left, value, ref$, temps;
    left = this.left;
    if (left instanceof Existence && !left.negated) {
      if ((left = left.it) instanceof Var) {
        value = (this.left = left).value;
        if (!o.scope.check(value, true)) {
          left = JS("typeof " + value + " != 'undefined' && " + value);
        }
      } else {
        ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
      }
      return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
    }
    return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) && If.unfoldSoak(o, this, 'right');
  };
  prototype.compileNode = function(o){
    var right;
    right = this.right;
    if (!this.all) {
      if (right instanceof Chain) {
        right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
      }
      if (right instanceof List) {
        return this.compileAssign(o, right.asObj().items);
      }
    }
    return Call.make(Util("import" + (this.all || '')), [this.left, right]).compileNode(o);
  };
  prototype.compileAssign = function(o, items){
    var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
    if (!items.length) {
      return this.left.compile(o);
    }
    top = !o.level;
    if (items.length < 2 && (top || this['void'] || items[0] instanceof Splat)) {
      reft = this.left;
      if (reft.isComplex()) {
        reft = Parens(reft);
      }
    } else {
      ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
    }
    ref$ = top
      ? [';', '\n' + this.tab]
      : [',', ' '], delim = ref$[0], space = ref$[1];
    delim += space;
    code = this.temps ? left.compile(o, LEVEL_PAREN) + delim : '';
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      node = items[i$];
      i && (code += com ? space : delim);
      if (com = node.comment) {
        code += node.compile(o);
        continue;
      }
      if (node instanceof Splat) {
        code += Import(reft, node.it).compile(o);
        continue;
      }
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (dyna = node instanceof Parens) {
        ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
      } else if (node instanceof Prop) {
        key = node.key, val = node.val;
        if (node.accessor) {
          if (key instanceof Key) {
            key = JS("'" + key.name + "'");
          }
          code += "Object.defineProperty(" + reft.compile(o, LEVEL_LIST) + ", " + key.compile(o, LEVEL_LIST) + ", " + node.compileDescriptor(o) + ")";
          continue;
        }
      } else {
        key = val = node;
      }
      dyna || (key = key.maybeKey());
      logic && (val = (logic.first = val, logic));
      code += Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN);
    }
    if (top) {
      return code;
    }
    this['void'] || node instanceof Splat || (code += (com ? ' ' : ', ') + reft.compile(o, LEVEL_PAREN));
    if (o.level < LEVEL_LIST) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  return Import;
}(Node));
exports.In = In = (function(superclass){
  var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;
  importAll$(prototype, arguments[1]);
  function In(item, array){
    this.item = item;
    this.array = array;
  }
  prototype.children = ['item', 'array'];
  prototype.compileNode = function(o){
    var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
    items = (array = this.array.expandSlice(o).unwrap()).items;
    if (!(array instanceof Arr) || items.length < 2) {
      return (this.negated ? '!' : '') + "" + util('in') + "(" + this.item.compile(o, LEVEL_LIST) + ", " + array.compile(o, LEVEL_LIST) + ")";
    }
    code = '';
    ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
    ref$ = this.negated
      ? [' != ', ' && ']
      : [' == ', ' || '], cmp = ref$[0], cnj = ref$[1];
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      test = items[i$];
      code && (code += cnj);
      if (test instanceof Splat) {
        code += (ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP);
        if (!(i || sub === ref)) {
          code = "(" + sub + ", " + code + ")";
        }
      } else {
        code += (i || sub === ref
          ? ref
          : "(" + sub + ")") + cmp + test.compile(o, LEVEL_OP + PREC['==']);
      }
    }
    sub === ref || o.scope.free(ref);
    if (o.level < LEVEL_OP + PREC['||']) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  return In;
}(Node, Negatable));
exports.Existence = Existence = (function(superclass){
  var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;
  importAll$(prototype, arguments[1]);
  function Existence(it, negated){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.negated = negated;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['it'];
  prototype.compileNode = function(o){
    var node, ref$, code, op, eq;
    node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
    code = node.compile(o, LEVEL_OP + PREC['==']);
    if (node instanceof Var && !o.scope.check(code, true)) {
      ref$ = this.negated
        ? ['||', '=']
        : ['&&', '!'], op = ref$[0], eq = ref$[1];
      code = "typeof " + code + " " + eq + "= 'undefined' " + op + " " + code + " " + eq + "== null";
    } else {
      code += " " + (op = this.negated ? '==' : '!=') + " null";
    }
    if (o.level < LEVEL_OP + PREC[op]) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  return Existence;
}(Node, Negatable));
exports.Fun = Fun = (function(superclass){
  var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;
  function Fun(params, body, bound, curried){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.params = params || [];
    this$.body = body || Block();
    this$.bound = bound && 'this$';
    this$.curried = curried || false;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['params', 'body'];
  prototype.show = function(){
    var that;
    return [this.name] + [(that = this.bound) ? "~" + that : void 8];
  };
  prototype.named = function(it){
    return this.name = it, this.statement = true, this;
  };
  prototype.isCallable = YES;
  prototype.isStatement = function(){
    return !!this.statement;
  };
  prototype.traverseChildren = function(arg$, xscope){
    if (xscope) {
      return superclass.prototype.traverseChildren.apply(this, arguments);
    }
  };
  prototype.makeReturn = function(){
    if (this.statement) {
      return this.returns = true, this;
    } else {
      return superclass.prototype.makeReturn.apply(this, arguments);
    }
  };
  prototype.ripName = function(it){
    this.name || (this.name = it.varName());
  };
  prototype.compileNode = function(o){
    var pscope, sscope, scope, that, inLoop, body, name, tab, code, ref$, curryCodeCheck, this$ = this;
    pscope = o.scope;
    sscope = pscope.shared || pscope;
    scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);
    scope.fun = this;
    if (that = this.proto) {
      scope.assign('prototype', that.compile(o) + ".prototype");
    }
    if (that = this.cname) {
      scope.assign('constructor', that);
    }
    if (inLoop = o.loop, delete o.loop, inLoop) {
      o.indent = this.tab = '';
    }
    o.indent += TAB;
    body = this.body, name = this.name, tab = this.tab;
    code = 'function';
    if (this.bound === 'this$') {
      if (this.ctor) {
        scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
        body.add(Return(Literal('this$')));
      } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
        this.bound = that;
      } else {
        sscope.assign('this$', 'this');
      }
    }
    if (this.statement) {
      name || this.carp('nameless function declaration');
      pscope === o.block.scope || this.carp('misplaced function declaration');
      this.accessor && this.carp('named accessor');
      pscope.add(name, 'function', this);
    }
    if (this.statement || name && this.labeled) {
      code += ' ' + scope.add(name, 'function', this);
    }
    this['void'] || this.ctor || body.makeReturn();
    code += "(" + this.compileParams(scope) + "){";
    if (that = body.compileWithDeclarations(o)) {
      code += "\n" + that + "\n" + tab;
    }
    code += '}';
    curryCodeCheck = function(){
      if (this$.curried) {
        if (this$.hasSplats) {
          this$.carp('cannot curry a function with a variable number of arguments');
        }
        return util('curry') + "(" + code + ")";
      } else {
        return code;
      }
    };
    if (inLoop) {
      return pscope.assign(pscope.temporary('fn'), curryCodeCheck());
    }
    if (this.returns) {
      code += "\n" + tab + "return " + name + ";";
    } else if (this.bound && this.ctor) {
      code += ' function ctor$(){} ctor$.prototype = prototype;';
    }
    code = curryCodeCheck();
    if (this.front && !this.statement) {
      return "(" + code + ")";
    } else {
      return code;
    }
  };
  prototype.compileParams = function(scope){
    var params, body, names, assigns, i$, len$, i, p, splace, rest, that, dic, vr, df, v, ref$, ref1$, name;
    params = this.params, body = this.body;
    names = [];
    assigns = [];
    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
      i = i$;
      p = params[i$];
      if (p instanceof Splat) {
        splace = i;
        this.hasSplats = true;
      } else if (p.op === '=') {
        params[i] = Binary(p.logic || '?', p.left, p.right);
      }
    }
    if (splace != null) {
      rest = params.splice(splace, 9e9);
      if (!rest[1] && rest[0].it.isEmpty()) {
        rest = 0;
      }
    } else if (this.accessor) {
      if (that = params[1]) {
        that.carp('excess accessor parameter');
      }
    } else if (!(params.length || this.wrapper)) {
      if (body.traverseChildren(function(it){
        return it.value === 'it' || null;
      })) {
        params[0] = Var('it');
      }
    }
    if (params.length) {
      dic = {};
      for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
        p = params[i$];
        vr = p;
        if (df = vr.getDefault()) {
          vr = vr.first;
        }
        if (vr.isEmpty()) {
          vr = Var(scope.temporary('arg'));
        } else if (!(vr instanceof Var)) {
          v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
          assigns.push(Assign(vr, df ? Binary(p.op, v, p.second) : v));
          vr = v;
        } else if (df) {
          assigns.push(Assign(vr, p.second, '=', p.op, true));
        }
        names.push(name = scope.add(vr.value, 'arg', p));
        if (!(dic[name + "."] ^= 1)) {
          p.carp("duplicate parameter \"" + name + "\"");
        }
      }
    }
    if (rest) {
      while (splace--) {
        rest.unshift(Arr());
      }
      assigns.push(Assign(Arr(rest), Literal('arguments')));
    }
    if (assigns.length) {
      (ref$ = this.body).prepend.apply(ref$, assigns);
    }
    return names.join(', ');
  };
  return Fun;
}(Node));
exports.Class = Class = (function(superclass){
  var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;
  function Class(arg$){
    var body;
    this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
    this.fun = Fun([], body);
  }
  prototype.children = ['title', 'sup', 'mixins', 'fun'];
  prototype.isCallable = YES;
  prototype.ripName = function(it){
    this.name = it.varName();
  };
  prototype.compile = function(o, level){
    var fun, body, lines, title, boundFuncs, decl, name, proto, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, ref$, f, vname, args, that, imports, res$, clas;
    fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
    boundFuncs = [];
    decl = title != null ? title.varName() : void 8;
    name = decl || this.name;
    if (ID.test(name || '')) {
      fun.cname = name;
    } else {
      name = 'constructor';
    }
    proto = Var('prototype');
    ctorName = 'constructor$$';
    importProtoObj = function(node, i){
      var j, prop, ref$, i$, len$, f;
      j = 0;
      for (; j < node.items.length; j++) {
        prop = node.items[j];
        if ((ref$ = prop.key) instanceof Key || ref$ instanceof Literal) {
          if ((prop.key instanceof Key && prop.key.name === ctorName) || (prop.key instanceof Literal && prop.key.value === "'" + ctorName + "'")) {
            if (ctor) {
              node.carp('redundant constructor');
            }
            ctor = prop.val;
            node.items.splice(j--, 1);
            ctorPlace = i;
          } else if (prop.val instanceof Fun) {
            prop.val.meth = prop.key;
            if (prop.val.bound) {
              boundFuncs.push(prop.key);
              prop.val.bound = false;
            }
          } else if (prop.accessor) {
            for (i$ = 0, len$ = (ref$ = prop.val).length; i$ < len$; ++i$) {
              f = ref$[i$];
              f.meth = prop.key;
            }
          }
        }
      }
      if (node.items.length) {
        return Import(proto, node);
      } else {
        return Literal('void');
      }
    };
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      i = i$;
      node = lines[i$];
      if (node instanceof Obj) {
        lines[i] = importProtoObj(node, i);
      } else if (node instanceof Fun && !node.statement) {
        ctor && node.carp('redundant constructor');
        ctor = node;
      } else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {
        node.right.stat = node.left.tails[0].key;
      } else {
        node.traverseChildren(fn$);
      }
    }
    ctor || (ctor = lines[lines.length] = this.sup && ((ref$ = this.sup) instanceof Fun || ref$ instanceof Var)
      ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
      : Fun());
    if (!(ctor instanceof Fun)) {
      lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
      lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
    }
    ctor.name = name;
    ctor.ctor = true;
    ctor.statement = true;
    for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {
      f = boundFuncs[i$];
      ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'" + f.name + "'"), Var('prototype')]))));
    }
    lines.push(vname = fun.proto = Var(fun.bound = name));
    args = [];
    if (that = this.sup) {
      args.push(that);
      imports = Chain(Import(Literal('this'), Var('superclass')));
      fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
    }
    if (that = this.mixins) {
      res$ = [];
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        args[args.length] = that[i$];
        res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
      }
      imports = res$;
      body.prepend.apply(body, imports);
    }
    if (fun.cname && !this.sup) {
      body.prepend(Literal(name + ".displayName = '" + name + "'"));
    }
    clas = Parens(Call.make(fun, args), true);
    if (decl && title.isComplex()) {
      clas = Assign(vname, clas);
    }
    if (title) {
      clas = Assign(title, clas);
    }
    return clas.compile(o, level);
    function fn$(it){
      var i$, ref$, len$, k, child;
      if (it instanceof Block) {
        for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {
          k = i$;
          child = ref$[i$];
          if (child instanceof Obj) {
            it.lines[k] = importProtoObj(child, i);
          }
        }
      }
    }
  };
  return Class;
}(Node));
exports.Super = Super = (function(superclass){
  var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;
  function Super(){}
  prototype.isCallable = YES;
  prototype.compile = function(o){
    var scope, that, result, ref$;
    scope = o.scope;
    if (!this.sproto) {
      for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {
        result = that;
        if (that = result.meth) {
          return 'superclass.prototype' + Index(that).compile(o);
        }
        if (that = result.stat) {
          return 'superclass' + Index(that).compile(o);
        }
        if (that = scope.fun.inClass) {
          return that + ".superclass.prototype." + scope.fun.name;
        } else if (that = scope.fun.inClassStatic) {
          return that + ".superclass." + scope.fun.name;
        }
      }
      if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
        return that + ".superclass";
      }
    }
    return 'superclass';
  };
  return Super;
}(Node));
exports.Parens = Parens = (function(superclass){
  var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;
  function Parens(it, keep, string){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.keep = keep;
    this$.string = string;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['it'];
  prototype.show = function(){
    return this.string && '""';
  };
  prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex'], function(it){
    return this.it[it]();
  });
  prototype.isString = function(){
    return this.string || this.it.isString();
  };
  prototype.unparen = function(){
    if (this.keep) {
      return this;
    } else {
      return this.it.unparen();
    }
  };
  prototype.compile = function(o, level){
    var it;
    level == null && (level = o.level);
    it = this.it;
    it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
    if (this.calling && (!level || this['void'])) {
      it.head['void'] = true;
    }
    if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {
      return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
    }
    if (it.isStatement()) {
      return it.compileClosure(o);
    } else {
      return "(" + it.compile(o, LEVEL_PAREN) + ")";
    }
  };
  return Parens;
}(Node));
exports.Splat = Splat = (function(superclass){
  var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;
  function Splat(it, filler){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.filler = filler;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
  prototype.isAssignable = YES;
  prototype.assigns = function(it){
    return this.it.assigns(it);
  };
  prototype.compile = function(){
    return this.carp('invalid splat');
  };
  Splat.compileArray = function(o, list, apply){
    var index, i$, len$, node, args, atoms, ref$;
    expand(list);
    index = 0;
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      node = list[i$];
      if (node instanceof Splat) {
        break;
      }
      ++index;
    }
    if (index >= list.length) {
      return '';
    }
    if (!list[1]) {
      return (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST);
    }
    args = [];
    atoms = [];
    for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node instanceof Splat) {
        if (atoms.length) {
          args.push(Arr(atoms.splice(0, 9e9)));
        }
        args.push(ensureArray(node.it));
      } else {
        atoms.push(node);
      }
    }
    if (atoms.length) {
      args.push(Arr(atoms));
    }
    return (index
      ? Arr(list)
      : args.shift()).compile(o, LEVEL_CALL) + (".concat(" + List.compile(o, args) + ")");
  };
  function expand(nodes){
    var index, node, it;
    index = -1;
    while (node = nodes[++index]) {
      if (node instanceof Splat) {
        it = node.it;
        if (it.isEmpty()) {
          nodes.splice(index--, 1);
        } else if (it instanceof Arr) {
          nodes.splice.apply(nodes, [index, 1].concat(slice$.call(expand(it.items))));
          index += it.items.length - 1;
        }
      }
    }
    return nodes;
  }
  function ensureArray(node){
    if (node.isArray()) {
      return node;
    }
    return Call.make(JS(util('slice') + '.call'), [node]);
  }
  return Splat;
}(Node));
exports.Jump = Jump = (function(superclass){
  var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;
  function Jump(verb, label){
    this.verb = verb;
    this.label = label;
  }
  prototype.show = function(){
    var that;
    return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
  };
  prototype.isStatement = YES;
  prototype.makeReturn = THIS;
  prototype.getJump = function(ctx){
    var that, ref$;
    ctx || (ctx = {});
    if (!ctx[this.verb]) {
      return this;
    }
    if (that = this.label) {
      return !in$(that, (ref$ = ctx.labels) != null
        ? ref$
        : ctx.labels = []) && this;
    }
  };
  prototype.compileNode = function(o){
    var that, ref$;
    if (that = this.label) {
      in$(that, (ref$ = o.labels) != null
        ? ref$
        : o.labels = []) || this.carp("unknown label \"" + that + "\"");
    } else {
      o[this.verb] || this.carp("stray " + this.verb);
    }
    return this.show() + ';';
  };
  Jump.extended = function(sub){
    sub.prototype.children = ['it'];
    this[sub.displayName.toLowerCase()] = sub;
  };
  return Jump;
}(Node));
exports.Throw = Throw = (function(superclass){
  var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;
  function Throw(it){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.getJump = VOID;
  prototype.compileNode = function(o){
    var ref$;
    return "throw " + (((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null') + ";";
  };
  return Throw;
}(Jump));
exports.Return = Return = (function(superclass){
  var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;
  function Return(it){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    if (it && it.value !== 'void') {
      this$.it = it;
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.getJump = THIS;
  prototype.compileNode = function(o){
    var that;
    return "return" + ((that = this.it) ? ' ' + that.compile(o, LEVEL_PAREN) : '') + ";";
  };
  return Return;
}(Jump));
exports.While = While = (function(superclass){
  var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;
  function While(test, un, mode){
    this.un = un;
    mode && (mode instanceof Node
      ? this.update = mode
      : this.post = true);
    if (this.post || test.value !== '' + !un) {
      this.test = test;
    }
  }
  prototype.children = ['test', 'body', 'update', 'else'];
  prototype.aSource = 'test';
  prototype.aTargets = ['body', 'update'];
  prototype.show = function(){
    return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
  };
  prototype.isStatement = prototype.isArray = YES;
  prototype.makeComprehension = function(toAdd, loops){
    this.isComprehension = true;
    while (loops.length) {
      toAdd = loops.pop().addBody(Block(toAdd));
      if (!toAdd.isComprehension) {
        toAdd.inComprehension = true;
      }
    }
    return this.addBody(Block(toAdd));
  };
  prototype.getJump = function(ctx){
    var i$, ref$, ref1$, len$, node;
    ctx || (ctx = {});
    ctx['continue'] = true;
    ctx['break'] = true;
    for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.getJump(ctx)) {
        return node;
      }
    }
  };
  prototype.addBody = function(body){
    var top;
    this.body = body;
    if (this.guard) {
      this.body = Block(If(this.guard, body));
    }
    top = this.body.lines[0];
    if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {
      this.body.lines.length = 0;
    }
    return this;
  };
  prototype.addGuard = function(guard){
    this.guard = guard;
    return this;
  };
  prototype.addObjComp = function(objComp){
    this.objComp = objComp != null ? objComp : true;
    return this;
  };
  prototype.makeReturn = function(it){
    var last, ref$;
    if (it) {
      if (this.objComp) {
        this.body = Block(this.body.makeObjReturn(it));
        if (this.guard) {
          this.body = If(this.guard, this.body);
        }
      } else {
        if (!(this.body || this.index)) {
          this.addBody(Block(Var(this.index = 'ridx$')));
        }
        last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
        if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {
          this.body.makeReturn(it);
          if ((ref$ = this['else']) != null) {
            ref$.makeReturn(it);
          }
        } else {
          this.resVar = it;
          if ((ref$ = this['else']) != null) {
            ref$.makeReturn(it);
          }
        }
      }
    } else {
      this.getJump() || (this.returns = true);
    }
    return this;
  };
  prototype.compileNode = function(o){
    var test, ref$, head, that;
    o.loop = true;
    this.test && (this.un
      ? this.test = this.test.invert()
      : this.anaphorize());
    if (this.post) {
      return 'do {' + this.compileBody((o.indent += TAB, o));
    }
    test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
    if (!(this.update || this['else'])) {
      head = test ? "while (" + test : 'for (;;';
    } else {
      head = 'for (';
      if (this['else']) {
        head += (this.yet = o.scope.temporary('yet')) + " = true";
      }
      head += ";" + (test && ' ' + test) + ";";
      if (that = this.update) {
        head += ' ' + that.compile(o, LEVEL_PAREN);
      }
    }
    return head + ') {' + this.compileBody((o.indent += TAB, o));
  };
  prototype.compileBody = function(o){
    var lines, yet, tab, code, ret, mid, empty, last, hasLoop, res, temp, key$, ref$, that;
    o['break'] = o['continue'] = true;
    lines = this.body.lines, yet = this.yet, tab = this.tab;
    code = ret = mid = '';
    empty = this.objComp ? '{}' : '[]';
    last = lines != null ? lines[lines.length - 1] : void 8;
    if (!((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension))) {
      this.traverseChildren(function(it){
        if (it instanceof While) {
          hasLoop = true;
        }
      });
      if (this.returns && !this.resVar) {
        this.resVar = res = o.scope.assign('results$', empty);
      }
      if (this.resVar && (last instanceof While || hasLoop)) {
        temp = o.scope.temporary('lresult');
        lines.unshift(Assign(Var(temp), Arr(), '='));
        if (lines[key$ = lines.length - 1] != null) {
          lines[key$] = lines[key$].makeReturn(temp);
        }
        mid += TAB + "" + Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o) + ";\n" + this.tab;
      } else {
        this.hasReturned = true;
        if (this.resVar) {
          this.body.makeReturn(this.resVar);
        }
      }
    }
    if (this.returns) {
      if (this.objComp) {
        this.body = Block(this.body.makeObjReturn('results$'));
      }
      if (this.guard && this.objComp) {
        this.body = If(this.guard, this.body);
      }
      if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {
        if (lines[key$ = lines.length - 1] != null) {
          lines[key$] = lines[key$].makeReturn(res = o.scope.assign('results$', empty));
        }
      }
      ret += "\n" + this.tab + "return " + (res || empty) + ";";
      if ((ref$ = this['else']) != null) {
        ref$.makeReturn();
      }
    }
    yet && lines.unshift(JS(yet + " = false;"));
    if (that = this.body.compile(o, LEVEL_TOP)) {
      code += "\n" + that + "\n" + tab;
    }
    code += mid;
    code += '}';
    if (this.post) {
      code += " while (" + this.test.compile((o.tab = tab, o), LEVEL_PAREN) + ");";
    }
    if (yet) {
      code += " if (" + yet + ") " + this.compileBlock(o, Block(this['else']));
      o.scope.free(yet);
    }
    return code + ret;
  };
  return While;
}(Node));
exports.For = For = (function(superclass){
  var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;
  function For(it){
    importAll$(this, it);
    if (this.item instanceof Var && !this.item.value) {
      this.item = null;
    }
  }
  prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];
  prototype.aSource = null;
  prototype.show = function(){
    return this.index;
  };
  prototype.compileNode = function(o){
    var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
    o.loop = true;
    temps = this.temps = [];
    if (this.object && this.index) {
      o.scope.declare(idx = this.index);
    } else {
      temps.push(idx = o.scope.temporary('i'));
    }
    if (!this.body) {
      this.addBody(Block(Var(idx)));
    }
    if (!this.object) {
      ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
      pvar === step || temps.push(pvar);
    }
    if (this.from) {
      ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
      fvar = this.from.compile(o, LEVEL_LIST);
      vars = idx + " = " + fvar;
      if (tail !== tvar) {
        vars += ", " + tail;
        temps.push(tvar);
      }
      if (!this.step && +fvar > +tvar) {
        pvar = step = -1;
      }
      eq = this.op === 'til' ? '' : '=';
      cond = +pvar
        ? idx + " " + '<>'.charAt(pvar < 0) + eq + " " + tvar
        : pvar + " < 0 ? " + idx + " >" + eq + " " + tvar + " : " + idx + " <" + eq + " " + tvar;
    } else {
      if (this.item || this.object && this.own) {
        ref$ = this.source.compileLoopReference(o, 'ref', !this.object), svar = ref$[0], srcPart = ref$[1];
        svar === srcPart || temps.push(svar);
      } else {
        svar = srcPart = this.source.compile(o, LEVEL_PAREN);
      }
      if (!this.object) {
        if (0 > pvar && ~~pvar === +pvar) {
          vars = idx + " = " + srcPart + ".length - 1";
          cond = idx + " >= 0";
        } else {
          temps.push(lvar = o.scope.temporary('len'));
          vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
          cond = idx + " < " + lvar;
        }
      }
    }
    this['else'] && (this.yet = o.scope.temporary('yet'));
    head = 'for (';
    if (this.object) {
      head += idx + " in ";
    }
    if (that = this.yet) {
      head += that + " = true, ";
    }
    if (this.object) {
      head += srcPart;
    } else {
      step === pvar || (vars += ', ' + step);
      head += (vars + "; " + cond + "; ") + (1 == Math.abs(pvar)
        ? (pvar < 0 ? '--' : '++') + idx
        : idx + (pvar < 0
          ? ' -= ' + pvar.slice(1)
          : ' += ' + pvar));
    }
    this.own && (head += ") if (" + o.scope.assign('own$', '{}.hasOwnProperty') + ".call(" + svar + ", " + idx + ")");
    head += ') {';
    this.infuseIIFE();
    o.indent += TAB;
    if (this.index && !this.object) {
      head += '\n' + o.indent + Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP) + ';';
    }
    if (this.item && !this.item.isEmpty()) {
      head += '\n' + o.indent + Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP) + ';';
    }
    body = this.compileBody(o);
    if ((this.item || (this.index && !this.object)) && '}' === body.charAt(0)) {
      head += '\n' + this.tab;
    }
    return head + body;
  };
  prototype.infuseIIFE = function(){
    var this$ = this;
    function dup(params, name){
      var i$, len$, p;
      if (name) {
        for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
          p = params[i$];
          if (name === p.value) {
            return true;
          }
        }
      }
    }
    this.body.traverseChildren(function(it){
      var fun, params, call, index, item, that;
      if (!(it.calling || it.op === 'new' && (fun = it.it).params)) {
        return;
      }
      if (fun) {
        it.it = Call.make((fun['void'] = true, fun));
      } else {
        fun = it.it.head;
      }
      params = fun.params;
      call = it.it.tails[0];
      if (params.length ^ call.args.length - !!call.method) {
        return;
      }
      index = this$.index, item = this$.item;
      if (index && !dup(params, index)) {
        call.args.push(params[params.length] = Var(index));
      }
      if (that = item instanceof List && item.name) {
        item = Var(that);
      }
      if (item instanceof Var && !dup(params, item.value)) {
        call.args.push(params[params.length] = item);
      }
    });
  };
  return For;
}(While));
exports.Try = Try = (function(superclass){
  var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;
  function Try(attempt, thrown, recovery, ensure){
    var ref$;
    this.attempt = attempt;
    this.thrown = thrown;
    this.recovery = recovery;
    this.ensure = ensure;
    if ((ref$ = this.recovery) != null) {
      ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
    }
  }
  prototype.children = ['attempt', 'recovery', 'ensure'];
  prototype.show = function(){
    return this.thrown;
  };
  prototype.isStatement = YES;
  prototype.isCallable = function(){
    var ref$;
    return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();
  };
  prototype.getJump = function(it){
    var ref$;
    return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
  };
  prototype.makeReturn = function(it){
    this.attempt = this.attempt.makeReturn(it);
    if (this.recovery != null) {
      this.recovery = this.recovery.makeReturn(it);
    }
    return this;
  };
  prototype.compileNode = function(o){
    var code, that;
    o.indent += TAB;
    code = 'try ' + this.compileBlock(o, this.attempt);
    if (that = this.recovery || !this.ensure && JS('')) {
      code += ' catch (e$) ' + this.compileBlock(o, that);
    }
    if (that = this.ensure) {
      code += ' finally ' + this.compileBlock(o, that);
    }
    return code;
  };
  return Try;
}(Node));
exports.Switch = Switch = (function(superclass){
  var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;
  function Switch(type, topic, cases, $default){
    var last, ref$;
    this.type = type;
    this.topic = topic;
    this.cases = cases;
    this['default'] = $default;
    if (type === 'match') {
      if (topic) {
        this.target = Arr(topic);
      }
      this.topic = null;
    } else {
      if (topic) {
        if (topic.length > 1) {
          throw "can't have more than one topic in switch statement";
        }
        this.topic = this.topic[0];
      }
    }
    if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {
      this.cases.pop();
      this['default'] = last.body;
    }
  }
  prototype.children = ['topic', 'cases', 'default'];
  prototype.aSource = 'topic';
  prototype.aTargets = ['cases'];
  prototype.show = function(){
    return this.type;
  };
  prototype.isStatement = YES;
  prototype.isCallable = function(){
    var i$, ref$, len$, c;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      if (!c.isCallable()) {
        return false;
      }
    }
    return (ref$ = this['default']) != null ? ref$.isCallable() : void 8;
  };
  prototype.getJump = function(ctx){
    var i$, ref$, len$, c, that;
    ctx || (ctx = {});
    ctx['break'] = true;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      if (that = c.body.getJump(ctx)) {
        return that;
      }
    }
    return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
  };
  prototype.makeReturn = function(it){
    var i$, ref$, len$, c;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      c.makeReturn(it);
    }
    if ((ref$ = this['default']) != null) {
      ref$.makeReturn(it);
    }
    return this;
  };
  prototype.compileNode = function(o){
    var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
    tab = this.tab;
    if (this.target) {
      ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
    }
    topic = this.type === 'match'
      ? (t = target
        ? [targetNode]
        : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
      : !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);
    code = "switch (" + topic + ") {\n";
    stop = this['default'] || this.cases.length - 1;
    o['break'] = true;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      i = i$;
      c = ref$[i$];
      code += c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target);
    }
    if (this['default']) {
      o.indent = tab + TAB;
      if (that = this['default'].compile(o, LEVEL_TOP)) {
        code += tab + ("default:\n" + that + "\n");
      }
    }
    return code + tab + '}';
  };
  return Switch;
}(Node));
exports.Case = Case = (function(superclass){
  var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;
  function Case(tests, body){
    this.tests = tests;
    this.body = body;
  }
  prototype.children = ['tests', 'body'];
  prototype.isCallable = function(){
    return this.body.isCallable();
  };
  prototype.makeReturn = function(it){
    var ref$, ref1$;
    if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
      this.body.makeReturn(it);
    }
    return this;
  };
  prototype.compileCase = function(o, tab, nobr, bool, type, target){
    var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft;
    tests = [];
    for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {
      test = ref$[i$];
      test = test.expandSlice(o).unwrap();
      if (test instanceof Arr && type !== 'match') {
        for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {
          t = ref1$[j$];
          tests.push(t);
        }
      } else {
        tests.push(test);
      }
    }
    tests.length || tests.push(Literal('void'));
    if (type === 'match') {
      for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
        i = i$;
        test = tests[i$];
        tar = Chain(target).add(Index(Literal(i), '.', true));
        tests[i] = Chain(test).autoCompare(target ? [tar] : null);
      }
    }
    if (bool) {
      binary = type === 'match' ? '&&' : '||';
      t = tests[0];
      i = 0;
      while (that = tests[++i]) {
        t = Binary(binary, t, that);
      }
      tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
    }
    code = '';
    for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
      t = tests[i$];
      code += tab + ("case " + t.compile(o, LEVEL_PAREN) + ":\n");
    }
    lines = this.body.lines;
    last = lines[lines.length - 1];
    if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
      lines[lines.length - 1] = JS('// fallthrough');
    }
    o.indent = tab += TAB;
    if (that = this.body.compile(o, LEVEL_TOP)) {
      code += that + '\n';
    }
    if (!(nobr || ft || last instanceof Jump)) {
      code += tab + 'break;\n';
    }
    return code;
  };
  return Case;
}(Node));
exports.If = If = (function(superclass){
  var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;
  function If($if, then, un){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$['if'] = $if;
    this$.then = then;
    this$.un = un;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['if', 'then', 'else'];
  prototype.aSource = 'if';
  prototype.aTargets = ['then'];
  prototype.show = function(){
    return this.un && '!';
  };
  prototype.terminator = '';
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
    var ref$;
    return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();
  });
  prototype.getJump = function(it){
    var ref$;
    return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
  };
  prototype.makeReturn = function(it){
    this.then = this.then.makeReturn(it);
    if (this['else'] != null) {
      this['else'] = this['else'].makeReturn(it);
    }
    return this;
  };
  prototype.compileNode = function(o){
    if (this.un) {
      this['if'] = this['if'].invert();
    } else {
      this.soak || this.anaphorize();
    }
    if (o.level) {
      return this.compileExpression(o);
    } else {
      return this.compileStatement(o);
    }
  };
  prototype.compileStatement = function(o){
    var code, els;
    code = "if (" + this['if'].compile(o, LEVEL_PAREN) + ") ";
    o.indent += TAB;
    code += this.compileBlock(o, Block(this.then));
    if (!(els = this['else'])) {
      return code;
    }
    return code + ' else ' + (els instanceof constructor
      ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
      : this.compileBlock(o, els));
  };
  prototype.compileExpression = function(o){
    var thn, els, code, pad;
    thn = this.then, els = this['else'] || Literal('void');
    this['void'] && (thn['void'] = els['void'] = true);
    if (!this['else'] && (this.cond || this['void'])) {
      return Parens(Binary('&&', this['if'], thn)).compile(o);
    }
    code = this['if'].compile(o, LEVEL_COND);
    pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
    code += pad + "? " + thn.compile(o, LEVEL_LIST) + "" + pad + ": " + els.compile(o, LEVEL_LIST);
    if (o.level < LEVEL_COND) {
      return code;
    } else {
      return "(" + code + ")";
    }
  };
  If.unfoldSoak = function(o, parent, name){
    var that;
    if (that = parent[name].unfoldSoak(o)) {
      parent[name] = that.then;
      return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
    }
  };
  return If;
}(Node));
exports.Label = Label = (function(superclass){
  var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;
  function Label(label, it){
    var fun;
    this.label = label || '_';
    this.it = it;
    if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {
      fun.name || (fun.name = this.label, fun.labeled = true);
      return it;
    }
  }
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
  prototype.show = function(){
    return this.label;
  };
  prototype.isStatement = YES;
  prototype.getJump = function(ctx){
    var ref$;
    ctx || (ctx = {});
    ((ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []).push(this.label);
    return this.it.getJump((ctx['break'] = true, ctx));
  };
  prototype.makeReturn = function(it){
    this.it = this.it.makeReturn(it);
    return this;
  };
  prototype.compileNode = function(o){
    var label, it, labels;
    label = this.label, it = this.it;
    labels = o.labels = slice$.call(o.labels || []);
    if (in$(label, labels)) {
      this.carp("duplicate label \"" + label + "\"");
    }
    labels.push(label);
    it.isStatement() || (it = Block(it));
    return (label + ": ") + (it instanceof Block
      ? (o.indent += TAB, this.compileBlock(o, it))
      : it.compile(o));
  };
  return Label;
}(Node));
exports.Cascade = Cascade = (function(superclass){
  var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;
  function Cascade(input, output){
    this.input = input;
    this.output = output;
  }
  prototype.children = ['input', 'output'];
  prototype.terminator = '';
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
    return this.output[it]();
  });
  prototype.getJump = function(it){
    return this.output.getJump(it);
  };
  prototype.makeReturn = function(ret){
    this.ret = ret;
    return this;
  };
  prototype.compileNode = function(o){
    var level, input, output, ref, ref$, code, out;
    level = o.level;
    input = this.input, output = this.output, ref = this.ref;
    if ('ret' in this || level && !this['void']) {
      output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
    }
    if ('ret' in this) {
      output = output.makeReturn(this.ret);
    }
    if (ref) {
      output = Assign(Arr(), output);
    } else {
      this.temps = [ref = o.scope.temporary('x')];
    }
    if (input instanceof Cascade) {
      input.ref = ref;
    } else {
      input = Assign(JS(ref), input);
    }
    o.level && (o.level = LEVEL_PAREN);
    code = input.compile(o);
    o.ref = new String(ref);
    out = Block(output).compile(o);
    o.ref.erred || this.carp("unreferred cascadee");
    if (!level) {
      return code + "" + input.terminator + "\n" + out;
    }
    code += ", " + out;
    if (level > LEVEL_PAREN) {
      return "(" + code + ")";
    } else {
      return code;
    }
  };
  return Cascade;
}(Node));
exports.JS = JS = (function(superclass){
  var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;
  function JS(code, literal, comment){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.code = code;
    this$.literal = literal;
    this$.comment = comment;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.show = function(){
    if (this.comment) {
      return this.code;
    } else {
      return "`" + this.code + "`";
    }
  };
  prototype.terminator = '';
  prototype.isAssignable = prototype.isCallable = function(){
    return !this.comment;
  };
  prototype.compile = function(it){
    if (this.literal) {
      return entab(this.code, it.indent);
    } else {
      return this.code;
    }
  };
  return JS;
}(Node));
exports.Require = Require = (function(superclass){
  var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;
  function Require(body){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.body = body;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['body'];
  prototype.compile = function(o){
    var chain, stripString, getFileName, getValue, processItem, item, this$ = this;
    stripString = function(val){
      var that;
      if (that = /^['"](.*)['"]$/.exec(val)) {
        return that[1];
      } else {
        return val;
      }
    };
    getFileName = function(val){
      var ref$;
      return (ref$ = stripString(val).split('/'))[ref$.length - 1].split('.')[0].replace(/-[a-z]/ig, function(it){
        return it.charAt(1).toUpperCase();
      });
    };
    getValue = function(item){
      var ref$;
      switch (false) {
      case !(item instanceof Key):
        return item.name;
      case !(item instanceof Var):
        return item.value;
      case !(item instanceof Literal):
        return item.value;
      case !(item instanceof Index):
        return getValue(item.key);
      case !(item instanceof Chain):
        if ((ref$ = item.tails) != null && ref$.length) {
          chain = item.tails;
        }
        return getValue(item.head);
      default:
        return item;
      }
    };
    processItem = function(item){
      var ref$, asg, value, main;
      ref$ = (function(){
        var ref$;
        switch (false) {
        case !(item instanceof Prop):
          return [getValue(item.key), item.val];
        case !(item instanceof Chain):
          if ((ref$ = item.tails) != null && ref$.length) {
            chain = item.tails;
            return [(ref$ = item.tails)[ref$.length - 1], item.head];
          } else {
            return [item.head, item.head];
          }
          break;
        default:
          return [item, item];
        }
      }()), asg = ref$[0], value = ref$[1];
      asg = getFileName(getValue(asg));
      value = stripString(getValue(value));
      main = Chain(Var('require')).add(Call([Literal("'" + value + "'")]));
      return Assign(Var(asg), chain ? Chain(main, chain) : main).compile(o);
    };
    if (this.body.items != null) {
      return (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {
          item = ref$[i$];
          results$.push(processItem(item));
        }
        return results$;
      }.call(this)).join(";\n" + o.indent);
    } else {
      return processItem(this.body);
    }
  };
  return Require;
}(Node));
exports.Util = Util = (function(superclass){
  var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;
  function Util(verb){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.verb = verb;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.show = Jump.prototype.show;
  prototype.isCallable = YES;
  prototype.compile = function(){
    return util(this.verb);
  };
  Util.Extends = function(){
    return Call.make(Util('extend'), [arguments[0], arguments[1]]);
  };
  return Util;
}(Node));
exports.Vars = Vars = (function(superclass){
  var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;
  function Vars(vars){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.vars = vars;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.children = ['vars'];
  prototype.makeReturn = THIS;
  prototype.compile = function(o, level){
    var i$, ref$, len$, v, value;
    for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {
      v = ref$[i$], value = v.value;
      if (!(v instanceof Var)) {
        v.carp('invalid variable declaration');
      }
      if (o.scope.check(value)) {
        v.carp("redeclaration of \"" + value + "\"");
      }
      o.scope.declare(value, v);
    }
    return Literal('void').compile(o, level);
  };
  return Vars;
}(Node));
exports.L = function(yylineno, node){
  return node.line = yylineno + 1, node;
};
exports.Decl = function(type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError("empty " + type + " on line " + lno);
  }
  return DECLS[type](nodes);
};
DECLS = {
  'export': function(lines){
    var i, out, node, that, ref$;
    i = -1;
    out = Util('out');
    while (node = lines[++i]) {
      if (node instanceof Block) {
        lines.splice.apply(lines, [i--, 1].concat(slice$.call(node.lines)));
        continue;
      }
      if (that = node instanceof Fun && node.name) {
        lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));
        continue;
      }
      lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))
        ? Assign(Chain(out, [Index(Key(that))]), node)
        : Import(out, node);
    }
    return Block(lines);
  },
  'import': function(lines, all){
    var i$, len$, i, line;
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      i = i$;
      line = lines[i$];
      lines[i] = Import(Literal('this'), line, all);
    }
    return Block(lines);
  },
  importAll: function(it){
    return this['import'](it, true);
  },
  'const': function(lines){
    var i$, len$, node;
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      node = lines[i$];
      node.op === '=' || node.carp('invalid constant variable declaration');
      node['const'] = true;
    }
    return Block(lines);
  },
  'var': Vars
};
function Scope(parent, shared){
  this.parent = parent;
  this.shared = shared;
  this.variables = {};
}
ref$ = Scope.prototype;
ref$.READ_ONLY = {
  'const': 'constant',
  'function': 'function',
  undefined: 'undeclared'
};
ref$.add = function(name, type, node){
  var t, that;
  if (node && (t = this.variables[name + "."])) {
    if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {
      node.carp("redeclaration of " + that + " \"" + name + "\"");
    } else if (t === type && type === 'arg') {
      node.carp("duplicate parameter \"" + name + "\"");
    } else if (t === 'upvar') {
      node.carp("accidental shadow of \"" + name + "\"");
    }
    if (t == 'arg' || t == 'function') {
      return name;
    }
  }
  this.variables[name + "."] = type;
  return name;
};
ref$.get = function(name){
  return this.variables[name + "."];
};
ref$.declare = function(name, node, constant){
  var that, scope;
  if (that = this.shared) {
    if (this.check(name)) {
      return;
    }
    scope = that;
  } else {
    scope = this;
  }
  return scope.add(name, constant ? 'const' : 'var', node);
};
ref$.assign = function(name, value){
  return this.add(name, {
    value: value
  });
};
ref$.temporary = function(name){
  var ref$;
  name || (name = 'ref');
  while ((ref$ = this.variables[name + "$."]) != 'reuse' && ref$ != void 8) {
    name = name.length < 2 && name < 'z'
      ? String.fromCharCode(name.charCodeAt() + 1)
      : name.replace(/\d*$/, fn$);
  }
  return this.add(name + '$', 'var');
  function fn$(it){
    return ++it;
  }
};
ref$.free = function(name){
  return this.add(name, 'reuse');
};
ref$.check = function(name, above){
  var type, ref$;
  if ((type = this.variables[name + "."]) || !above) {
    return type;
  }
  return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;
};
ref$.checkReadOnly = function(name){
  var that, ref$, key$;
  if (that = this.READ_ONLY[this.check(name, true)]) {
    return that;
  }
  (ref$ = this.variables)[key$ = name + "."] || (ref$[key$] = 'upvar');
  return '';
};
ref$.emit = function(code, tab){
  var vrs, asn, fun, name, ref$, type, that, val;
  vrs = [];
  asn = [];
  fun = [];
  for (name in ref$ = this.variables) {
    type = ref$[name];
    name = name.slice(0, -1);
    if (type == 'var' || type == 'const' || type == 'reuse') {
      vrs.push(name);
    } else if (that = type.value) {
      if (~(val = entab(that, tab)).lastIndexOf('function(', 0)) {
        fun.push("function " + name + val.slice(8));
      } else {
        asn.push(name + " = " + val);
      }
    }
  }
  if (that = vrs.concat(asn).join(', ')) {
    code = tab + "var " + that + ";\n" + code;
  }
  if (that = fun.join("\n" + tab)) {
    return code + "\n" + tab + that;
  } else {
    return code;
  }
};
function YES(){
  return true;
}
function NO(){
  return false;
}
function THIS(){
  return this;
}
function VOID(){}
UTILS = {
  clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
  extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.extended(sub);\n  return sub;\n}',
  bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
  'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}',
  importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
  repeatString: 'function(str, n){\n  for (var r = \'\'; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n  return r;\n}',
  repeatArray: 'function(arr, n){\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\n    if (n & 1) r.push.apply(r, arr);\n  return r;\n}',
  'in': 'function(x, arr){\n  var i = -1, l = arr.length >>> 0;\n  while (++i < l) if (x === arr[i] && i in arr) return true;\n  return false;\n}',
  out: 'typeof exports != \'undefined\' && exports || this',
  curry: 'function(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      curry$.call(this, f, params) : f.apply(this, params);\n  } : f;\n}',
  compose: 'function(fs){\n  return function(){\n    var i, args = arguments;\n    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }\n    return args[0];\n  };\n}',
  flip: 'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}',
  partialize: 'function(f, args, where){\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ? partialize$(f, ta, tw) : f.apply(this, ta);\n  };\n}',
  not: 'function(x){ return !x; }',
  deepEq: 'function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case \'[object String]\': return a == String(b);\n      case \'[object Number]\':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case \'[object Date]\':\n      case \'[object Boolean]\':\n        return +a == +b;\n      case \'[object RegExp]\':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != \'object\' || typeof b != \'object\') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == \'[object Array]\') {\n      alength = a.length;\n      blength = b.length;\n      if (first) { \n        switch (type) {\n        case \'===\': result = alength === blength; break;\n        case \'<==\': result = alength <= blength; break;\n        case \'<<=\': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if (\'constructor\' in a != \'constructor\' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === \'<<=\') {\n            result = size < sizeB;\n          } else if (type === \'<==\') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}',
  split: "''.split",
  replace: "''.replace",
  toString: '{}.toString',
  join: '[].join',
  slice: '[].slice',
  splice: '[].splice'
};
LEVEL_TOP = 0;
LEVEL_PAREN = 1;
LEVEL_LIST = 2;
LEVEL_COND = 3;
LEVEL_OP = 4;
LEVEL_CALL = 5;
(function(){
  this['&&'] = this['||'] = this['xor'] = 0.2;
  this['.&.'] = this['.^.'] = this['.|.'] = 0.3;
  this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;
  this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = this['+++'] = 0.5;
  this['<<='] = this['>>='] = this['<=='] = this['>=='] = 0.5;
  this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;
  this['+'] = this['-'] = 0.7;
  this['*'] = this['/'] = this['%'] = 0.8;
}.call(PREC = {
  unary: 0.9
}));
TAB = '  ';
ID = /^(?!\d)[\w$\xAA-\uFFDC]+$/;
SIMPLENUM = /^\d+$/;
function util(it){
  return Scope.root.assign(it + '$', UTILS[it]);
}
function entab(code, tab){
  return code.replace(/\n/g, '\n' + tab);
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function in$(x, arr){
  var i = -1, l = arr.length >>> 0;
  while (++i < l) if (x === arr[i] && i in arr) return true;
  return false;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
});

require.define("/node_modules/LiveScript/lib/node.js",function(require,module,exports,__dirname,__filename,process,global){var split$ = ''.split;
module.exports = function(LiveScript){
  var fs, path;
  fs = require('fs');
  path = require('path');
  LiveScript.run = function(code, options, js){
    var filename, main, dirname, ref$, e;
    if (options != null) {
      filename = options.filename;
    }
    main = require.main;
    if (filename) {
      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
    } else {
      dirname = filename = '.';
    }
    main.paths = main.constructor._nodeModulePaths(dirname);
    main.filename = filename;
    js || (code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$)));
    try {
      return main._compile(code, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, code, filename);
    }
  };
  importAll$(LiveScript, require('events').EventEmitter.prototype);
  require.extensions['.ls'] = function(module, filename){
    var js, e;
    js = LiveScript.compile(fs.readFileSync(filename, 'utf8'), {
      filename: filename,
      bare: true
    });
    try {
      return module._compile(js, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, js, filename);
    }
  };
};
function hackTrace(error, js, filename){
  var stack, traces, i$, len$, i, trace, index, lno, end, length, lines, j$, ref$, n;
  if (error != null) {
    stack = error.stack;
  }
  if (!stack) {
    return error;
  }
  traces = split$.call(stack, '\n');
  if (!(traces.length > 1)) {
    return error;
  }
  for (i$ = 0, len$ = traces.length; i$ < len$; ++i$) {
    i = i$;
    trace = traces[i$];
    if (0 > (index = trace.indexOf("(" + filename + ":"))) {
      continue;
    }
    lno = (/:(\d+):/.exec(trace.slice(index + filename.length)) || '')[1];
    if (!(lno = +lno)) {
      continue;
    }
    length = ('' + (end = lno + 4)).length;
    lines || (lines = split$.call(js, '\n'));
    for (j$ = 1 > (ref$ = lno - 4) ? 1 : ref$; j$ <= end; ++j$) {
      n = j$;
      traces[i] += "\n" + ('    ' + n).slice(-length) + "" + '|+'.charAt(n === lno) + " " + [lines[n - 1]];
    }
  }
  return error.stack = traces.join('\n'), error;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
});

require.define("/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {
  "name": "coffee2ls",
  "author": "George Zahariev",
  "version": "0.1.0",
  "homepage": "https://github.com/gkz/coffee2ls",
  "bugs": "https://github.com/gkz/coffee2ls/issues",
  "description": "Compile CoffeeScript into LiveScript",
  "keywords": [
    "coffee2ls",
    "livescript",
    "coffeescript",
    "javascript",
    "language",
    "compiler"
  ],
  "main": "./lib/coffee2ls/module",
  "bin": {
    "coffee2ls": "./bin/coffee2ls"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gkz/coffee2ls.git"
  },
  "scripts": {
    "build": "make -j build",
    "test": "make -j test"
  },
  "devDependencies": {
    "mocha": "~1.6.0",
    "pegjs": "git://github.com/michaelficarra/CoffeeScriptRedux.git#pegjs",
    "browserify": "~1.16"
  },
  "dependencies": {
    "StringScanner": "~0.0.3"
  },
  "optionalDependencies": {
    "coffee2ls-codegen": ">= 0.1.0",
    "LiveScript": ">= 1.1.0",
    "CoffeeScriptRedux": "~2.0.0",
    "uglify-js": "~1.3.4",
    "js2coffee": "0.1.3"
  },
  "engines": { "node": "0.6.x || 0.8.x" },
  "licenses": [
    {
      "type": "3-clause BSD",
      "url": "https://raw.github.com/gkz/coffee2ls/master/LICENSE"
    }
  ],
  "license": "3-clause BSD"
}
;

});

require.define("/lib/coffee2ls/module.js",function(require,module,exports,__dirname,__filename,process,global){// Generated by CoffeeScript 2.0.0-dev
var codegen, coffee2ls, coffee2ls, formatParserError, fs, LiveScript, Nodes, Parser, path, pkg, Preprocessor;
fs = require('fs');
path = require('path');
formatParserError = require('./helpers').formatParserError;
Nodes = require('./nodes');
Preprocessor = require('./preprocessor').Preprocessor;
Parser = require('./parser');
codegen = require('coffee2ls-codegen');
LiveScript = require('LiveScript');
coffee2ls = null;
pkg = require('./../../package.json');
module.exports = {
  Parser: Parser,
  Preprocessor: Preprocessor,
  Nodes: Nodes,
  VERSION: pkg.version,
  parse: function (coffee, options) {
    var e, parsed, preprocessed;
    if (null == options)
      options = {};
    try {
      preprocessed = Preprocessor.processSync(coffee);
      return parsed = Parser.parse(preprocessed);
    } catch (e$) {
      e = e$;
      if (!options.suppress)
        console.log('Error parsing CoffeeScript');
      if (!(e instanceof Parser.SyntaxError))
        throw e;
      throw new Error(formatParserError(preprocessed, e));
    }
  },
  js2coffee: function (js, options) {
    var e;
    if (null == options)
      options = {js: {}};
    try {
      return eval('require("js2coffee")').build(js, options.js);
    } catch (e$) {
      e = e$;
      if (!options.suppress) {
        console.log('Error with JavaScript -> CoffeeScript compilation');
        console.log(js);
      }
      throw e;
    }
  },
  ls: function (csAst, options) {
    var e;
    if (null == options)
      options = {};
    try {
      return codegen.generate(csAst);
    } catch (e$) {
      e = e$;
      if (!options.suppress) {
        console.log('Error with CoffeeScript AST -> LiveScript compilation');
        console.log(csAst);
      }
      throw e;
    }
  },
  compile: function (csAst, options) {
    if (null == options)
      options = {};
    return this.ls(csAst, options);
  },
  ls2js: function (ls, options) {
    var e;
    if (null == options)
      options = {ls: {bare: true}};
    try {
      return LiveScript.compile(ls, options.ls);
    } catch (e$) {
      e = e$;
      if (!options.suppress) {
        console.log('Error with LiveScript -> JavaScript compilation');
        console.log(ls);
      }
      throw e;
    }
  },
  coffee2js: function (coffee, options) {
    if (null == options)
      options = {};
    return this.ls2js(this.ls(this.parse(coffee, options), options), options);
  },
  run: function (coffee, options) {
    var e;
    try {
      return eval(this.coffee2js(coffee, options));
    } catch (e$) {
      e = e$;
      if (!options.suppress) {
        console.log('Error attempting to eval JavaScript compiled from CoffeeScript');
        console.log(coffee);
      }
      throw e;
    }
  }
};
coffee2ls = module.exports.coffee2ls = module.exports;
if (null != ('undefined' !== typeof require && null != require ? require.extensions : void 0))
  require.extensions['.coffee'] = function (module, filename) {
    var input;
    input = fs.readFileSync(filename, 'utf8');
    return module._compile(coffee2ls.coffee2js(input), filename);
  };
if ('undefined' !== typeof window && null != window)
  window.coffee2ls = coffee2ls;

});
require("/lib/coffee2ls/module.js");
})();

